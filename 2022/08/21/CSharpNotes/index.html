<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="CSharpNotes, 8yyy&#39;s blog">
    <meta name="description" content="1. C#程序结构一个 C# 程序主要包括以下几个部分：

命名空间声明；
一个类（class）；
类方法；
类属性；
一个 Main 方法；
语句和表达式；
注释。

using System;

namespace test1
&amp;#12">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>CSharpNotes | 8yyy&#39;s blog</title>
    <link rel="icon" type="image/png" href="https://cdn.jsdelivr.net/gh/8yyy/8yyy.github.io/favicon.png">

    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/8yyy/8yyy.github.io/libs/awesome/css/all.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/8yyy/8yyy.github.io/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/8yyy/8yyy.github.io/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/8yyy/8yyy.github.io/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/8yyy/8yyy.github.io/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/8yyy/8yyy.github.io/css/matery.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/8yyy/8yyy.github.io/css/my.css">

    <script src="https://cdn.jsdelivr.net/gh/8yyy/8yyy.github.io/libs/jquery/jquery-3.6.0.min.js"></script>

<meta name="generator" content="Hexo 6.3.0"></head>




<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="https://cdn.jsdelivr.net/gh/8yyy/8yyy.github.io/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">8yyy&#39;s blog</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="https://cdn.jsdelivr.net/gh/8yyy/8yyy.github.io/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">8yyy&#39;s blog</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/blinkfox/hexo-theme-matery" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/blinkfox/hexo-theme-matery" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    
<script src="https://cdn.jsdelivr.net/gh/8yyy/8yyy.github.io/libs/cryptojs/crypto-js.min.js"></script>
<script>
    (function() {
        let pwd = 'd39b6d92a4aedc038b37c1c4dc4fe72ad4293ddce0b929690fe5feaae295e0cd';
        if (pwd && pwd.length > 0) {
            if (pwd !== CryptoJS.SHA256(prompt('请输入访问本文章的密码')).toString(CryptoJS.enc.Hex)) {
                alert('密码错误，将返回主页！');
                location.href = '/';
            }
        }
    })();
</script>




<div class="bg-cover pd-header post-cover" style="background-image: url('https://cdn.jsdelivr.net/gh/8yyy/8yyy.github.io/medias/featureimages/2.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">CSharpNotes</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/8yyy/8yyy.github.io/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/CSharp/">
                                <span class="chip bg-color">CSharp</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2022-08-21
                </div>
                

                

                

                

                
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/8yyy/8yyy.github.io/libs/prism/prism.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h2 id="1-C-程序结构"><a href="#1-C-程序结构" class="headerlink" title="1. C#程序结构"></a>1. C#程序结构</h2><p><strong>一个 C# 程序主要包括以下几个部分：</strong></p>
<ul>
<li>命名空间声明；</li>
<li>一个类（class）；</li>
<li>类方法；</li>
<li>类属性；</li>
<li>一个 Main 方法；</li>
<li>语句和表达式；</li>
<li>注释。</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using System;

namespace test1
&#123;
    class Program
    &#123;
        static void Main(string[] args)
        &#123;
            &#x2F;* my first c# program *&#x2F;
            Console.WriteLine(&quot;Hello World!&quot;);
            Console.ReadKey();
        &#125;
    &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>下面我们来看一下上面程序的各个部分</p>
<h4 id="1-using-System"><a href="#1-using-System" class="headerlink" title="1) using System;"></a>1) using System;</h4><p>using 关键字用来在程序中引入 System 命名空间，一个程序中可以有多个 using 语句。</p>
<h4 id="2-namespace-test1"><a href="#2-namespace-test1" class="headerlink" title="2) namespace test1"></a>2) namespace test1</h4><p>namespace 关键字用来声明一个命名空间，“test1”则是命名空间的名字。命名空间是类的集合，上面代码中名为“test1”的命名空间中包含了一个名为“Program”的类。</p>
<h4 id="3-class-Program"><a href="#3-class-Program" class="headerlink" title="3) class Program"></a>3) class Program</h4><p>class 关键字用来定义一个类，“Program”则是类的名称，类中通常用来存放程序中要使用的数据和函数（也叫方法）。</p>
<h4 id="4-static-void-Main-string-args"><a href="#4-static-void-Main-string-args" class="headerlink" title="4) static void Main(string[] args)"></a>4) static void Main(string[] args)</h4><p>此行代码中，Main 为定义的函数名称，Main 函数是整个 C# 程序的入口，其中包含了程序运行时需要执行的操作。static 和 void 都是用来修饰 Main 函数的关键字。</p>
<h4 id="5-my-first-c-program"><a href="#5-my-first-c-program" class="headerlink" title="5)/* my first c# program */"></a>5)/* my first c# program */</h4><p>这是程序的注释，当程序运行时被<code>/* */</code>包裹的内容将被编译器忽略，不会执行。注释主要用来对我们所写的代码进行说明。</p>
<h4 id="6-Console-WriteLine-“Hello-World-”"><a href="#6-Console-WriteLine-“Hello-World-”" class="headerlink" title="6) Console.WriteLine(“Hello World!”);"></a>6) Console.WriteLine(“Hello World!”);</h4><p>此行代码用来在命令行窗口中输出“Hello World!”。WriteLine 是 System 命名空间中定义的 Console 类里面的方法，用来输出一些消息。</p>
<h4 id="7-Console-ReadKey"><a href="#7-Console-ReadKey" class="headerlink" title="7) Console.ReadKey();"></a>7) Console.ReadKey();</h4><p>此行代码是针对 VS.NET 用户的，它会 <strong>使程序进入等待状态</strong>，敲击键盘上的任意一个按键即可让程序继续运行。之所以需要这行代码，是因为命令行窗口会在程序运行结束后自动关闭，这会导致我们想要输出的内容一闪而过，加入此行代码则可以避免这种情况。</p>
<p>按F5即可执行</p>
<h2 id="2-C-基本的语法"><a href="#2-C-基本的语法" class="headerlink" title="2. C#基本的语法"></a>2. C#基本的语法</h2><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using System;

namespace test1
&#123;
    class Rectangle
    &#123;
        &#x2F;&#x2F;成员变量
        double length;
        double width;

        &#x2F;&#x2F;成员函数
        public void Acceptdetails() &#123;
            length &#x3D; 4.5;
            width &#x3D; 3.5;
        &#125;
        
        public double GetArea() &#123;
            return length * width;
        &#125;

        public void Diskplay()
        &#123;
            Console.WriteLine(&quot;length:&#123;0&#125;&quot;,length);
            Console.WriteLine(&quot;width:&#123;0&#125;&quot;, width);
            Console.WriteLine(&quot;Area:&#123;0&#125;&quot;, GetArea());
        &#125;
    &#125;

    class ExecuteRectangle
    &#123;
        static void Main(string[] args)
        &#123;
            &#x2F;&#x2F;类的实例化
            Rectangle r &#x3D; new Rectangle();
            r.Acceptdetails();
            r.Diskplay();
            Console.ReadKey();
        &#125;
    &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h4><p>成员变量是用来存储类中要使用的数据或属性的。在上面的示例程序中，Rectangle 类中包含两个成员变量，分别是 length 和 width。</p>
<h4 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h4><p>成员函数（也可以称为成员方法）是执行特定任务的语句集，一个类的成员函数需要在类中声明。上面的示例代码中，Rectangle 类包含三个成员函数，分别是 AcceptDetails、GetArea 和 Display。</p>
<h4 id="类的实例化"><a href="#类的实例化" class="headerlink" title="类的实例化"></a>类的实例化</h4><p>通过一个已有的类（class）创建出这个类的对象（object）的过程叫做类的实例化。类的实例化需要使用 new 关键字，例如上面示例中第 26 行就创建了一个 Rectangle 类的对象。</p>
<h2 id="3-C-关键字"><a href="#3-C-关键字" class="headerlink" title="3. C#关键字"></a>3. C#关键字</h2><p>C# 中的关键字是编译器预先定义好的一些单词，也可以称为保留字或者保留标识符，这些关键字对编译器有特殊的意义，不能用作标识符。但是，如果您非要使用的话也不是没有办法，只需要在关键字前面加上<code>@</code>前缀即可，例如<code>@if</code>就是一个有效的标识符，而<code>if</code>则是一个关键字。</p>
<p>在 C# 中，有些关键字在代码的上下文中具有特殊的意义，例如 get 和 set，这样的关键字被称为上下文关键字（contextual keywords）。一般来说，C# 语言中新增的关键字都会作为上下文关键字，这样可以避免影响到使用旧版语言编写的 C# 程序。</p>
<p>下表列出了 C# 中的保留关键字（Reserved Keywords）和上下文关键字（Contextual Keywords）：</p>
<table>
<thead>
<tr>
<th>保留关键字</th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>abstract</td>
<td>as</td>
<td>base</td>
<td>bool</td>
<td>break</td>
<td>byte</td>
<td>case</td>
</tr>
<tr>
<td>catch</td>
<td>char</td>
<td>checked</td>
<td>class</td>
<td>const</td>
<td>continue</td>
<td>decimal</td>
</tr>
<tr>
<td>default</td>
<td>delegate</td>
<td>do</td>
<td>double</td>
<td>else</td>
<td>enum</td>
<td>event</td>
</tr>
<tr>
<td>explicit</td>
<td>extern</td>
<td>false</td>
<td>finally</td>
<td>fixed</td>
<td>float</td>
<td>for</td>
</tr>
<tr>
<td>foreach</td>
<td>goto</td>
<td>if</td>
<td>implicit</td>
<td>in</td>
<td>in (generic modifier)</td>
<td>int</td>
</tr>
<tr>
<td>interface</td>
<td>internal</td>
<td>is</td>
<td>lock</td>
<td>long</td>
<td>namespace</td>
<td>new</td>
</tr>
<tr>
<td>null</td>
<td>object</td>
<td>operator</td>
<td>out</td>
<td>out (generic modifier)</td>
<td>override</td>
<td>params</td>
</tr>
<tr>
<td>private</td>
<td>protected</td>
<td>public</td>
<td>readonly</td>
<td>ref</td>
<td>return</td>
<td>sbyte</td>
</tr>
<tr>
<td>sealed</td>
<td>short</td>
<td>sizeof</td>
<td>stackalloc</td>
<td>static</td>
<td>string</td>
<td>struct</td>
</tr>
<tr>
<td>switch</td>
<td>this</td>
<td>throw</td>
<td>true</td>
<td>try</td>
<td>typeof</td>
<td>uint</td>
</tr>
<tr>
<td>ulong</td>
<td>unchecked</td>
<td>unsafe</td>
<td>ushort</td>
<td>using</td>
<td>virtual</td>
<td>void</td>
</tr>
<tr>
<td>volatile</td>
<td>while</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>上下文关键字</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>add</td>
<td>alias</td>
<td>ascending</td>
<td>descending</td>
<td>dynamic</td>
<td>from</td>
<td>get</td>
</tr>
<tr>
<td>global</td>
<td>group</td>
<td>into</td>
<td>join</td>
<td>let</td>
<td>orderby</td>
<td>partial (type)</td>
</tr>
<tr>
<td>partial (method)</td>
<td>remove</td>
<td>select</td>
<td>set</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="4-C-数据类型"><a href="#4-C-数据类型" class="headerlink" title="4. C#数据类型"></a>4. C#数据类型</h2><p>C# 语言中内置了一些基本的数据类型，数据类型用来指定程序中变量可以存储的数据的类型，C# 中的数据类型可以大致分为三类：</p>
<ul>
<li>值类型（Value types）；</li>
<li>引用类型（References types）；</li>
<li>指针类型（Pointer types）。</li>
</ul>
<p>如果想要获取类型或变量的确切大小，可以使用 sizeof 方法</p>
<p>例如sizeof(int)，结果为4</p>
<h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><p><strong>引用类型的变量中并不存储实际的数据值</strong>，而是存储的对数据（对象）的引用，换句话说就是，<strong>引用类型的变量中存储的是数据在内存中的位置</strong>。当多个变量都引用同一个内存地址时，如果其中一个变量改变了内存中数据的值，那么所有引用这个内存地址的变量的值都会改变。C# 中内置的引用类型包括 Object（对象）、Dynamic（动态）和 string（字符串）。</p>
<h4 id="1-对象类型（Object）"><a href="#1-对象类型（Object）" class="headerlink" title="1) 对象类型（Object）"></a>1) 对象类型（Object）</h4><p>对象类型是 C# 通用类型系统（Common Type System：CTS）中所有数据类型的最终基类，Object 是 System.Object 类的别名。任何类型的值都可以分配给对象类型，但是在分配值之前，需要对类型进行转换。</p>
<p>将值类型转换为对象类型的过程被称为“装箱”，反之将对象类型转换为值类型的过程则被称为“拆箱”。注意，只有经过装箱的数据才能进行拆箱。</p>
<h4 id="2-动态类型（Dynamic）"><a href="#2-动态类型（Dynamic）" class="headerlink" title="2) 动态类型（Dynamic）"></a>2) 动态类型（Dynamic）</h4><p>您可以在动态类型的变量中存储任何类型的值，这些变量的类型检查是在程序运行时进行的。动态类型的声明语法如下所示：</p>
<p>dynamic <variable_name> = value;</variable_name></p>
<p>例如：</p>
<p>dynamic d = 20;</p>
<p>动态类型与对象类型类似，但对象类型变量的类型检查是在编译时进行的，而动态类型变量的类型检查则是在程序运行时进行的。</p>
<h4 id="3-字符串类型（String）"><a href="#3-字符串类型（String）" class="headerlink" title="3) 字符串类型（String）"></a>3) 字符串类型（String）</h4><p>字符串类型的变量允许您将一个字符串赋值给这个变量，字符串类型需要通过 String 类来创建，String 类是 System.String 类的别名，它是从对象（Object）类型中派生的。**在 C# 中有两种定义字符串类型的方式，分别是使用<code>&quot; &quot;</code>和<code>@&quot; &quot;</code>**。</p>
<p>示例代码如下：</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;使用引号的声明方式
String str &#x3D; &quot;http:&#x2F;&#x2F;c.biancheng.net&#x2F;&quot;;
&#x2F;&#x2F;使用 @ 加引号的声明形式
String str &#x3D; @&quot;http:&#x2F;&#x2F;c.biancheng.net&#x2F;&quot;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>使用<code>@&quot; &quot;</code>形式声明的字符串称为“逐字字符串”，逐字字符串会将转义字符<code>\</code>当作普通字符对待</strong>，例如<code>string str = @&quot;C:\Windows&quot;;</code>等价于<code>string str = &quot;C:\\Windows&quot;;</code>。</p>
<p>另外，在<code>@&quot; &quot;</code>形式声明的字符串中可以任意使用换行，换行符及缩进空格等都会计算在字符串的长度之中。</p>
<h2 id="5-C-变量"><a href="#5-C-变量" class="headerlink" title="5. C#变量"></a>5. C#变量</h2><table>
<thead>
<tr>
<th>类型</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>整型（整数类型）</td>
<td>sbyte、byte、short、ushort、int、uint、long、ulong、char</td>
</tr>
<tr>
<td>浮点型</td>
<td>float、double</td>
</tr>
<tr>
<td>十进制类型</td>
<td>decimal</td>
</tr>
<tr>
<td>布尔型</td>
<td>true、false</td>
</tr>
<tr>
<td>空类型</td>
<td>可为空值的数据类型</td>
</tr>
</tbody></table>
<p>C# 中变量的名称并不是可以随意定义的，需要遵循如下所示的规则：</p>
<ul>
<li>变量名中可以包含英文字母<code>a-z, A-Z</code>、数字<code>0-9</code>和下划线<code>_</code>；</li>
<li>变量名只能以英文字母<code>a-z, A-Z</code>或下划线<code>_</code>开头，不能以数字开头；</li>
<li>变量名中不允许使用空格；</li>
<li>变量名不能是任何 C# 中的保留字或关键字，例如 char、float 等。</li>
<li>变量名命名我们一般遵循<strong>驼峰命名法</strong>，即以<strong>小写字母开头</strong>，多个单词拼接时，除第一个单词外，其余<strong>首字母大写</strong></li>
</ul>
<h3 id="接受用户输入的值"><a href="#接受用户输入的值" class="headerlink" title="接受用户输入的值"></a>接受用户输入的值</h3><p>上面的示例代码中我们使用到了一个名为 ReadLine() 的函数，它是由 System 命名空间中的 Console 类提供的，使用 ReadLine() 函数可以接受来自用户输入的内容并将其存储到变量中。</p>
<p>示例代码如下：</p>
<pre class="line-numbers language-none"><code class="language-none">using System;
namespace c.biancheng.net&#123;
    class Program &#123;
        static void Main(string[] args) &#123;
            int a, b;
            Console.WriteLine(&quot;请输入第一个数字：&quot;);
            a &#x3D; Convert.ToInt32(Console.ReadLine());
            Console.WriteLine(&quot;请输入第二个数字：&quot;);
            b &#x3D; Convert.ToInt32(Console.ReadLine());
            Console.WriteLine(&quot;&#123;0&#125;+&#123;1&#125;&#x3D;&#123;2&#125;&quot;, a, b, a+b);
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>因为使用 <strong>Console.ReadLine() 接收的数据是字符串格式</strong>的，所以示例中我们需要使用 <strong>Convert.ToInt32() 函数来将用户输入的数据转换为 int 类型</strong>。</p>
<h2 id="6-C-数据类型转换"><a href="#6-C-数据类型转换" class="headerlink" title="6. C#数据类型转换"></a>6. C#数据类型转换</h2><p>数据类型转换就是将一种类型的数据转换为另一种类型，在 C# 中有  <strong>两种</strong>  形式的类型转换方式，分别是  <strong>隐式类型转换</strong>  和  <strong>显示类型转换</strong></p>
<h3 id="1、隐式类型转换"><a href="#1、隐式类型转换" class="headerlink" title="1、隐式类型转换"></a>1、隐式类型转换</h3><p>隐式类型转换是由 C# 以类型安全的方式执行的，转换的过程中不会导致数据丢失，例如从较 **小 **的整数类型（例如 int） <strong>转</strong>  换到较 **大 **的整数类型（例如 long），从派生类转换为基类。</p>
<p>隐式转换不需要我们编写额外的代码，下例中演示了如何使用隐式类型转换的方式将 int 类型的数据转换成 double 类型：</p>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">int a &#x3D; 10;
double b &#x3D; a;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>提示：一种数据类型（类型 A），只要其取值范围 <strong>完全包含</strong> 在另一种数据类型（类型 B）的取值范围内，那么类型 A 就可以隐式转换为类型 B。基于这一特性，C# 的隐式类型转换不会导致数据丢失。</p>
<h3 id="2、显式类型转换"><a href="#2、显式类型转换" class="headerlink" title="2、显式类型转换"></a>2、显式类型转换</h3><p>显式类型转换也叫 <strong>强制类型转换</strong> ，这种转换需要使用<code>(type)value</code>的形式或者预定义函数显式的完成，显式转换需要用户明确的指定要转换的类型，而且在转换的过程中可能会造成数据丢失，例如将 double 类型转换为 int 类型。</p>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">double d&#x3D;56.23;
int i &#x3D; (int)d;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>结果为56</p>
<p><code>int.Parse(string)</code> : 只支持将string类型转成int，Parse就是将int,char,double…等将</p>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">string st&#x3D;&quot;56.21&quot;;
Int.Parse(st);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p><font color="red">这是一种错误的写法，会报错Input string was not in a correct format，输入的格式错误，注意这里只能输入<code>int</code>的字符串</font></p>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">string st&#x3D;&quot;56&quot;;		&#x2F;&#x2F;这是正确的写法
Int.Parse(st);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p><code>Convert.ToInt32(double value)</code>：<strong>不完全遵循四舍五入</strong>，如果value为两个整数中间的数，返回两者中的偶数</p>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">Console.WriteLine(Convert.ToInt32(4.3));
&#x2F;&#x2F;四舍五入，结果为4 
Console.WriteLine(Convert.ToInt32(4.5));
&#x2F;&#x2F;4.5为4和5中间的数，输出偶数4         
Console.WriteLine(Convert.ToInt32(4.53));
&#x2F;&#x2F;四舍五入，结果为5        
Console.WriteLine(Convert.ToInt32(5.5));
&#x2F;&#x2F;5.5为5和6中间的数，输出偶数6      
Console.WriteLine(Convert.ToInt32(5.53));
&#x2F;&#x2F;四舍五入，结果为6
Console.WriteLine(Convert.ToInt32(null));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>运行结果如下：</p>
<pre class="line-numbers language-none"><code class="language-none">4
4
5
6
6
0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>Convert.ToInt32()和int.Parse()对于空值(null)的处理不同Convert.ToInt32(null)会返回0而不会产生异常，int.Parse(null)则会产生异常:System.ArgumentNullException:“Value cannot be null. ”</code></p>
<p>C# 中还提供了一系列内置的类型转换方法，如下表所示：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>ToBoolean</td>
<td>将类型转换为布尔型</td>
</tr>
<tr>
<td>ToByte</td>
<td>将类型转换为字节类型</td>
</tr>
<tr>
<td>ToChar</td>
<td>将类型转换为单个 Unicode 字符类型</td>
</tr>
<tr>
<td>ToDateTime</td>
<td>将类型（整数或字符串类型）转换为日期时间的结构</td>
</tr>
<tr>
<td>ToDecimal</td>
<td>将浮点型或整数类型转换为十进制类型</td>
</tr>
<tr>
<td>ToDouble</td>
<td>将类型转换为双精度浮点型</td>
</tr>
<tr>
<td>ToInt16</td>
<td>将类型转换为 16 位整数类型</td>
</tr>
<tr>
<td>ToInt32</td>
<td>将类型转换为 32 位整数类型</td>
</tr>
<tr>
<td>ToInt64</td>
<td>将类型转换为 64 位整数类型</td>
</tr>
<tr>
<td>ToSbyte</td>
<td>将类型转换为有符号字节类型</td>
</tr>
<tr>
<td>ToSingle</td>
<td>将类型转换为小浮点数类型</td>
</tr>
<tr>
<td>ToString</td>
<td>将类型转换为字符串类型</td>
</tr>
<tr>
<td>ToType</td>
<td>将类型转换为指定类型</td>
</tr>
<tr>
<td>ToUInt16</td>
<td>将类型转换为 16 位无符号整数类型</td>
</tr>
<tr>
<td>ToUInt32</td>
<td>将类型转换为 32 位无符号整数类型</td>
</tr>
<tr>
<td>ToUInt64</td>
<td>将类型转换为 64 位无符号整数类型</td>
</tr>
</tbody></table>
<h2 id="7-C-运算符"><a href="#7-C-运算符" class="headerlink" title="7. C#运算符"></a>7. C#运算符</h2><p>运算符其实就是一个符号，用来告诉编译器执行特定的数学或逻辑运算。C# 中内置了丰富的运算符，大致可以分为如下几类：</p>
<ul>
<li>算术运算符；</li>
<li>关系运算符；</li>
<li>逻辑运算符；</li>
<li>位运算符；</li>
<li>赋值运算符；</li>
<li>其它运算符。</li>
</ul>
<h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><p>算术运算符即完成特定算术运算的符号，C# 中支持的算术运算符如下表所示：（假设变量 A = 10，变量 B = 20）</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>实例</th>
</tr>
</thead>
<tbody><tr>
<td>+</td>
<td>加法运算符，对运算符左右两边的操作数执行加法操作</td>
<td>A + B 值为 30</td>
</tr>
<tr>
<td>-</td>
<td>减法运算符，对运算符左右两边的操作数执行减法操作</td>
<td>A - B 值为 -10</td>
</tr>
<tr>
<td>*</td>
<td>乘法运算符，将运算符左右两边的操作数相乘</td>
<td>A * B 值为 200</td>
</tr>
<tr>
<td>/</td>
<td>除法运算符，使用运算符左边的操作数除以右边的操作数</td>
<td>B / A 值为 2</td>
</tr>
<tr>
<td>%</td>
<td>取模运算符，整除后的余数</td>
<td>B % A 值为 0</td>
</tr>
<tr>
<td>++</td>
<td>自增运算符，整数值增加 1</td>
<td>A++ 值为 11</td>
</tr>
<tr>
<td>–</td>
<td>自减运算符，整数值减少 1</td>
<td>A– 值为 9</td>
</tr>
</tbody></table>
<p><code>与C/C++不同的是，/和%支持float、double等类型的变量</code></p>
<p>例如：</p>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">Console.WriteLine(5.42 &#x2F; 3);
         Console.WriteLine(6 &#x2F; 3);
         Console.WriteLine(5 &#x2F; 2.5);
         Console.WriteLine(9 &#x2F; 1.1);
         Console.WriteLine(5.42 % 3);
         Console.WriteLine(6 % 3);
         Console.WriteLine(5 % 2.5);
         Console.WriteLine(9 % 1.1);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>运行结果如下：</p>
<pre class="line-numbers language-none"><code class="language-none">1.8066666666666666
2
2
8.181818181818182
2.42
0
0
0.1999999999999993<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><p>位运算符用来对 <strong>二进制</strong> 位进行操作，＆、| 和 ^ 的真值表如下：</p>
<table>
<thead>
<tr>
<th>p</th>
<th>q</th>
<th>p &amp; q</th>
<th>p | q</th>
<th>p ^ q</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
</tbody></table>
<p>下表列举了 C# 中支持的位运算符：（假设变量 A = 60，变量 B = 13）</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>实例</th>
</tr>
</thead>
<tbody><tr>
<td>&amp;</td>
<td>按位与，对两个操作数的二进制位进行按位与运算，即当两个数对应的二进制位均为 1 时，结果位为 1，否则为 0</td>
<td>(A &amp; B) 将得到 12，即为 0000 1100</td>
</tr>
<tr>
<td>|</td>
<td>按位或，对两个操作数的二进制位进行按位或运算，即当两个数对应的二进制位有一个为 1 时，结果就为 1，否则为 0</td>
<td>(A | B) 将得到 61，即为 0011 1101</td>
</tr>
<tr>
<td>^</td>
<td>按位异或，对两个操作数的二进制位进行按位异或运算，即当两个数对应的二进制位不同时，结果为 1，否则为 0</td>
<td>(A ^ B) 将得到 49，即为 0011 0001</td>
</tr>
<tr>
<td>~</td>
<td>按位取反，该运算符具有”翻转”位效果，即 0 变成 1，1 变成 0，包括符号位</td>
<td>(~A ) 将得到 -61，即为 1100 0011</td>
</tr>
<tr>
<td>&lt;&lt;</td>
<td>二进制左移运算符，左操作数的值向左移动右操作数指定的位数</td>
<td>A &lt;&lt; 2 将得到 240，即为 1111 0000</td>
</tr>
<tr>
<td>&gt;&gt;</td>
<td>二进制右移运算符，左操作数的值向右移动右操作数指定的位数</td>
<td>A &gt;&gt; 2 将得到 15，即为 0000 1111</td>
</tr>
</tbody></table>
<pre class="line-numbers language-C#" data-language="C#"><code class="language-C#">using System;
namespace c.biancheng.net
&#123;
    class Demo
    &#123;
        static void Main(string[] args)
        &#123;
            int a &#x3D; 60;            &#x2F;* 60 &#x3D; 0011 1100 *&#x2F; 
            int b &#x3D; 13;            &#x2F;* 13 &#x3D; 0000 1101 *&#x2F;
            int c &#x3D; 0;         
            c &#x3D; a &amp; b;           &#x2F;* 12 &#x3D; 0000 1100 *&#x2F;
            Console.WriteLine(&quot;a &amp; b 的值是 &#123;0&#125;&quot;, c );
            c &#x3D; a | b;           &#x2F;* 61 &#x3D; 0011 1101 *&#x2F;
            Console.WriteLine(&quot;a | b 的值是 &#123;0&#125;&quot;, c);
            c &#x3D; a ^ b;           &#x2F;* 49 &#x3D; 0011 0001 *&#x2F;
            Console.WriteLine(&quot;a ^ b 的值是 &#123;0&#125;&quot;, c);
            c &#x3D; ~a;               &#x2F;*-61 &#x3D; 1100 0011 *&#x2F;
            Console.WriteLine(&quot;~a 的值是 &#123;0&#125;&quot;, c);
            c &#x3D; a &lt;&lt; 2;     &#x2F;* 240 &#x3D; 1111 0000 *&#x2F;
            Console.WriteLine(&quot;a &lt;&lt; 2 的值是 &#123;0&#125;&quot;, c);
            c &#x3D; a &gt;&gt; 2;     &#x2F;* 15 &#x3D; 0000 1111 *&#x2F;
            Console.WriteLine(&quot;a &gt;&gt; 2 的值是 &#123;0&#125;&quot;, c);
            Console.ReadLine();
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>运行结果如下：</p>
<pre class="line-numbers language-none"><code class="language-none">a &amp; b 的值是 12
a | b 的值是 61
a ^ b 的值是 49
~a 的值是 -61
a &lt;&lt; 2 的值是 240
a &gt;&gt; 2 的值是 15<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><p>赋值运算符顾名思义就是用来为变量赋值的，下表列举了 C# 中支持的赋值运算符：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>实例</th>
</tr>
</thead>
<tbody><tr>
<td>=</td>
<td>最简单的赋值运算符，把右边操作数的值赋给左边的操作数</td>
<td>C = A + B 将把 A + B 的值赋给 C</td>
</tr>
<tr>
<td>+=</td>
<td>加且赋值运算符，把右边操作数加上左边操作数的结果赋值给左边操作数</td>
<td>C += A 相当于 C = C + A</td>
</tr>
<tr>
<td>-=</td>
<td>减且赋值运算符，把左边操作数减去右边操作数的结果赋值给左边操作数</td>
<td>C -= A 相当于 C = C - A</td>
</tr>
<tr>
<td>*=</td>
<td>乘且赋值运算符，把右边操作数乘以左边操作数的结果赋值给左边操作数</td>
<td>C *= A 相当于 C = C * A</td>
</tr>
<tr>
<td>/=</td>
<td>除且赋值运算符，把左边操作数除以右边操作数的结果赋值给左边操作数</td>
<td>C /= A 相当于 C = C / A</td>
</tr>
<tr>
<td>%=</td>
<td>求模且赋值运算符，求两个操作数的模并赋值给左边操作数</td>
<td>C %= A 相当于 C = C % A</td>
</tr>
<tr>
<td>&lt;&lt;=</td>
<td>左移且赋值运算符</td>
<td>C &lt;&lt;= 2 等同于 C = C &lt;&lt; 2</td>
</tr>
<tr>
<td>&gt;&gt;=</td>
<td>右移且赋值运算符</td>
<td>C &gt;&gt;= 2 等同于 C = C &gt;&gt; 2</td>
</tr>
<tr>
<td>&amp;=</td>
<td>按位与且赋值运算符</td>
<td>C &amp;= 2 等同于 C = C &amp; 2</td>
</tr>
<tr>
<td>^=</td>
<td>按位异或且赋值运算符</td>
<td>C ^= 2 等同于 C = C ^ 2</td>
</tr>
<tr>
<td>|=</td>
<td>按位或且赋值运算符</td>
<td>C |= 2 等同于 C = C | 2</td>
</tr>
</tbody></table>
<h3 id="其他运算符"><a href="#其他运算符" class="headerlink" title="其他运算符"></a>其他运算符</h3><p>除了上面介绍的运算符之外，C# 中还支持一些其他的重要运算符，如下表所示：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>实例</th>
</tr>
</thead>
<tbody><tr>
<td>sizeof()</td>
<td>返回数据类型的大小</td>
<td>sizeof(int)，将返回 4</td>
</tr>
<tr>
<td>typeof()</td>
<td>返回 class 的类型</td>
<td>typeof(StreamReader);</td>
</tr>
<tr>
<td>&amp;</td>
<td>返回变量的地址</td>
<td>&amp;a 将得到变量的实际地址</td>
</tr>
<tr>
<td>*</td>
<td>变量的指针</td>
<td>*a; 将指向一个变量。</td>
</tr>
<tr>
<td>? :</td>
<td>三元（三目）运算符</td>
<td>a&gt;b ? X : Y; 如果条件为真，则值为 X : 否则值为 Y</td>
</tr>
<tr>
<td>is</td>
<td>判断对象是否为某一类型</td>
<td>if( Ford is Car) // 检查 Ford 是否是 Car 类的一个对象</td>
</tr>
<tr>
<td>as</td>
<td>强制转换，即使转换失败也不会抛出异常。</td>
<td>Object obj = new StringReader(“Hello”); StringReader r = obj as StringReader;</td>
</tr>
</tbody></table>
<p><strong>关于三目运算</strong></p>
<p>在C/C++中可以这么写</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;bits&#x2F;stdc++.h&gt;
using namespace std;

int main()&#123;
	int a&#x3D;2,b&#x3D;1,t;
	a&gt;b?t&#x3D;a:t&#x3D;b;
	cout&lt;&lt;t;
	return 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>但在C#中就不能这么写</p>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using System;

namespace test1
&#123;
    class test
    &#123;
        static void Main(string[] args)
                &#123;
                    int a &#x3D; 2, b &#x3D; 1, t;
                    a &gt; b ? t &#x3D; a : t &#x3D; b;
                    &#x2F;&#x2F;会报错
                    Console.WriteLine(&quot;t&#x3D;&#123;0&#125;&quot;, t);
                &#125;
     &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p> <font color="red">编译器错误消息: CS0201: 只有 assignment、call、increment、decrement 和 new 对象表达式可用作语句</font></p>
<p>只能写成</p>
<pre class="line-numbers language-C#" data-language="C#"><code class="language-C#">using System;

namespace test1
&#123;
    class test
    &#123;
        static void Main(string[] args)
                &#123;
                    int a &#x3D; 2, b &#x3D; 1, t;
                    t &#x3D; a &gt; b ? a : b;
                    Console.WriteLine(&quot;t&#x3D;&#123;0&#125;&quot;, t);
                &#125;
     &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h2 id="8-C-常量"><a href="#8-C-常量" class="headerlink" title="8. C#常量"></a>8. C#常量</h2><p>常量和我们前面介绍的《<a target="_blank" rel="noopener" href="http://m.biancheng.net/csharp/variable.html">变量</a>》类似，唯一不同的是常量的值在程序的编译阶段就已经确定了，而且在程序的运行期间不允许修改。常量可以是任何基本数据类型，例如整数常量、浮点常量、字符串常量等等。</p>
<h3 id="1）定义常量"><a href="#1）定义常量" class="headerlink" title="1）定义常量"></a>1）定义常量</h3><p>常量需要使用  <strong>const</strong>  关键字定义，语法格式如下所示：</p>
<p>const data_type constant_name = value;</p>
<p>其中，data_type 为常量的数据类型；constant_name 为常量名（类似于变量名）；value 为常量的值。</p>
<h3 id="2）整数常量"><a href="#2）整数常量" class="headerlink" title="2）整数常量"></a>2）整数常量</h3><p>整数常量可以是 <strong>八进制、十进制或者十六进制</strong>，可以使用前缀指定具体的进制，例如<code>0x</code>或<code>0X</code>表示 <strong>十六进制</strong>，<code>0</code>表示 <strong>八进制</strong>，没有前缀则表示 <strong>十进制</strong> 。</p>
<p><strong>除了前缀外，整数常量还可以包含后缀</strong> ，后缀可以是 U 和 L 的组合，U 和 L 分别表示 unsigned 和 long。后缀既可以大写也可以小写，而且可以以任意顺序进行组合，但是不能重复。</p>
<p>下面列举了一些整数常量的示例：</p>
<pre class="line-numbers language-none"><code class="language-none">85    &#x2F;&#x2F; 合法：十进制常量
0213  &#x2F;&#x2F; 合法：八进制常量
0x4b  &#x2F;&#x2F; 合法：十六进制常量
30    &#x2F;&#x2F; 合法：int 类型常量
30u   &#x2F;&#x2F; 合法：无符号 int 类型常量
30l   &#x2F;&#x2F; 合法：long 类型常量
30ul  &#x2F;&#x2F; 合法：无符号 long 类型常量
068   &#x2F;&#x2F; 非法：8 不是一个八进制数字
032UU  &#x2F;&#x2F; 非法：后缀不能重复<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-C#" data-language="C#"><code class="language-C#">using System;


namespace test1
&#123;
    
    class test
    &#123;
        static void Main(string[] args)
        &#123;
            int a &#x3D; 66;
            int b &#x3D; 0100;
            int t &#x3D; a &gt; b ? 10 : 8;
            Console.WriteLine(&quot;t&#x3D;&#123;0&#125;&quot;, t);
            Console.ReadKey();
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面这个例子，a为十进制66，b为八进制100，既十进制为64，结果应为10，但是编译器给的结果是8，可见不能直接用&gt;直接比较10进制数和8进制数。</p>
<h3 id="3）浮点常量"><a href="#3）浮点常量" class="headerlink" title="3）浮点常量"></a>3）浮点常量</h3><p>浮点常量由整数部分、小数点、小数部分和指数部分组成。您可以用小数或指数形式来表示浮点常量。</p>
<p>下面列举了一些浮点常量的示例：</p>
<pre class="line-numbers language-none"><code class="language-none">3.14159       &#x2F;&#x2F; 合法
314159E-5    &#x2F;&#x2F; 合法，等价于3.14159
510E         &#x2F;&#x2F; 非法：不完全指数
210f         &#x2F;&#x2F; 非法：没有小数或指数
.e55         &#x2F;&#x2F; 非法：缺少整数或小数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>当使用小数形式表示浮点常量时，必须包含小数点、指数或同时包含两者。当使用指数形式表示浮点常量时，必须包括整数部分、小数部分或同时包含两者。有符号的指数使用 e 或 E 表示。</p>
<h4 id="浮点数精度问题"><a href="#浮点数精度问题" class="headerlink" title="浮点数精度问题"></a>浮点数精度问题</h4><p><strong>解决方案是使用【decimal】</strong></p>
<pre class="line-numbers language-C#" data-language="C#"><code class="language-C#">using System;


namespace test1
&#123;
    
    class test
    &#123;
        static void Main(string[] args)
        &#123;
            double x &#x3D; 88.8;
            double y &#x3D; 88;
            Console.WriteLine(&quot;失去精度结果为:&#123;0&#125;&quot;, x - y);
            decimal d1 &#x3D; decimal.Parse(&quot;88.8&quot;);
            decimal d2 &#x3D; decimal.Parse(&quot;88&quot;);
            Console.WriteLine(&quot;decimal计算结果为:&#123;0&#125;&quot;, d1 - d2);
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>结果为：</p>
<p><img src="/source/images/c-sharp/image-20220822113001755.png" alt="image-20220822113001755"></p>
<h3 id="4）字符常量"><a href="#4）字符常量" class="headerlink" title="4）字符常量"></a>4）字符常量</h3><p>字符常量需要使用单引号括起来，类似于定义字符串类型的变量，例如<code>&#39;x&#39;</code>。一个字符常量可以是一个普通字符（例如<code>&#39;x&#39;</code>）、转义序列（例如<code>&#39;\t&#39;</code>）或 Unicode 字符（例如<code>&#39;\u02C0&#39;</code>）。</p>
<p>在 C# 中，有些字符前面带有一个反斜杠，这样的字符具有特殊含义，例如<code>\n</code>用于表示换行符、<code>\t</code>表示制表符。下表中列举了一些常用的转义字符：</p>
<table>
<thead>
<tr>
<th>转义序列</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>\</td>
<td>\ 字符</td>
</tr>
<tr>
<td>&#39;</td>
<td>‘ 字符</td>
</tr>
<tr>
<td>&quot;</td>
<td>“ 字符</td>
</tr>
<tr>
<td>?</td>
<td>? 字符</td>
</tr>
<tr>
<td>\a</td>
<td>Alert 或 bell</td>
</tr>
<tr>
<td>\b</td>
<td>退格键（Backspace）</td>
</tr>
<tr>
<td>\f</td>
<td>换页符（Form feed）</td>
</tr>
<tr>
<td>\n</td>
<td>换行符（Newline）</td>
</tr>
<tr>
<td>\r</td>
<td>回车</td>
</tr>
<tr>
<td>\t</td>
<td>水平制表符 tab</td>
</tr>
<tr>
<td>\v</td>
<td>垂直制表符 tab</td>
</tr>
<tr>
<td>\ooo</td>
<td>一到三位的八进制字符</td>
</tr>
<tr>
<td>\xhh . . .</td>
<td>一个或多个数字的十六进制字符</td>
</tr>
</tbody></table>
<p>下面通过示例演示一下转义字符的使用：</p>
<pre class="line-numbers language-C#" data-language="C#"><code class="language-C#">using System;


namespace test1
&#123;
    
    class test
    &#123;
        static void Main(string[] args)
        &#123;         
            Console.WriteLine(&quot;a\nb\nc\n2333\t666&quot;);
            Console.ReadKey();
        &#125;
    &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>结果如下：</p>
<pre class="line-numbers language-none"><code class="language-none">a
b
c
2333    666<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="5）字符串常量"><a href="#5）字符串常量" class="headerlink" title="5）字符串常量"></a>5）字符串常量</h3><p>字符串常量需要使用双引号<code>&quot; &quot;</code>或<code>@&quot; &quot;</code>引起来。字符串常量与字符常量相似，可以是纯字符、转义序列或 Unicode 字符。</p>
<h2 id="9-C-循环示例"><a href="#9-C-循环示例" class="headerlink" title="9. C#循环示例"></a>9. C#循环示例</h2><h3 id="1）for循环"><a href="#1）for循环" class="headerlink" title="1）for循环"></a>1）for循环</h3><pre class="line-numbers language-C#" data-language="C#"><code class="language-C#">using System;


namespace test1
&#123;
    
    class test
    &#123;
        static void Main(string[] args)
        &#123;          
            for(int i &#x3D; 1; i &lt; 10; i++)
            &#123;
                for(int j &#x3D; i; j &lt; 10; j++)
                &#123;
                    Console.Write(&quot;&#123;0&#125; x &#123;1&#125; &#x3D; &#123;2&#125;  &quot;, i, j, i * j);
                &#125;
                Console.WriteLine();&#x2F;&#x2F;换行
            &#125;
            Console.ReadKey();
        &#125;
    &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h3 id="2）While-循环"><a href="#2）While-循环" class="headerlink" title="2）While 循环"></a>2）While 循环</h3><pre class="line-numbers language-C#" data-language="C#"><code class="language-C#">using System;
namespace test1
&#123;
    
    class test
    &#123;
        static void Main(string[] args)
        &#123;
            int i &#x3D; 1;
            while (i &lt;&#x3D; 9)
            &#123;
                int j &#x3D; 1;
                while (j &lt;&#x3D; i)
                &#123;
                    Console.Write(&quot;&#123;0&#125; x &#123;1&#125; &#x3D; &#123;2&#125;  &quot;, j, i, i * j);
                    j++;
                &#125;
                i++;
                Console.WriteLine();
            &#125;
            Console.ReadKey();
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>结果如下：</p>
<pre class="line-numbers language-none"><code class="language-none">1 x 1 &#x3D; 1  1 x 2 &#x3D; 2  1 x 3 &#x3D; 3  1 x 4 &#x3D; 4  1 x 5 &#x3D; 5  1 x 6 &#x3D; 6  1 x 7 &#x3D; 7  1 x 8 &#x3D; 8  1 x 9 &#x3D; 9
2 x 2 &#x3D; 4  2 x 3 &#x3D; 6  2 x 4 &#x3D; 8  2 x 5 &#x3D; 10  2 x 6 &#x3D; 12  2 x 7 &#x3D; 14  2 x 8 &#x3D; 16  2 x 9 &#x3D; 18
3 x 3 &#x3D; 9  3 x 4 &#x3D; 12  3 x 5 &#x3D; 15  3 x 6 &#x3D; 18  3 x 7 &#x3D; 21  3 x 8 &#x3D; 24  3 x 9 &#x3D; 27
4 x 4 &#x3D; 16  4 x 5 &#x3D; 20  4 x 6 &#x3D; 24  4 x 7 &#x3D; 28  4 x 8 &#x3D; 32  4 x 9 &#x3D; 36
5 x 5 &#x3D; 25  5 x 6 &#x3D; 30  5 x 7 &#x3D; 35  5 x 8 &#x3D; 40  5 x 9 &#x3D; 45
6 x 6 &#x3D; 36  6 x 7 &#x3D; 42  6 x 8 &#x3D; 48  6 x 9 &#x3D; 54
7 x 7 &#x3D; 49  7 x 8 &#x3D; 56  7 x 9 &#x3D; 63
8 x 8 &#x3D; 64  8 x 9 &#x3D; 72
9 x 9 &#x3D; 81<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="3）foreach循环"><a href="#3）foreach循环" class="headerlink" title="3）foreach循环"></a>3）foreach循环</h3><p>除了前面介绍的几种循环语句外，C# 同样也支持 foreach 循环，使用 foreach 可以遍历数组或者集合对象中的每一个元素，其语法格式如下：</p>
<p>foreach(数据类型 变量名 in 数组或集合对象){<br>  语句块;<br>}</p>
<p>foreach 会在每次循环的过程中，依次从数组或集合对象中取出一个新的元素放到<code>foreach( )</code>里定义的变量中，直到所有元素都成功取出后退出循环。</p>
<pre class="line-numbers language-C#" data-language="C#"><code class="language-C#">using System;


namespace test1
&#123;
    
    class test
    &#123;
        static void Main(string[] args)
        &#123;
            int[] a &#x3D; new int[] &#123; 1, 2, 3, 4, 5 &#125;;
            foreach(int i in a)
            &#123;
                Console.Write(&quot;&#123;0&#125;  &quot;, i);
            &#125;
            Console.ReadKey();
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>运行结果如下：</p>
<p>1  2  3  4  5</p>
<h2 id="10-C-函数-方法"><a href="#10-C-函数-方法" class="headerlink" title="10. C#函数/方法"></a>10. C#函数/方法</h2><p>C# 中的函数（也可以称为方法）是一段具有签名（由函数名、参数类型和参数修饰符组成的函数信息）的代码块，可以用来实现特定的功能。一般情况下一个函数由以下几个部分组成：</p>
<ul>
<li>访问权限修饰符：用于指定函数对一个类的可见性；</li>
<li>返回值类型：用于指定函数返回值的数据类型；</li>
<li>函数名称：用于进行函数调用的唯一名称；</li>
<li>参数列表：在调用函数时需要传递给函数的参数，参数列表是可选的，可以为空；</li>
<li>函数主体：其中包含了实现函数功能的若干代码。</li>
</ul>
<p><code>函数的命名规则:</code></p>
<ul>
<li>函数命名使用<strong>大驼峰命名</strong>，即开头<strong>首字母大写</strong></li>
<li>多个单词拼接时，所有单词<strong>首字母大写</strong></li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">Add();
AddResult();
GetUserInfo();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>



<h3 id="1）函数声明"><a href="#1）函数声明" class="headerlink" title="1）函数声明"></a>1）函数声明</h3><p>C# 中声明函数的语法格式如下所示：</p>
<pre class="line-numbers language-none"><code class="language-none">Access_Specifier Return_Type FunctionName(Parameter List)
&#123;
  Function_Body
  Return_Statement
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>其中，Access_Specifier 为访问权限修饰符；Return_Type 为返回值类型；FunctionName 为函数名称；Parameter List 为参数列表；Function_Body 为函数主体；Return_Statement 为返回语句，用来返回数据。另外需要注意的是，访问权限修饰符、参数列表和返回语句是可选的，可以省略。</p>
<pre class="line-numbers language-none"><code class="language-none">访问权限修饰符 返回值类型 函数名称（参数列表）
&#123;
	函数主体
	返回语句
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="2）函数调用"><a href="#2）函数调用" class="headerlink" title="2）函数调用"></a>2）函数调用</h3><p>想要调用我们定义好的函数，首先需要将函数所在的类实例化为对象，然后通过<code>对象.函数名() </code>的形式即可调用指定的函数，这里有几点需要注意：</p>
<ul>
<li>若函数在定义时参数列表中定义了若干参数，那么在调用时也应该在函数名后面的括号中填入相应数量的参数，并且与参数列表中的参数类型一一对应；</li>
<li>若函数在定义时没有定义参数列表，那么在调用函数时也不需要在函数名后面填入参数；</li>
<li>对于有返回值的函数，在调用函数时可以使用一个变量（可选）来接收函数的返回值，变量的类型要与函数返回值的类型相同。</li>
</ul>
<p> <strong>提示：若调用同一个类中静态函数（使用 static 修饰的函数），则可以省略实例化对象的过 程，直接使用<code>函数名()</code>的形式调用。</strong></p>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using System;


namespace test1
&#123;
    
    class test
    &#123;
        static void Main(string[] args)
        &#123;
            test t &#x3D; new test(); &#x2F;&#x2F;实例化当前类的对象
            
            t.a();          &#x2F;&#x2F;调用a函数

            string s1 &#x3D; &quot;bbbb&quot;;
            t.b(s1);         &#x2F;&#x2F;调用b函数

            string s2 &#x3D; &quot;cccc&quot;;
            Console.WriteLine(t.c(s2));    &#x2F;&#x2F;调用c函数

            string s3 &#x3D; &quot;dddd&quot;;
            Console.WriteLine(d(s3));       &#x2F;&#x2F;调用类中的静态函数d

        &#125;
        public void a()         &#x2F;&#x2F;没有参数和返回值的函数
        &#123;
            Console.WriteLine(&quot;aaaa&quot;);
        &#125;

        public void b(string s) &#x2F;&#x2F;有参数没有返回值的函数
        &#123;
            Console.WriteLine(s);
        &#125;

        public string c(string s)   &#x2F;&#x2F;有参数且有返回值的函数
        &#123;
            string str &#x3D; s;
            return str;
        &#125;

        static string d(string s)   &#x2F;&#x2F;类中的静态函数，无需实例化即可调用
        &#123;
            string str &#x3D; s;
            return s;
        &#125;
    &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>结果如下：</p>
<pre class="line-numbers language-none"><code class="language-none">aaaa
bbbb
cccc
dddd<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="3）拓展——参数修饰符"><a href="#3）拓展——参数修饰符" class="headerlink" title="3）拓展——参数修饰符"></a>3）拓展——参数修饰符</h3><p>无参数修饰符，<strong>按值进行传递</strong></p>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public int Add(int count)&#123;
	..
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>ref 引用传递</p>
<p>out 输出传递</p>
<h2 id="11-C-封装"><a href="#11-C-封装" class="headerlink" title="11. C#封装"></a>11. C#封装</h2><p>C# 是一门面向对象编程语言，面向对象编程语言有三大特性，分别是 **封装、<a target="_blank" rel="noopener" href="http://m.biancheng.net/csharp/inheritance.html">继承</a>和<a target="_blank" rel="noopener" href="http://m.biancheng.net/csharp/polymorphism.html">多态</a>**。 <strong>所谓封装就是将一个或多个项目（函数）集合在一个单元中，这个单元称之为类</strong>，我们可以根据需要通过访问权限修饰符来设定类中成员的范围和可见性。C# 中的访问权限修饰符有以下几种：</p>
<ul>
<li>public：公共的，所有对象都可以访问，但是需要引用命名空间；</li>
<li>private：私有的，类的内部才可以访问；</li>
<li>internal：内部的，同一个程序集的对象可以访问，程序集就是命名空间；</li>
<li>protected：受保护的，类的内部或类的父类和子类中可以访问；</li>
<li>Protected internal：protected 和 internal 的并集，符合任意一条都可以访问。</li>
</ul>
<h3 id="1）public"><a href="#1）public" class="headerlink" title="1）public"></a>1）public</h3><p>类中使用 public 访问权限修饰符修饰的成员变量或成员函数可以在其他函数和对象，我们可以从类的外部访问类中的公共成员（使用 public 修饰的类成员）。</p>
<h3 id="2）private"><a href="#2）private" class="headerlink" title="2）private"></a>2）private</h3><p>类中使用 private 访问权限修饰符修饰的成员变量或成员函数不能在其它函数或对象访问，即使是类的实例也不能访问这个类中的私有成员，只有 <strong>同属一个类的函数才可以访问</strong> 这个类的私有成员。</p>
<h3 id="3）protected"><a href="#3）protected" class="headerlink" title="3）protected"></a>3）protected</h3><p>类中使用 protected 访问权限修饰符修饰的成员变量和成员函数可以在其子类中访问，也就是说基类（父类）中使用 protected 访问权限修饰符修饰的成员变量和成员函数可以在其子类中访问，这样有助于 <strong>实现继承</strong>。</p>
<h3 id="4）internal"><a href="#4）internal" class="headerlink" title="4）internal"></a>4）internal</h3><p>类中使用 internal 访问权限修饰符修饰的成员变量和成员函数可以在当前程序集中的其他函数或对象中使用。换句话说就是， <strong>任何使用 internal 修饰的成员都可以被同一命名空间下的任何类或方法访问</strong>。</p>
<pre class="line-numbers language-C#" data-language="C#"><code class="language-C#">using System;


namespace test1
&#123;
    
    class test
    &#123;
        static void Main(string[] args)
        &#123;
            &#x2F;&#x2F;实例化对象
            Rectangle rec &#x3D; new Rectangle();
            rec.length &#x3D; 23.3;
            rec.width &#x3D; 23.3;
            rec.Display();
            Console.ReadKey();

        &#125;

    &#125;

    class Rectangle &#x2F;&#x2F;定义一个名为Rectangle的类
    &#123;
        &#x2F;&#x2F;internal修饰的成员变量
        internal double width, length;

        double GetArea()    &#x2F;&#x2F;没有使用任何访问权限修饰符修饰的成员函数 GetArea() 默认是私有的
        &#123;
            return width * length;
        &#125;

        public void Display()
        &#123;
            Console.WriteLine(&quot;长方形的长：&#123;0&#125;&quot;, length);
            Console.WriteLine(&quot;长方形的宽：&#123;0&#125;&quot;, width);
            Console.WriteLine(&quot;长方形的面积：&#123;0&#125;&quot;, GetArea());
        &#125;
    &#125;

&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>结果如下：</p>
<pre class="line-numbers language-none"><code class="language-none">长方形的长：23.3
长方形的宽：23.3
长方形的面积：542.89<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h3 id="5）protected-internal"><a href="#5）protected-internal" class="headerlink" title="5）protected internal"></a>5）protected internal</h3><p>类中使用 protected internal 访问权限修饰符修饰的成员可以在本类、派生类或者包含该类（使用 using 引入）的程序集中访问，在实现继承时也使用此方法。</p>
<h2 id="12-C-值传递、引用传递、输出传递"><a href="#12-C-值传递、引用传递、输出传递" class="headerlink" title="12. C#值传递、引用传递、输出传递"></a>12. C#值传递、引用传递、输出传递</h2><p>通过前面的学习我们知道，在调用带有参数的函数时，需要将参数传递给函数。在介绍这几种传递方式之前，我们先来介绍一下形式参数（形参）和实际参数（实参）这两个概念：</p>
<ul>
<li>形式参数： <strong>在定义函数阶段参数列表中定义的参数称之为形式参数</strong>，简称形参，可以将它看作变量的名称，它没有具体的值，只是用来接收函数调用时传递过来的数据；</li>
<li>实际参数： <strong>在函数被调用时传递给函数的参数称之为实际参数</strong>，简称实参，可以将它看作变量的值，用来为形参赋值。</li>
</ul>
<p>参数可以通过三种方式传递给函数，如下表所示：</p>
<table>
<thead>
<tr>
<th>方式</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>值传递</td>
<td>值传递会复制参数的实际值并赋值给函数的形式参数，实参和形参使用的是两个不同内存位置中的值，<strong>当形参的值发生改变时，不会影响实参的值</strong>，从而保证了实参数据的安全</td>
</tr>
<tr>
<td>引用传递</td>
<td>引用传递会复制参数的内存位置并传递给形式参数，<strong>当形参的值发生改变时，同时也会改变实参的值</strong></td>
</tr>
<tr>
<td>输出传递</td>
<td>输出传递可以一次返回多个值</td>
</tr>
</tbody></table>
<h3 id="1）值传递"><a href="#1）值传递" class="headerlink" title="1）值传递"></a>1）值传递</h3><p>在 C# 中，值传递是将参数传递给函数的默认方式，值传递的本质就是将实参的副本（将实参的值复制一份）传递给函数的形参。当调用函数时，将使用实参为每个形参赋值，并为每个形参创建一个新的存储位置，由于形参和实参指向不同的内存位置，所以无论是修改实参的值还是修改形参的值都不会对彼此造成影响。</p>
<p>下面通过示例来演示一下如何使用值传递的方式将参数传递给函数：</p>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using System;
namespace c.biancheng.net
&#123;
    class Demo
    &#123;
        static void Main(string[] args)&#123;
            int val &#x3D; 10;
            Demo Obj &#x3D; new Demo();
            Console.WriteLine(&quot;调用函数之前：&#123;0&#125;&quot;, val);
            Obj.Func(val);
            Console.WriteLine(&quot;调用函数之后：&#123;0&#125;&quot;, val);
        &#125;
        public void Func(int val)&#123;
            val *&#x3D; val;
            Console.WriteLine(&quot;函数内部的值：&#123;0&#125;&quot;, val);
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>运行结果如下：</p>
<pre class="line-numbers language-none"><code class="language-none">调用函数之前：10
函数内部的值：100
调用函数之后：10<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>通过运行结果可以看出，<strong>尽管我们在函数内部对形参 val 的值进行的修改，但是并不会影响函数外面实参 val 的值。</strong></p>
<h3 id="2）引用传递"><a href="#2）引用传递" class="headerlink" title="2）引用传递"></a>2）引用传递</h3><p>引用传递是对变量内存位置的引用。与值传递不同，使用引用传递的形式传递参数时，并不会为形参创建新的内存地址，而是与实参共同指向相同的内存地址。正因为如此，当修改形参的值时，实参的值也会被修改。</p>
<p>在 C# 中，需要使用 **ref **关键字来使用引用传递，下面通过示例来演示一下：</p>
<pre class="line-numbers language-C#" data-language="C#"><code class="language-C#">using System;
namespace c.biancheng.net
&#123;
    class Demo
    &#123;
        static void Main(string[] args)&#123;
            int val &#x3D; 10;
            Demo Obj &#x3D; new Demo();
            Console.WriteLine(&quot;调用函数之前：&#123;0&#125;&quot;, val);
            Obj.Func(ref val);
            Console.WriteLine(&quot;调用函数之后：&#123;0&#125;&quot;, val);
        &#125;
        public void Func(ref int val)&#123;
            val *&#x3D; val;
            Console.WriteLine(&quot;函数内部的值：&#123;0&#125;&quot;, val);
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>运行结果如下：</p>
<pre class="line-numbers language-none"><code class="language-none">调用函数之前：10
函数内部的值：100
调用函数之后：100<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h3 id="3）输出传递"><a href="#3）输出传递" class="headerlink" title="3）输出传递"></a>3）输出传递</h3><p>使用 return 语句可以从函数中返回一个值，但是使用输出传递则<strong>可以从函数中一次性返回多个值</strong>。输出传递与引用传递相似，不同之处在于输出传递是将数据从函数中传输出来而不是传输到函数中。</p>
<p>在 C# 中，需要使用 <strong>out</strong> 关键字来使用输出传递，下面通过示例来演示一下：</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">using System;
namespace c.biancheng.net
&#123;
    class Demo
    &#123;
        static void Main(string[] args)&#123;
            int val &#x3D; 33;
            Demo Obj &#x3D; new Demo();
            Console.WriteLine(&quot;调用函数之前 val 的值：&#123;0&#125;&quot;, val);
            Obj.getValue(out val);
            Console.WriteLine(&quot;调用函数之后 val 的值：&#123;0&#125;&quot;, val);
        &#125;
        public void getValue(out int x)&#123;
            int temp &#x3D; 11;
            x &#x3D; temp;
            x *&#x3D; x;
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>运行结果如下：</p>
<pre class="line-numbers language-none"><code class="language-none">调用函数之前 val 的值：33
调用函数之后 val 的值：121<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>在使用输出传递时，也可以不为实参赋值，如下例所示：</p>
<pre class="line-numbers language-C#" data-language="C#"><code class="language-C#">using System;
namespace c.biancheng.net
&#123;
    class Demo
    &#123;
        static void Main(string[] args)&#123;
            int a, b;
            Demo Obj &#x3D; new Demo();
            Obj.getValues(out a, out b);
            Console.WriteLine(&quot;调用函数之后 a 的值：&#123;0&#125;&quot;, a);
            Console.WriteLine(&quot;调用函数之后 b 的值：&#123;0&#125;&quot;, b);
        &#125;
        public void getValues(out int x, out int y)&#123;
            Console.WriteLine(&quot;请输入第一个值： &quot;);
            x &#x3D; Convert.ToInt32(Console.ReadLine());
            Console.WriteLine(&quot;请输入第二个值： &quot;);
            y &#x3D; Convert.ToInt32(Console.ReadLine());
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>运行结果如下：</p>
<pre class="line-numbers language-none"><code class="language-none">请输入第一个值：
123
请输入第二个值：
321
调用函数之后 a 的值：123
调用函数之后 b 的值：321<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>ref需要对变量赋初值，而out可以不赋初值</strong></p>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using System;

namespace test
&#123;
    class Program
    &#123;
        static void Main(string[] args)
        &#123;
            int val;
            Program p &#x3D; new Program();
            p.Func(ref val);
            &#x2F;&#x2F;这里会报错，使用了未赋值的局部变量“val”

        &#125;

        public void Func(ref int val)
        &#123;
            val &#x3D; 99;
        &#125;
    &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>如果改成</p>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using System;

namespace test
&#123;
    class Program
    &#123;
        static void Main(string[] args)
        &#123;
            int val;
            Program p &#x3D; new Program();
            p.Func(out val);

        &#125;

        public void Func(out int val)
        &#123;
            val &#x3D; 99;
        &#125;
    &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>则不会报错</p>
<h3 id="4）out-输出-和ref-引用-的区别"><a href="#4）out-输出-和ref-引用-的区别" class="headerlink" title="4）out(输出)和ref(引用)的区别"></a>4）out(输出)和ref(引用)的区别</h3><ul>
<li><code>out</code>修饰的参数<strong>必须在方法内修改</strong>，而<code>ref</code><strong>可以修改也可以不修改</strong></li>
<li><code>out</code>在传入参数的时候，参数是局部变量的话，可以不赋值，因为<code>out</code>一定会对其进行赋值</li>
<li>而<code>ref</code>修饰的参数，在实参<strong>必须有初始值才能进行调用</strong>。因为<code>ref</code>修饰的不一定会对其赋值</li>
</ul>
<h2 id="13-C-nullable：可空类型"><a href="#13-C-nullable：可空类型" class="headerlink" title="13. C# nullable：可空类型"></a>13. C# nullable：可空类型</h2><p>在 C# 1.x 的版本中，一个值类型的变量是不可以被赋值为 null（空值）的，否则会产生异常。而在 C# 2.0 中，新增了一个 nullable 类型，可以使用 nullable 类型定义包含 null 值的数据，例如，您可以在 nullable <Int32>（可为空的 int32 类型）类型的变量中存储 -2147483648 到 2147483647 之间的任何值或者 null。同样，您可以在 nullable <bool>（可为空的 bool 类型）类型的变量中存储 true、false 或 null。声明可空类型的语法如下：</bool></Int32></p>
<pre class="line-numbers language-none"><code class="language-none">data_type? variable_name &#x3D; null;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>其中，data_type 为要声明的数据类型，后面紧跟一个问号；variable_name 则为变量的名称。</p>
<p>【示例】下面通过示例来演示可空类型的用法：</p>
<pre class="line-numbers language-C#" data-language="C#"><code class="language-C#">using System;
namespace c.biancheng.net
&#123;
    class Demo
    &#123;
        static void Main(string[] args)&#123;
            int? num1;
            int? num2 &#x3D; 123;
            num1 &#x3D; null;
        
            double? num3 &#x3D; new double?();
            double? num4 &#x3D; 3.1415926;
            bool? boolval &#x3D; null;
            &#x2F;&#x2F; 输出这些值
            Console.WriteLine(&quot; num1 &#x3D; &#123;0&#125; \r\n num2 &#x3D; &#123;1&#125; \r\n num3 &#x3D; &#123;2&#125; \r\n num4 &#x3D; &#123;3&#125; \r\n boolval &#x3D; &#123;4&#125;&quot;, num1, num2, num3, num4, boolval);
            Console.ReadLine();
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>运行结果如下：</p>
<pre class="line-numbers language-none"><code class="language-none">num1 &#x3D;
num2 &#x3D; 123
num3 &#x3D;
num4 &#x3D; 3.1415926
boolval &#x3D;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="Null-合并运算符（-）"><a href="#Null-合并运算符（-）" class="headerlink" title="Null 合并运算符（??）"></a>Null 合并运算符（??）</h3><p>在 C# 中 Null 合并运算符用于定义可空类型和引用类型的默认值。如果此运算符的左操作数不为 null，那么运算符将返回左操作数，否则返回右操作数。<strong>例如表达式<code>a??b</code>中，如果 a 不为空，那么表达式的值则为 a，反之则为 b。</strong></p>
<p>需要注意的是，Null 合并运算符左右两边操作数的类型必须相同，或者右操作数的类型可以隐式的转换为左操作数的类型，否则将编译错误。</p>
<p>【示例】下面通过示例来演示 Null 合并运算符的使用：</p>
<pre class="line-numbers language-none"><code class="language-none">using System;
namespace c.biancheng.net
&#123;
    class Demo
    &#123;
        static void Main(string[] args)&#123;
            int? num1 &#x3D; null;
            int? num2 &#x3D; 123;
            int num3;
        
            num3 &#x3D; num1 ?? 321;
            Console.WriteLine(&quot;num3 &#x3D; &#123;0&#125;&quot;, num3);
            num3 &#x3D; num2 ?? 321;
            Console.WriteLine(&quot;num3 &#x3D; &#123;0&#125;&quot;, num3);
            Console.ReadLine();
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>运行结果如下：</p>
<pre class="line-numbers language-none"><code class="language-none">num3 &#x3D; 321
num3 &#x3D; 123<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h2 id="14-C-数组"><a href="#14-C-数组" class="headerlink" title="14. C#数组"></a>14. C#数组</h2><h3 id="1）声明数组"><a href="#1）声明数组" class="headerlink" title="1）声明数组"></a>1）声明数组</h3><p>在 C# 中声明一个数组的语法格式如下：</p>
<pre class="line-numbers language-none"><code class="language-none">data_type[] array_name;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>其中，data_type 用来指定数组中元素的类型；<code>[ ]</code>用来指定数组的维度；array_name 为数组的名称。</p>
<p>示例代码如下：</p>
<pre class="line-numbers language-C#" data-language="C#"><code class="language-C#">int[] array1      &#x2F;&#x2F; 声明一个整型数组
double[] array2   &#x2F;&#x2F; 声明一个浮点型数组<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h3 id="2）初始化数组"><a href="#2）初始化数组" class="headerlink" title="2）初始化数组"></a>2）初始化数组</h3><p>仅仅是声明数组还不够，数组只有经过初始化后才可以为其中的每个元素赋值。因为数组是引用类型的，所以您需要使用 new 关键字来对数组进行初始化，例如：</p>
<pre class="line-numbers language-C#" data-language="C#"><code class="language-C#">int[] array1            &#x2F;&#x2F; 声明一个整型数组
array1 &#x3D; new int[10]    &#x2F;&#x2F; 初始化数组 array1
double[] array2         &#x2F;&#x2F; 声明一个浮点型数组
array2 &#x3D; new double[5]  &#x2F;&#x2F; 初始化数组 array2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>另外，数组的声明和初始化还可以放在一起进行，如下所示：</p>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">int[] array1 &#x3D; new int[10]        &#x2F;&#x2F; 初始化一个长度为 10 的整型数组
double[] array2 &#x3D; new double[5]   &#x2F;&#x2F; 初始化一个长度为 5 的浮点型数组<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>提示：初始化数组的过程中，new int[10] 中<code>[ ]</code>里面的数字代表数组的长度，也就是数组中最多可以存放多少个元素，我们可以根据需要来设定数组的长度。</p>
<h3 id="3）为数组元素赋值"><a href="#3）为数组元素赋值" class="headerlink" title="3）为数组元素赋值"></a>3）为数组元素赋值</h3><p>我们可以使用数组的索引来为数组中的各个元素赋值，如下所示：</p>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">int[] arr &#x3D; new int[10];
arr[0] &#x3D; 10;
arr[1] &#x3D; 11;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>单独为数组中的各个元素赋值太过麻烦了，我们也可以在声明数组时直接为数组赋值，只需要将数组中的每个元素依次放入到一个<code>&#123; &#125;</code>中，并将每个元素使用<code>,</code>分隔开即可，如下所示：</p>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">double[] arr1 &#x3D; &#123;96.5, 98.0, 99.5, 90.0&#125;;
int[] arr2 &#x3D; &#123;1, 2, 3, 4, 5, 6, 7, 8, 9&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>使用上面的方法并不用提前设定数组的长度，那如果想要指定数组的长度该怎么办呢？只需要像下面这样即可：</p>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">double[] arr1 &#x3D; new double[4]&#123;96.5, 98.0, 99.5, 90.0&#125;;
int[] arr2 &#x3D; new int[10]&#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>当然像下面这样省略数组的长度也是可以的，例如：</p>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">double[] arr1 &#x3D; new double[]&#123;96.5, 98.0, 99.5, 90.0&#125;;
int[] arr2 &#x3D; new int[]&#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>数组也可以像变量一样，使用一个定义好的数组为另一个相同类型的数组赋值，这种情况下，两个数组将指向相同的内存地址，如下所示：</p>
<pre class="line-numbers language-C#" data-language="C#"><code class="language-C#">int[] arr1 &#x3D; new int[]&#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9&#125;;
int[] arr2 &#x3D; arr1;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>提示：当我们创建一个数组时，C# 的编译器会根据数组类型隐式的为数组中的每个元素初始化一个默认值。例如 int 类型的数组中所有元素都会被初始化为 0。</p>
<h3 id="4）访问数组中的元素"><a href="#4）访问数组中的元素" class="headerlink" title="4）访问数组中的元素"></a>4）访问数组中的元素</h3><p>我们可以通过数组的索引（也可称为下标）来访问数组中的指定元素，只需要在数组名的后面加上一个方括号<code>[ ]</code>，并在其中填写对应的数组索引即可，如下所示：</p>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">int[] arr &#x3D; new int[]&#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9&#125;;
int a &#x3D; arr[0];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h3 id="5）使用-foreach-遍历数组"><a href="#5）使用-foreach-遍历数组" class="headerlink" title="5）使用 foreach 遍历数组"></a>5）使用 foreach 遍历数组</h3><p>前面的示例中我们使用了 <a target="_blank" rel="noopener" href="http://m.biancheng.net/csharp/for.html">for 循环</a>来访问数组中的每个元素，另外还可以使用 <a target="_blank" rel="noopener" href="http://m.biancheng.net/csharp/foreach.html">foreach 循环</a>来遍历数组中的元素，示例代码如下：</p>
<pre class="line-numbers language-C#" data-language="C#"><code class="language-C#">using System;
namespace c.biancheng.net
&#123;
    class Demo
    &#123;
        static void Main(string[] args)&#123;
            int[] arr &#x3D; new int[]&#123;100, 101, 102, 103, 104, 105, 106, 107, 108, 109&#125;;
            int index &#x3D; 0;
            foreach(int i in arr)&#123;
                Console.WriteLine(&quot;arr[&#123;0&#125;] &#x3D; &#123;1&#125;&quot;, index, i);
                index++;
            &#125;
            Console.ReadLine();
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>运行结果如下：</p>
<pre class="line-numbers language-none"><code class="language-none">arr[0] &#x3D; 100
arr[1] &#x3D; 101
arr[2] &#x3D; 102
arr[3] &#x3D; 103
arr[4] &#x3D; 104
arr[5] &#x3D; 105
arr[6] &#x3D; 106
arr[7] &#x3D; 107
arr[8] &#x3D; 108
arr[9] &#x3D; 109<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="15-C-二维数组与多维数组"><a href="#15-C-二维数组与多维数组" class="headerlink" title="15. C#二维数组与多维数组"></a>15. C#二维数组与多维数组</h2><p>C# 中同样支持多维数组（也可称为矩形数组），它可以是二维的，也可以是三维的，多维数组中的数据以类似表格（行、列）的形式存储，因此也被称为矩阵。</p>
<p>要创建多维数组，我们需要在声明数组的方括号内添加逗号，例如：</p>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">int[,] arr&#x3D;new int[3,3];      &#x2F;&#x2F; 声明一个二维数组
int[,,] arr&#x3D;new int[3,3,3];   &#x2F;&#x2F; 声明一个三维数组 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h3 id="1）初始化二维数组"><a href="#1）初始化二维数组" class="headerlink" title="1）初始化二维数组"></a>1）初始化二维数组</h3><p>二维数组的初始化与一维数组类似，例如我们要定义一个 3 行 4 列的整型数组，可以使用以下几种方式：</p>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">&#x2F;&#x2F; 第一种方式
int[,] arr &#x3D; new int[3,4]&#123;
  &#123;0, 1, 2, 3&#125;,
  &#123;4, 5, 6, 7&#125;,
  &#123;8, 9, 10, 11&#125;
&#125;;
&#x2F;&#x2F; 第二种方式
int[,] arr &#x3D; new int[,]&#123;
  &#123;0, 1, 2, 3&#125;,
  &#123;4, 5, 6, 7&#125;,
  &#123;8, 9, 10, 11&#125;
&#125;;
&#x2F;&#x2F; 第三种方式
int[,] arr &#x3D; &#123;
  &#123;0, 1, 2, 3&#125;,
  &#123;4, 5, 6, 7&#125;,
  &#123;8, 9, 10, 11&#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="2）访问二维数组种的元素"><a href="#2）访问二维数组种的元素" class="headerlink" title="2）访问二维数组种的元素"></a>2）访问二维数组种的元素</h3><p>二维数组中的元素同样可以通过索引（行索引和列索引）来访问的，例如：</p>
<pre class="line-numbers language-C#" data-language="C#"><code class="language-C#">int[,] arr &#x3D; new int[3,4]&#123;
  &#123;0, 1, 2, 3&#125;,
  &#123;4, 5, 6, 7&#125;,
  &#123;8, 9, 10, 11&#125;
&#125;;

int a &#x3D; arr[1, 0];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>上例中<code>arr[1, 0]</code>代表了数组 arr 中第二行中的第一个元素</strong>。</p>
<h2 id="16-C-交错数组-Jagged-Arrays"><a href="#16-C-交错数组-Jagged-Arrays" class="headerlink" title="16. C#交错数组(Jagged Arrays)"></a>16. C#交错数组(Jagged Arrays)</h2><p>C# 中的交错数组其实就是<strong>元素为数组的数组</strong>，换句话说就是交错数组中的每个元素都可以是维度和大小不同的数组，所以有时交错数组也被称为“数组的数组”。</p>
<h3 id="1）声明交错数组"><a href="#1）声明交错数组" class="headerlink" title="1）声明交错数组"></a>1）声明交错数组</h3><p>交错数组的声明语法如下所示：</p>
<pre class="line-numbers language-none"><code class="language-none">data_type[][] array_name;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>假如要声明一个<strong>具有三个元素的一维交错数组</strong>，并且数组中的每个元素都是一个一维的整型数组，示例代码如下：</p>
<pre class="line-numbers language-none"><code class="language-none">int[][] jaggedArray &#x3D; new int[3][];<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="2）初始化交错数组"><a href="#2）初始化交错数组" class="headerlink" title="2）初始化交错数组"></a>2）初始化交错数组</h3><p>和普通数组相同，交错数组也需要初始化后才可以使用，可以使用下面的方式初始化一个交错数组。</p>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">int[][] jaggedArray &#x3D; new int[3][]; &#x2F;&#x2F; 定义一个交错数组
jaggedArray[0] &#x3D; new int[5];    	&#x2F;&#x2F; 对数组的第一个元素初始化
jaggedArray[1] &#x3D; new int[4];   		&#x2F;&#x2F; 对数组的第二个元素初始化
jaggedArray[2] &#x3D; new int[2];    	&#x2F;&#x2F; 对数组的第三个元素初始化<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面的交错数组中包含三个元素，第一个元素是长度为 5 的整型数组，第二个元素是长度为 4 的整型数组，第三个元素是长度为 2 的整型数组。</p>
<p>除了上面的方法外，还可以直接使用具体的值来填充数组，这种情况下就不需要再设定数组的大小了，如下所示：</p>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">int[][] jaggedArray &#x3D; new int[3][]; 		&#x2F;&#x2F; 定义一个交错数组
jaggedArray[0] &#x3D; new int[] &#123;1, 2, 3, 4, 5&#125;;
jaggedArray[1] &#x3D; new int[] &#123;6, 7, 8, 9&#125;;
jaggedArray[2] &#x3D; new int[] &#123;10, 11&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>还可以在声明数组时，直接将数组初始化，如下所示：</p>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">int[][] jaggedArray &#x3D; new int[][]&#123;
  new int[] &#123;1, 2, 3, 4, 5&#125;,
  new int[] &#123;6, 7, 8, 9&#125;,
  new int[] &#123;10, 11&#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面的声明方式还有一种简写形式，如下所示：</p>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">int[][] jaggedArray &#x3D; &#123;
  new int[] &#123;1, 2, 3, 4, 5&#125;,
  new int[] &#123;6, 7, 8, 9&#125;,
  new int[] &#123;10, 11&#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>注意：不能从元素初始化中省略 new 运算符，因为不存在元素的默认初始化。</strong></p>
<h3 id="3）访问数组中的元素"><a href="#3）访问数组中的元素" class="headerlink" title="3）访问数组中的元素"></a>3）访问数组中的元素</h3><p>以上面定义的交错数组 jaggedArray 为例，可以使用如下所示的方法来获取数组的中每个元素或者为指定的元素赋值：</p>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">int a &#x3D; jaggedArray[0][1]  &#x2F;&#x2F; 变量 a 的值为：2
jaggedArray[2][1] &#x3D; 0      &#x2F;&#x2F; 将交错数组中第三个数组元素中的第二个元素赋值为 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h3 id="4）交错数组和多维数组"><a href="#4）交错数组和多维数组" class="headerlink" title="4）交错数组和多维数组"></a>4）交错数组和多维数组</h3><p>交错数组中的元素不仅可以是一维数组，还可以是多维数组，例如下面的代码中定义了一个包含<strong>三个二维数组元素的一维交错数组</strong>：</p>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">int[][,] jaggedArray &#x3D; new int[3][,]
&#123;
  new int[,] &#123;
    &#123;1, 1&#125;,
    &#123;2, 3&#125;
  &#125;,
  new int[,] &#123;
    &#123;5, 8&#125;,
    &#123;13, 21&#125;,
    &#123;34, 55&#125;
  &#125;,
  new int[,] &#123;
    &#123;89, 144&#125;,
    &#123;233, 377&#125;,
    &#123;610, 987&#125;
  &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>对于这样的交错数组，在访问数组中的每个元素时也需要做出相应的改变，如下所示：</p>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">int a &#x3D; jaggedArray[1][1,1]   &#x2F;&#x2F; 变量 a 的值为 21
int b &#x3D; jaggedArray[2][0,0]   &#x2F;&#x2F; 变量 b 的值为 89<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>【示例1】定义一个交错数组，并遍历数组中的内容（三个一维数组元素的一维交错数组）：</p>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using System;
namespace c.biancheng.net
&#123;
    class Demo
    &#123;
        static void Main(string[] args)&#123;
            int[][] arr &#x3D; new int[3][]&#123;  
                new int[]&#123;31, 22, 16, 88&#125;,
                new int[]&#123;21, 54, 6, 77, 98, 52&#125;,
                new int[]&#123;112, 25&#125;
            &#125;;
            &#x2F;&#x2F; 遍历数组
            for(int i &#x3D; 0; i &lt; arr.Length; i++)&#123;
                for(int j &#x3D; 0; j &lt; arr[i].Length; j++)&#123;
                    Console.Write(arr[i][j]+&quot; &quot;);
                &#125;
                Console.WriteLine();
            &#125;
            Console.ReadLine();
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>运行结果如下：</p>
<pre class="line-numbers language-none"><code class="language-none">31 22 16 88
21 54 6 77 98 52
112 25<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p><strong>提示：示例中用到了 Length 属性，它是数组的一个属性，代表数组的长度（元素个数）。</strong></p>
<p>【示例2】定义一个交错数组，并遍历数组中的内容（三个二维数组元素的一维交错数组）：</p>
<pre class="line-numbers language-C#" data-language="C#"><code class="language-C#">using System;


namespace test1
&#123;
    
    class test
    &#123;
        static void Main(string[] args)
        &#123;
            int[][,] a &#x3D; new int[3][,]
            &#123;
                new int[,]
                &#123;
                    &#123;1,2 &#125;,
                    &#123;3,4 &#125;
                &#125;,
                new int[,]
                &#123;
                    &#123;3,4 &#125;,
                    &#123;5,6 &#125;
                &#125;,
                new int[,]
                &#123;
                    &#123;5,6 &#125;,
                    &#123;7,8 &#125;
                &#125;
            &#125;;

            for(int i &#x3D; 0; i &lt; a.Length; i++)
            &#123;
                
                for(int j &#x3D; 0; j &lt; a[i].GetLength(0); j++)
                &#123;
                   for(int k &#x3D; 0; k &lt; a[i].GetLength(1); k++)
                    &#123;
                        Console.Write(a[i][j, k]+&quot; &quot;);
                    &#125;
                &#125;
                Console.WriteLine();
            &#125;
            Console.ReadLine();
        &#125;

    &#125;
   

&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>运行结果如下：</p>
<pre class="line-numbers language-none"><code class="language-none">1 2 3 4
3 4 5 6
5 6 7 8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p><strong>提示：GetLength()是数组类的一个预定义方法。它有一个指定维度的参数。如果我们将0传递给GetLenth()方法，那么它将返回第一个维度的大小。如果我们将1传递给getlengthth()方法，那么它将返回第二个维度的大小。</strong></p>
<h2 id="17-C-params：参数数组"><a href="#17-C-params：参数数组" class="headerlink" title="17. C# params：参数数组"></a>17. C# params：参数数组</h2><p>某些情况下，我们在定义函数时可能并不能提前确定参数的数量，这时可以使用 C# 提供的参数数组，参数数组通常用于为函数传递未知数量的参数。</p>
<p>若要使用参数数组，则需要利用 **params **关键字，语法格式如下：</p>
<pre class="line-numbers language-none"><code class="language-none">访问权限修饰符 返回值类型 函数名(params 类型名称[] 数组名称)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><strong>提示：使用参数数组时，既可以直接为函数传递一个数组作为参数，也可以使用<code>函数名(参数1, 参数2, ..., 参数n)</code>的形式传递若干个具体的值作为参数。</strong></p>
<p>下面通过示例来演示以下参数数组的使用：</p>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using System;
namespace c.biancheng.net
&#123;
    class Demo
    &#123;
        static void Main(string[] args)&#123;
            Demo Obj &#x3D; new Demo();		&#x2F;&#x2F;类的实例化
            &#x2F;&#x2F;使用函数名(参数1, 参数2, ..., 参数n)的形式传递若干个具体的值作为参数
            string str &#x3D; Obj.getSum(1, 2, 3, 4, 5, 6);
            Console.WriteLine(str);
            &#x2F;&#x2F;直接为函数传递一个数组作为参数
            int[] arr &#x3D; &#123;2, 4, 6, 8, 10&#125;;
            string str2 &#x3D; Obj.getSum(arr);
            Console.WriteLine(str2);
        &#125;
        public string getSum(params int[] arr)&#123;
            int sum &#x3D; 0;
            string str &#x3D; &quot;&quot;;
            foreach(int i in arr)&#123;
                sum +&#x3D; i;
                str +&#x3D; &quot;+ &quot; + i + &quot; &quot;;
            &#125;
            str &#x3D; str.Trim(&#39;+&#39;);	&#x2F;&#x2F;清除第一个+号
            str +&#x3D; &quot;&#x3D; &quot;+sum;
            return str;
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>运行结果如下：</p>
<pre class="line-numbers language-none"><code class="language-none">1 + 2 + 3 + 4 + 5 + 6 &#x3D; 21
2 + 4 + 6 + 8 + 10 &#x3D; 30<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p><strong>提示：示例中用到的 Trim 方法可以用来去除字符串左右两边指定的字符，这里大家了解 即可。</strong></p>
<h2 id="18-C-Array类"><a href="#18-C-Array类" class="headerlink" title="18. C# Array类"></a>18. C# Array类</h2><p>Array 类是 C# 中<strong>所有数组的基类</strong>，其中提供了一系列用来处理数组的操作，例如对数组元素进行排序、搜索数组中指定的元素等。</p>
<p>Array 类的签名如下所示：</p>
<pre class="line-numbers language-none"><code class="language-none">[SerializableAttribute] 
[ComVisibleAttribute(true)] 
public abstract class Array : ICloneable, IList, ICollection, 
IEnumerable, IStructuralComparable, IStructuralEquatable <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="Array-类中的属性"><a href="#Array-类中的属性" class="headerlink" title="Array 类中的属性"></a>Array 类中的属性</h3><p>Array 类中提供了一系列属性，通过这些属性可以获取数组的各种信息。Array 类中的常用属性如下表所示：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>IsFixedSize</td>
<td>检查数组是否具有固定大小</td>
</tr>
<tr>
<td>IsReadOnly</td>
<td>检查数组是否为只读</td>
</tr>
<tr>
<td>IsSynchronized</td>
<td>检查是否同步对数组的访问（线程安全）</td>
</tr>
<tr>
<td>Length</td>
<td>获取数组中所有维度中元素的总数</td>
</tr>
<tr>
<td>LongLength</td>
<td>获取数组中所有维数中元素的总数，并返回一个 64 位整数</td>
</tr>
<tr>
<td>Rank</td>
<td>获取数组的秩（维数），例如一维数组返回 1，二维数组返回 2，依次类推</td>
</tr>
<tr>
<td>SyncRoot</td>
<td>用来获取一个对象，该对象可以用于同步对数组的访问</td>
</tr>
</tbody></table>
<h3 id="Array-类中的方法"><a href="#Array-类中的方法" class="headerlink" title="Array 类中的方法"></a>Array 类中的方法</h3><p>除了属性之外，Array 类中还提供了一系列的方法，如下表所示：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Clear(Array, Int32, Int32)</td>
<td>将数组中指定范围内的元素设置为该元素所属类型的默认值</td>
</tr>
<tr>
<td>Copy(Array, Array, Int32)</td>
<td>从第一个元素开始拷贝数组中指定长度的元素，并将其粘贴到另一个数组中（从第一个元素开始粘贴），使用 32 位整数来指定要拷贝的长度</td>
</tr>
<tr>
<td>CopyTo(Array, Int32)</td>
<td>从指定的目标数组索引处开始，将当前一维数组的所有元素复制到指定的一维数组中，索引使用 32 位整数指定</td>
</tr>
<tr>
<td>GetLength</td>
<td>获取数组指定维度中的元素数，并返回一个 32 位整数</td>
</tr>
<tr>
<td>GetLongLength</td>
<td>获取数组指定维度中的元素数，并返回一个 64 位整数</td>
</tr>
<tr>
<td>GetLowerBound</td>
<td>获取数组中指定维度第一个元素的索引</td>
</tr>
<tr>
<td>GetType</td>
<td>获取当前实例的类型（继承自 Object ）</td>
</tr>
<tr>
<td>GetUpperBound</td>
<td>获取数组中指定维度最后一个元素的索引</td>
</tr>
<tr>
<td>GetValue(Int32)</td>
<td>获取一维数组中指定位置的值</td>
</tr>
<tr>
<td>IndexOf(Array, Object)</td>
<td>在一个一维数组中搜索指定对象，并返回其首个匹配项的索引</td>
</tr>
<tr>
<td>Reverse(Array)</td>
<td>反转整个一维数组中元素的顺序</td>
</tr>
<tr>
<td>SetValue(Object, Int32)</td>
<td>设置一维数组中指定元素的值</td>
</tr>
<tr>
<td>Sort(Array)</td>
<td>对一维数组中的元素排序</td>
</tr>
<tr>
<td>ToString()</td>
<td>返回一个表示当前对象的字符串（继承自 Object）</td>
</tr>
</tbody></table>
<h2 id="19-C-String：字符串"><a href="#19-C-String：字符串" class="headerlink" title="19. C# String：字符串"></a>19. C# String：字符串</h2><p>在 C# 中，string（或 String）关键字是 System.String 类的别名，其中提供了定义字符串以及操作字符串的一系列方法，下面就来详细介绍一下。</p>
<h3 id="1）声明和初始化字符串"><a href="#1）声明和初始化字符串" class="headerlink" title="1）声明和初始化字符串"></a>1）声明和初始化字符串</h3><p>您可以使用以下方式来创建字符串</p>
<ul>
<li><p>为 String 类型的变量赋值一个字符串；</p>
</li>
<li><p>使用 String 类的构造函数；</p>
</li>
<li><p>使用字符串串联运算符<code>+</code>；</p>
</li>
<li><p>通过检索属性或调用返回字符串的方法；</p>
</li>
<li><p>通过调用格式化方法将值或对象转换为其字符串表示形式。</p>
<p>定义一个空字符串</p>
</li>
</ul>
<pre class="line-numbers language-C#" data-language="C#"><code class="language-C#">string str1 &#x3D; System.String.Empty;	
&#x2F;&#x2F;String.Empty是在语法级别对“”的优化，而且从美观角度看，也占优势。
string str2 &#x3D; &quot;&quot;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>Empty是string类中的一个静态的只读字段，他的定义是这样的：</p>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public static readonly String Empty &#x3D; “”;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>也就是说string.Empty的内部实现是等于””的。</p>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">string str &#x3D; null;&#x2F;&#x2F;在栈上有地址，但在堆上没有空间；null是string的默认值；
string str1 &#x3D;“”;  &#x2F;&#x2F;空字符串，堆栈都有，并且堆上地址为空；
string str2 &#x3D; string.empty; &#x2F;&#x2F;它和str1差不多，在堆栈都有空间，不同就是在语法级上对str1的优化。
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using System;
namespace c.biancheng.net
&#123;
    class Demo
    &#123;
        static void Main(string[] args) 
        &#123; 
            &#x2F;&#x2F; 使用常规字符串为字符串变量赋值
            string name &#x3D; &quot;C语言中文网&quot;;
            
            &#x2F;&#x2F; 声明一个字符串并初始化为空
            string str1 &#x3D; &quot;欢迎访问：&quot; + name;
            Console.WriteLine(&quot;str1 的值为：&quot; + str1);
            
            &#x2F;&#x2F; 使用 System.String.Empty 定义一个空字符串
            string str2 &#x3D; System.String.Empty;
            Console.WriteLine(&quot;str2 的值为：&quot; + str2);
            
            &#x2F;&#x2F; 使用 System.String 类
            System.String url &#x3D; &quot;http:&#x2F;&#x2F;c.biancheng.net&quot;;;
            Console.WriteLine(&quot;url 的值为：&quot; + url);
            
            &#x2F;&#x2F; 在局部变量中（即在方法体中）可以使用 var 来代替具体数据类型来定义变量
            var temp &#x3D; &quot;C#教程&quot;;
            Console.WriteLine(&quot;temp 的值为：&quot; + temp);
            
            &#x2F;&#x2F; 定义一个常量字符串
            const string str3 &#x3D; &quot;这是一个常量字符串&quot;;
            Console.WriteLine(&quot;str3 的值为：&quot; + str3);
            
            &#x2F;&#x2F; 使用字符串构造函数定义字符串
            char[] letters &#x3D; &#123; &#39;H&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39; &#125;;
            &#x2F;&#x2F; string[] letters &#x3D; &#123; &quot;C&quot;,&quot;语&quot;,&quot;言&quot;&#125;;
            string message &#x3D; new string(letters);
            Console.WriteLine(&quot;message 的值为：&quot; + message);
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>运行结果如下：</p>
<pre class="line-numbers language-none"><code class="language-none">str1 的值为：欢迎访问：C语言中文网
str2 的值为：
url 的值为：http:&#x2F;&#x2F;c.biancheng.net
temp 的值为：C#教程
str3 的值为：这是一个常量字符串
message 的值为：Hello<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="2、String-类中的属性"><a href="#2、String-类中的属性" class="headerlink" title="2、String 类中的属性"></a>2、String 类中的属性</h2><p>String 类中提供了两个属性，如下表所示：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Chars[Int32]</td>
<td>获取指定字符在字符串中的位置</td>
</tr>
<tr>
<td>Length</td>
<td>获取当前 String 对象中的字符数（字符串的长度）</td>
</tr>
</tbody></table>
<h2 id="3、String-类中的方法"><a href="#3、String-类中的方法" class="headerlink" title="3、String 类中的方法"></a>3、String 类中的方法</h2><p>String 类中提供了许多用来操作字符串的方法，下表中为大家列举了 String 类中一些比较常用的方法：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Clone()</td>
<td>返回对此 String 实例的引用</td>
</tr>
<tr>
<td>Compare(String, String)</td>
<td>比较两个指定的 String 对象，并返回一个指示二者在排序顺序中的相对位置的整数</td>
</tr>
<tr>
<td>CompareOrdinal(String, String)</td>
<td>通过比较每个字符串中的字符，来比较两个字符串是否相等</td>
</tr>
<tr>
<td>CompareTo(String)</td>
<td>将一个字符串与另一个字符串进行比较</td>
</tr>
<tr>
<td>Concat(String, String)</td>
<td>连接两个指定的字符串</td>
</tr>
<tr>
<td>Contains(String)</td>
<td>判断一个字符串中是否包含零一个字符串</td>
</tr>
<tr>
<td>Copy(String)</td>
<td>将字符串的值复制一份，并赋值给另一个字符串</td>
</tr>
<tr>
<td>CopyTo(Int32, Char[], Int32, Int32)</td>
<td>从字符串中复制指定数量的字符到一个字符数组中</td>
</tr>
<tr>
<td>EndsWith(String)</td>
<td>用来判断字符串是否以指定的字符串结尾</td>
</tr>
<tr>
<td>Equals(String, String)</td>
<td>判断两个字符串是否相等</td>
</tr>
<tr>
<td>Format(String, Object)</td>
<td>将字符串格式化为指定的字符串表示形式</td>
</tr>
<tr>
<td>GetEnumerator()</td>
<td>返回一个可以循环访问此字符串中的每个字符的对象</td>
</tr>
<tr>
<td>GetHashCode()</td>
<td>返回该字符串的哈希代码</td>
</tr>
<tr>
<td>GetType()</td>
<td>获取当前实例的类型</td>
</tr>
<tr>
<td>GetTypeCode()</td>
<td>返回字符串的类型代码</td>
</tr>
<tr>
<td>IndexOf(String)</td>
<td>返回字符在字符串中的首次出现的索引位置，索引从零开始</td>
</tr>
<tr>
<td>Insert(Int32, String)</td>
<td>在字符串的指定位置插入另一个字符串，并返回新形成的字符串</td>
</tr>
<tr>
<td>Intern(String)</td>
<td>返回指定字符串的内存地址</td>
</tr>
<tr>
<td>IsInterned(String)</td>
<td>返回指定字符串的内存地址</td>
</tr>
<tr>
<td>IsNormalized()</td>
<td>判断此字符串是否符合 Unicode 标准</td>
</tr>
<tr>
<td>IsNullOrEmpty(String)</td>
<td>判断指定的字符串是否为空（null）或空字符串（””）</td>
</tr>
<tr>
<td>IsNullOrWhiteSpace(String)</td>
<td>判断指定的字符串是否为 null、空或仅由空白字符组成</td>
</tr>
<tr>
<td>Join(String, String[])</td>
<td>串联字符串数组中的所有元素，并将每个元素使用指定的分隔符分隔开</td>
</tr>
<tr>
<td>LastIndexOf(Char)</td>
<td>获取某个字符在字符串中最后一次出现的位置</td>
</tr>
<tr>
<td>LastIndexOfAny(Char[])</td>
<td>获取一个或多个字符在字符串中最后一次出现的位置</td>
</tr>
<tr>
<td>Normalize()</td>
<td>返回一个新字符串，新字符串与原字符串的值相等，但其二进制表示形式符合 Unicode 标准</td>
</tr>
<tr>
<td>PadLeft(Int32)</td>
<td>返回一个指定长度的新字符串，新字符串通过在原字符串左侧填充空格来达到指定的长度，从而实现右对齐</td>
</tr>
<tr>
<td>PadRight(Int32)</td>
<td>返回一个指定长度的新字符串，新字符串通过在原字符串右侧填充空格来达到指定的长度，从而实现左对齐</td>
</tr>
<tr>
<td>Remove(Int32)</td>
<td>返回一个指定长度的新字符串，将字符串中超出长度以外的部分全部删除</td>
</tr>
<tr>
<td>Replace(String, String)</td>
<td>使用指定字符替换字符串中的某个字符，并返回新形成的字符串</td>
</tr>
<tr>
<td>Split(Char[])</td>
<td>按照某个分隔符将一个字符串拆分成一个字符串数组</td>
</tr>
<tr>
<td>StartsWith(String)</td>
<td>判断字符串是否使用指定的字符串开头</td>
</tr>
<tr>
<td>Substring(Int32)</td>
<td>从指定的位置截取字符串</td>
</tr>
<tr>
<td>ToCharArray()</td>
<td>将字符串中的字符复制到 Unicode 字符数组</td>
</tr>
<tr>
<td>ToLower()</td>
<td>将字符串中的字母转换为小写的形式</td>
</tr>
<tr>
<td>ToLowerInvariant()</td>
<td>使用固定区域性的大小写规则将字符串转换为小写的形式</td>
</tr>
<tr>
<td>ToString()</td>
<td>将其它数据类型转换为字符串类型</td>
</tr>
<tr>
<td>ToUpper()</td>
<td>将字符串中的字母转换为大写形式</td>
</tr>
<tr>
<td>Trim()</td>
<td>删除字符串首尾的空白字符</td>
</tr>
<tr>
<td>TrimEnd(Char[])</td>
<td>删除字符串尾部的空白字符</td>
</tr>
<tr>
<td>TrimStart(Char[])</td>
<td>删除字符串首部的空白字符</td>
</tr>
</tbody></table>
<p>上表中只列举了一些 String 类中常用方法，大家可以通过查阅 C# 的<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/dotnet/api/system.string?view=netcore-3.1#methods">官方文档</a>来了解 String 类中的全部的方法介绍。</p>
<h3 id="4）示例"><a href="#4）示例" class="headerlink" title="4）示例"></a>4）示例</h3><h4 id="【示例】比较两个字符串是否相同："><a href="#【示例】比较两个字符串是否相同：" class="headerlink" title="【示例】比较两个字符串是否相同："></a>【示例】比较两个字符串是否相同：</h4><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using System;


namespace test1
&#123;
    
    class test
    &#123;
        static void Main(string[] args)
        &#123;
            string s1 &#x3D; &quot;66333&quot;;
            string s2 &#x3D; &quot;66666&quot;;
            if (String.Compare(s1, s2) &#x3D;&#x3D; 0)&#123;
                Console.WriteLine(s1 + &quot; 与 &quot; + s2 + &quot; 相同&quot;);
            &#125;
            else
            &#123;
                Console.WriteLine(s1 + &quot; 与 &quot; + s2 + &quot; 不同&quot;);
            &#125;
            Console.WriteLine(String.Compare(s1, s2));
            Console.ReadKey();

        &#125;
       

    &#125;
   

&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>运行结果如下：</p>
<pre class="line-numbers language-none"><code class="language-none">66333 与 66666 不同
-1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h4 id="【示例】判断一个字符串是否包含在另一个字符串中："><a href="#【示例】判断一个字符串是否包含在另一个字符串中：" class="headerlink" title="【示例】判断一个字符串是否包含在另一个字符串中："></a>【示例】判断一个字符串是否包含在另一个字符串中：</h4><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using System;


namespace test1
&#123;
    
    class test
    &#123;
        static void Main(string[] args)
        &#123;
            string s1 &#x3D; &quot;23333&quot;;
            string s2 &#x3D; &quot;2333&quot;;

            if (s1.Contains(s2))
            &#123;
                Console.WriteLine(s1 + &quot; 中包含了 &quot; + s2);
            &#125;
            else
            &#123;
                Console.WriteLine(s1 + &quot; 中不包含 &quot; + s2);
            &#125;
            Console.ReadKey();        
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>运行结果如下：</p>
<pre class="line-numbers language-none"><code class="language-none">23333 中包含了 2333<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h4 id="【示例】从一个字符串中截取指定的字符串："><a href="#【示例】从一个字符串中截取指定的字符串：" class="headerlink" title="【示例】从一个字符串中截取指定的字符串："></a>【示例】从一个字符串中截取指定的字符串：</h4><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using System;


namespace test1
&#123;
    
    class test
    &#123;
        static void Main(string[] args)
        &#123;
            string s1 &#x3D; &quot;23333&quot;;
            Console.WriteLine(&quot;源字符串：&quot; + s1);

            string s2 &#x3D; s1.Substring(2);
            Console.WriteLine(&quot;截取之后的字符串：&quot; + s2);
            Console.ReadKey();        
        &#125;
    &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>运行结果如下：</p>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">源字符串：23333
截取之后的字符串：333<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h4 id="【示例】将数组中的元素合并为字符串："><a href="#【示例】将数组中的元素合并为字符串：" class="headerlink" title="【示例】将数组中的元素合并为字符串："></a>【示例】将数组中的元素合并为字符串：</h4><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using System;


namespace test1
&#123;
    
    class test
    &#123;
        static void Main(string[] args)
        &#123;
            string[] strarray &#x3D; new string[]
            &#123;
                &quot;2333&quot;,
                &quot;666&quot;,
                &quot;888&quot;
            &#125;;

            string str &#x3D; string.Join(&quot;-&quot;, strarray);
            Console.WriteLine(str);
            Console.ReadKey();        
        &#125;
    &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>运行结果如下：</p>
<pre class="line-numbers language-none"><code class="language-none">2333-666-888<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="20-C-struct：结构体"><a href="#20-C-struct：结构体" class="headerlink" title="20. C# struct：结构体"></a>20. C# struct：结构体</h2><p>在 C# 中，结构体也被称为结构类型（“structure type”或“struct type”），它是一种可封装数据和相关功能的值类型，在语法上结构体与类（class）非常相似，它们都可以用来封装数据，并且都可以包含成员属性和成员方法。</p>
<h3 id="1）定义结构体"><a href="#1）定义结构体" class="headerlink" title="1）定义结构体"></a>1）定义结构体</h3><p>要定义一个结构体需要使用 **struct ** 关键字，每个结构体都可以被看作是一种新的数据类型，其中可以包含多个成员（成员属性和成员方法），例如下面声明的 Books 结构体：</p>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">struct Books &#123;
  public string title;
  public string author;
  public string subject;
  public int book_id;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在设计结构体时有以下几点需要注意：</p>
<ul>
<li>不能为结构体声明无参数的构造函数，因为每个结构体中都已经默认创建了一个隐式的、无参数的构造函数；</li>
<li>不能在声明成员属性时对它们进行初始化，静态属性和常量除外；</li>
<li>结构体的构造函数必须初始化该结构体中的所有成员属性；</li>
<li>结构体不能从其他类或结构体中继承，也不能作为类的基础类型，但是结构类型可以实现接口；</li>
<li>不能在结构体中声明析构函数。</li>
</ul>
<p>下面通过一个示例来演示结构体的使用：</p>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using System;


namespace test1
&#123;
    struct books
    &#123;
        public string title;
        public string author;
        public string subject;
        public int book_id;
    &#125;
    class test
    &#123;
        static void Main(string[] args)
        &#123;
            &#x2F;&#x2F;声明books类型的book1和book2
            books book1;
            books book2;

            &#x2F;&#x2F;定义book1的属性
            book1.title &#x3D; &quot;c#教程&quot;;
            book1.author &#x3D; &quot;c语言中文网&quot;;
            book1.subject &#x3D; &quot;c#编程教程&quot;;
            book1.book_id &#x3D; 123456;

            &#x2F;&#x2F;定义book2的属性
            book2.title &#x3D; &quot;c教程&quot;;
            book2.author &#x3D; &quot;c语言中文网&quot;;
            book2.subject &#x3D; &quot;c编程教程&quot;;
            book2.book_id &#x3D; 133333;

            &#x2F;&#x2F;输出boo1和book2的属性信息
            Console.WriteLine(&quot;book1&#39;s title：&quot; + book1.title);
            Console.WriteLine(&quot;book1&#39;s author：&quot; + book1.author);
            Console.WriteLine(&quot;book1&#39;s subject：&quot; + book1.subject);
            Console.WriteLine(&quot;book1&#39;s book_id：&quot; + book1.book_id);
            Console.WriteLine(&quot;book2&#39;s title：&quot; + book2.title);
            Console.WriteLine(&quot;book2&#39;s author：&quot; + book2.author);
            Console.WriteLine(&quot;book2&#39;s subject：&quot; + book2.subject);
            Console.WriteLine(&quot;book2&#39;s book_id：&quot; + book2.book_id);
            Console.ReadKey();
        &#125;
    &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>运行结果如下：</p>
<pre class="line-numbers language-none"><code class="language-none">book1&#39;s title：c#教程
book1&#39;s author：c语言中文网
book1&#39;s subject：c#编程教程
book1&#39;s book_id：123456
book2&#39;s title：c教程
book2&#39;s author：c语言中文网
book2&#39;s subject：c编程教程
book2&#39;s book_id：133333<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="2）结构体的特征"><a href="#2）结构体的特征" class="headerlink" title="2）结构体的特征"></a>2）结构体的特征</h3><p>C# 中的结构体与 C/C++ 中的结构体有很大的不同，在 C# 中结构体具有以下功能：</p>
<ul>
<li>结构体中可以具有方法、字段、索引、属性、运算符方法和事件；</li>
<li>结构体中可以定义构造函数，但不能定义析构函数，需要注意的是，定义的构造函数不能没有参数，因为没有参数的构造函数是 C# 默认自动定义的，而且不能更改；</li>
<li>与类不同，结构体不能继承其他结构体或类；</li>
<li>结构体不能用作其他结构体或类的基础结构；</li>
<li>一种结构体可以实现一个或多个接口；</li>
<li>结构体成员不能被设定为 abstract、virtual 或 protected；</li>
<li>与类不同，结构体可以不用 New 操作符来实例化，当使用 New 操作符来实例化结构体时会自动调用结构体中的构造函数；</li>
<li>如果不使用 New 操作符来实例化结构体，结构体对象中的字段将保持未分配状态，并且在所有字段初始化之前无法使用该结构体实例。</li>
</ul>
<h3 id="3）类与结构体"><a href="#3）类与结构体" class="headerlink" title="3）类与结构体"></a>3）类与结构体</h3><p>类和结构体的主要区别如下所示：</p>
<ul>
<li>类是引用类型，结构体是值类型；</li>
<li>结构体不支持继承，但可以实现接口；</li>
<li>结构体中不能声明默认的构造函数。</li>
</ul>
<p>根据以上特征，让我们来完善一下前面的示例：</p>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using System;


namespace test1
&#123;
    struct books
    &#123;
        &#x2F;&#x2F;成员属性
        public string title;
        public string author;
        public string subject;
        public int book_id;

        &#x2F;&#x2F;成员方法
        public void getValue(string t,string a,string s,int id)
        &#123;
            title &#x3D; t;
            author &#x3D; a;
            subject &#x3D; s;
            book_id &#x3D; id;
        &#125;

        public void disPlay()
        &#123;
            Console.WriteLine(&quot;title：&quot; + title);
            Console.WriteLine(&quot;author：&quot; + author);
            Console.WriteLine(&quot;subject：&quot; + subject);
            Console.WriteLine(&quot;book_id：&quot; + book_id);
        &#125;
    &#125;
    class test
    &#123;
        static void Main(string[] args)
        &#123;
            &#x2F;&#x2F;实例化books结构体
            books book1&#x3D;new books();
            books book2&#x3D;new books();

            &#x2F;&#x2F;定义book1的属性
            book1.getValue(&quot;C#教程&quot;, &quot;C语言中文网&quot;, &quot;C#编程教程&quot;, 123456);

            &#x2F;&#x2F;定义book2的属性
            book2.getValue(&quot;HTTP教程&quot;, &quot;C语言中文网&quot;, &quot;HTTP协议教程&quot;, 123455);

            &#x2F;&#x2F;输出boo1和book2的属性信息
            book1.disPlay();
            book2.disPlay();
            Console.ReadKey();
        &#125;
    &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>运行结果如下：</p>
<pre class="line-numbers language-none"><code class="language-none">title：C#教程
author：C语言中文网
subject：C#编程教程
book_id：123456
title：HTTP教程
author：C语言中文网
subject：HTTP协议教程
book_id：123455<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="21-C-enum：枚举类型"><a href="#21-C-enum：枚举类型" class="headerlink" title="21. C# enum：枚举类型"></a>21. C# enum：枚举类型</h2><p>枚举类型（也可以称为“枚举器”）由一组具有独立标识符（名称）的<strong>整数类型常量</strong>构成，在 C# 中枚举类型不仅可以在类或结构体的内部声明，也可以在类或结构体的外部声明，默认情况下<strong>枚举类型中成员的默认值是从 0 开始的</strong>，然后逐一递增。</p>
<p>在 C# 中可以使用 <strong>enum</strong> 关键字来声明枚举类型，语法格式如下所示：</p>
<pre class="line-numbers language-none"><code class="language-none">enum enum_name&#123;
  enumeration list;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>其中，enum_name 为枚举类型变量的名称；enumeration list 为枚举类型中的成员列表，其中包含若干使用逗号分隔的标识符，每个标识符都代表了一个整数值。</p>
<p>在使用枚举类型时有以下几点需要注意：</p>
<ul>
<li>枚举类型中不能定义方法；</li>
<li>枚举类型具有固定的常量集；</li>
<li>枚举类型可提高类型的安全性；</li>
<li>枚举类型可以遍历。</li>
</ul>
<p>示例如下：</p>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using System;


namespace test1
&#123;
    
    class test
    &#123;
        enum Day &#123; Sun, Mon, Tue, Wed, Thu, Fri, Sat &#125;;
        enum Season
        &#123;
            spring &#x3D;10,
            summer,
            autumn&#x3D;15,
            winter
        &#125;
        static void Main(string[] args)
        &#123;
            &#x2F;&#x2F;默认情况下枚举类型中成员的默认值是从 0 开始的
            Console.WriteLine(&quot;Sun &#x3D; &#123;0&#125;&quot;, (int)Day.Sun);
            Console.WriteLine(&quot;Mon &#x3D; &#123;0&#125;&quot;, (int)Day.Mon);
            Console.WriteLine(&quot;Tue &#x3D; &#123;0&#125;&quot;, (int)Day.Tue);
            Console.WriteLine(&quot;Wed &#x3D; &#123;0&#125;&quot;, (int)Day.Wed);
            Console.WriteLine(&quot;Thu &#x3D; &#123;0&#125;&quot;, (int)Day.Thu);
            Console.WriteLine(&quot;Fri &#x3D; &#123;0&#125;&quot;, (int)Day.Fri);
            Console.WriteLine(&quot;Sat &#x3D; &#123;0&#125;&quot;, (int)Day.Sat);

            Console.WriteLine();

            &#x2F;&#x2F;默认情况下，枚举类型中的每个成员都为 int 类型，
            &#x2F;&#x2F;它们的值从零开始，并按定义顺序依次递增。但是我们
            &#x2F;&#x2F;也可以显式的为每个枚举类型的成员赋值
            foreach (Season i in Enum.GetValues(typeof(Season)))&#123;
                Console.WriteLine(i + &quot; &#x3D; &quot; + (int)i);
            &#125;

            Console.WriteLine();

            &#x2F;&#x2F;使用 GetNames() 遍历枚举类型中的所有成员
            foreach(string i  in Enum.GetNames(typeof(Season)))
            &#123;
                Console.WriteLine(i);
            &#125;

            Console.ReadKey();


        &#125;
    &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>运行结果如下：</p>
<pre class="line-numbers language-none"><code class="language-none">Sun &#x3D; 0
Mon &#x3D; 1
Tue &#x3D; 2
Wed &#x3D; 3
Thu &#x3D; 4
Fri &#x3D; 5
Sat &#x3D; 6

spring &#x3D; 10
summer &#x3D; 11
autumn &#x3D; 15
winter &#x3D; 16

spring
summer
autumn
winter<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="22-C-class：类"><a href="#22-C-class：类" class="headerlink" title="22. C# class：类"></a>22. C# class：类</h2><p>在 C# 中，类是引用类型的，其中包括状态（成员属性）和操作（成员方法和其它函数成员），我们可以动态创建类的实例（instance），这个实例也被称为对象（object），我们可以通过类和对象来设计程序。</p>
<h3 id="1）类的定义"><a href="#1）类的定义" class="headerlink" title="1）类的定义"></a>1）类的定义</h3><p>类的定义需要使用 <strong>class</strong> 关键字，语法格式如下：</p>
<pre class="line-numbers language-none"><code class="language-none">&lt;access specifier&gt; class class_name
&#123;
  &#x2F;&#x2F; 成员属性
  &lt;access specifier&gt; &lt;data type&gt; variable1;
  &lt;access specifier&gt; &lt;data type&gt; variable2;
  ...
  &lt;access specifier&gt; &lt;data type&gt; variableN;
  &#x2F;&#x2F; 成员函数&#x2F;成员方法
  &lt;access specifier&gt; &lt;return type&gt; method1(parameter_list)
  &#123;
    &#x2F;&#x2F; 函数体
  &#125;
  &lt;access specifier&gt; &lt;return type&gt; method2(parameter_list)
  &#123;
    &#x2F;&#x2F; 函数体
  &#125;
  ...
  &lt;access specifier&gt; &lt;return type&gt; methodN(parameter_list)
  &#123;
    &#x2F;&#x2F; 函数体
  &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>语法说明如下：</p>
<ul>
<li><access specifier> 为访问权限修饰符，用来指定类或类中成员的访问规则，可以忽略不写，如果没有指定，则使用默认的访问权限修饰符，类的默认访问权限修饰符是 internal，类中成员的默认访问权限修饰符是 private；</access></li>
<li>class_name 为类的名称；</li>
<li><data type> 为数据类型，用来指定成员属性的数据类型；</data></li>
<li>variable1、variable2 等为成员属性的名称，类似于变量名；</li>
<li><return type> 为返回值类型，用来指定成员函数的返回值类型；</return></li>
<li>method1、method2 等为成员函数的名称。</li>
</ul>
<h3 id="2）对象"><a href="#2）对象" class="headerlink" title="2）对象"></a>2）对象</h3><p>类和对象是不同的概念，类决定了对象的类型，但不是对象本身。另外，类是在开发阶段创建的，而对象则是在程序运行期间创建的。我们可以将对象看作是基于类创建的实体，所以<strong>对象也可以称为类的实例</strong>。</p>
<p>想要创建一个类的实例需要使用 new 关键字，假如我们创建了一个名为 Student 的类，若要创建这个类的对象，语法格式如下：</p>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">Student Object &#x3D; new Student();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="23-C-构造函数"><a href="#23-C-构造函数" class="headerlink" title="23. C#构造函数"></a>23. C#构造函数</h2><p>在 C# 中，<strong>构造函数就是与类（或结构体）具有相同名称的成员函数</strong>，它在类中的地位比较特殊，不需要我们主动调用，当创建一个类的对象时会自动调用类中的构造函数。在程序开发的过程中，我们通常使用类中的构造函数来初始化类中的成员属性。</p>
<p>C# 中的构造函数有三种：</p>
<ul>
<li>实例构造函数；</li>
<li>静态构造函数；</li>
<li>私有构造函数。</li>
</ul>
<h3 id="1）实例构造函数"><a href="#1）实例构造函数" class="headerlink" title="1）实例构造函数"></a>1）实例构造函数</h3><p>构造函数是类中特殊的成员函数，它的名称与它所在类的名称相同，并且没有返回值。当我们使用 new 关键字创建类的对象时，可以使用实例构造函数来创建和初始化类中的任意成员属性。下面示例中演示了一个名为 Person 的类，以及类中的实例构造函数。</p>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public class Person&#123;
    private string name;
    private int age;
    &#x2F;&#x2F;构造函数
    public Person(string n, int a)
    &#123;
        name &#x3D; n;
        age &#x3D; a;
    &#125;
    &#x2F;&#x2F; 类中剩余的成员
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>只要创建 Person 类的对象，就会调用类中的实例构造函数，我们只需要在实例化对象时将具体的值传递给类中的构造函数即可，如下所示：</p>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">Person P &#x3D; new Person(&quot;张三&quot;, 18);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><strong>如果没有为类显式的创建构造函数，那么 C# 将会为这个类隐式的创建一个没有参数的构造函数（无参数构造函数）</strong>，这个无参的构造函数会在实例化对象时为类中的成员属性设置默认值（关于 C# 中类型的默认值大家可以查阅《<a target="_blank" rel="noopener" href="http://m.biancheng.net/csharp/data-type.html">数据类型</a>》一节）。在结构体中也是如此，如果没有为结构体创建构造函数，那么 C# 将隐式的创建一个无参数的构造函数，用来将每个字段初始化为其默认值。</p>
<p>若要初始化静态类或非静态类中的静态属性，则需要使用下面将要介绍的静态构造函数。</p>
<h3 id="2）静态构造函数"><a href="#2）静态构造函数" class="headerlink" title="2）静态构造函数"></a>2）静态构造函数</h3><p>静态构造函数<strong>用于初始化类中的静态数据或执行仅需执行一次的特定操作</strong>。静态构造函数将在创建第一个实例或引用类中的静态成员之前自动调用。</p>
<p>静态构造函数具有以下特性：</p>
<ul>
<li>静态构造函数不使用访问权限修饰符修饰或不具有参数；</li>
<li>类或结构体中<strong>只能具有一个静态构造函数</strong>；</li>
<li>静态构造函数不能继承或重载；</li>
<li>静态构造函数不能直接调用，仅可以由公共语言运行时 (CLR) 调用；</li>
<li>用户无法控制程序中静态构造函数的执行时间；</li>
<li>在创建第一个实例或引用任何静态成员之前，将自动调用静态构造函数以初始化类；</li>
<li>静态构造函数会在实例构造函数之前运行。</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using System;


namespace test1
&#123;
    
    class test
    &#123;
        public static int num &#x3D; 0;

        &#x2F;&#x2F;构造函数
        test()
        &#123;
            num &#x3D; 1;
        &#125;

        &#x2F;&#x2F;静态构造函数
        static test()
        &#123;
            num &#x3D; 2;
        &#125;
        
        static void Main(string[] args)
        &#123;
            &#x2F;&#x2F;在创建第一个实例或引用任何静态成员之前，将自动调用静态构造函数以初始化类；
            Console.WriteLine(&quot;num &#x3D; &quot; + num);  &#x2F;&#x2F;所以结果为2
            test obj &#x3D; new test();
            Console.WriteLine(&quot;num &#x3D; &quot; + num);  
            &#x2F;&#x2F;创建示例后，调用构造函数，结果为1
            Console.Read();
        &#125;
    &#125;

   
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>当执行上面程序时，会首先执行<code>public static int num = 0</code>，接着执行类中的静态构造函数，此时 num = 2，然后执行 Main 函数里面的内容，此时打印 num 的值为 2，接着初始化 Demo 类，这时会执行类中的构造函数，此时 num 会重新赋值为 1，所以上例的运行结果如下所示：</p>
<pre class="line-numbers language-none"><code class="language-none">num &#x3D; 2
num &#x3D; 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h3 id="3）私有构造函数"><a href="#3）私有构造函数" class="headerlink" title="3）私有构造函数"></a>3）私有构造函数</h3><p>私有构造函数是一种特殊的实例构造函数，<strong>通常用在只包含静态成员的类中</strong>。如果一个类中具有一个或多个私有构造函数而没有公共构造函数的话，那么其他类（除嵌套类外）则无法创建该类的实例。 例如：</p>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">class NLog
&#123;
    &#x2F;&#x2F; 私有构造函数
    private NLog() &#123; &#125;
    public static double e &#x3D; Math.E;  &#x2F;&#x2F;2.71828...
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上例中定义了一个空的私有构造函数，这么做的好处就是空构造函数可阻止自动生成无参数构造函数。需要注意的是，如果不对构造函数使用访问权限修饰符，则默认它为私有构造函数。</p>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using System;


namespace test1
&#123;
    
    class test
    &#123;
       public class student
        &#123;
            &#x2F;&#x2F;定义一个空的私有构造函数
            private student() &#123; &#125;
            public static int id;
            public static string name;
            public static void Display()
            &#123;
                Console.WriteLine(&quot;姓名：&quot; + name + &quot;\n编号：&quot; + id);
            &#125;

        &#125;
        
        static void Main(string[] args)
        &#123;
            student.id &#x3D; 101;
            student.name &#x3D; &quot;张三&quot;;
            student.Display();
            Console.Read();
        &#125;
    &#125;

   
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>运行结果如下：</p>
<pre class="line-numbers language-none"><code class="language-none">姓名：张三
编号：101<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>上述代码如果写成<code>student stu = new student();</code>，程序就会出错，因为 student 类的构造函数是私有静态函数，受其保护级别的限制不能访问。</p>
<h2 id="24-C-析构函数"><a href="#24-C-析构函数" class="headerlink" title="24. C#析构函数"></a>24. C#析构函数</h2><p>与《<a target="_blank" rel="noopener" href="http://m.biancheng.net/csharp/constructor.html">构造函数</a>》类似，C# 中的析构函数（也被称作“终结器”）同样是类中的一个特殊成员函数，<strong>主要用于在垃圾回收器回收类实例时执行一些必要的清理操作</strong>。</p>
<p>C# 中的析构函数具有以下特点：</p>
<ul>
<li>析构函数只能在类中定义，不能用于结构体；</li>
<li>一个类中只能定义一个析构函数；</li>
<li>析构函数不能继承或重载；</li>
<li>析构函数没有返回值；</li>
<li>析构函数是自动调用的，不能手动调用；</li>
<li>析构函数不能使用访问权限修饰符修饰，也不能包含参数。</li>
</ul>
<p>析构函数的名称同样与类名相同，不过需要在名称的前面加上一个波浪号<code>~</code>作为前缀，如下所示：</p>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">class Car
&#123;
  ~Car() &#x2F;&#x2F; 析构函数
  &#123;

  &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using System;


namespace test1
&#123;
    
    class test
    &#123;
       public class student
        &#123;
            &#x2F;&#x2F;定义一个构造函数
            public student() &#123; Console.WriteLine(&quot;类中的构造函数&quot;); &#125;
            &#x2F;&#x2F;定义一个析构函数
            ~student()&#123; Console.WriteLine(&quot;类中的析构函数&quot;); &#125;

        &#125;
        
        static void Main(string[] args)
        &#123;
            student stu1 &#x3D; new student();
            student stu2 &#x3D; new student();
        &#125;
    &#125;

   
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>运行结果如下：</p>
<pre class="line-numbers language-none"><code class="language-none">类中的析构函数
类中的析构函数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>注意：析构函数不能对外公开，所以我们不能在析构函数上应用任何访问权限修饰符。</p>
<h2 id="25-C-this关键字"><a href="#25-C-this关键字" class="headerlink" title="25. C# this关键字"></a>25. C# this关键字</h2><p>在 C# 中，可以使用 this 关键字来表示当前对象，日常开发中我们可以使用 this 关键字来访问类中的成员属性以及函数。不仅如此 this 关键字还有一些其它的用法，下面就通过一些示例来分别演示一下。</p>
<h3 id="1-使用-this-表示当前类的对象"><a href="#1-使用-this-表示当前类的对象" class="headerlink" title="1) 使用 this 表示当前类的对象"></a>1) 使用 this 表示当前类的对象</h3><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public class Website
    &#123;
        private string name;
        private string url;
        public Website(string n, string u)&#123;
            this.name &#x3D; n;
            this.url &#x3D; u;
        &#125;
        public void Display()&#123;
            Console.WriteLine(name +&quot; &quot;+ url);
        &#125;
    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="2-使用-this-关键字串联构造函数"><a href="#2-使用-this-关键字串联构造函数" class="headerlink" title="2) 使用 this 关键字串联构造函数"></a>2) 使用 this 关键字串联构造函数</h3><p>目的是为了实例化该类时 还会先自动调用一次this()中对应参数的方法，再继续执行原本的方法</p>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using System;


namespace test1
&#123;
    public class student
        &#123;
           public student()
            &#123;
                Console.WriteLine(&quot;无参的构造函数&quot;);
            &#125;
            &#x2F;&#x2F; 这里的 this()代表无参构造函数 student()
            &#x2F;&#x2F; 先执行 student()，后执行 student(string text)
            public student(string text) : this()
            &#123;
                Console.WriteLine(text);
                Console.WriteLine(&quot;有参的构造函数&quot;);
            &#125;

        &#125;
    
    class test
    &#123;

        static void Main(string[] args)
        &#123;
            student stu &#x3D; new student(&quot;2333&quot;);
        &#125;
    &#125;

&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>运行结果如下：</p>
<pre class="line-numbers language-none"><code class="language-none">无参的构造函数
2333
有参的构造函数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>在一个类中如果需要实现多个自定义构造函数,通常做法是在构造函数中实现各自的业务逻辑,如果这些业务逻辑的实现并非截然不同的话,显然不符合**oop(面向对象编程思想)**编程思想,极不利于维护,当然,我们也可以通过将相同的逻辑部分封装成一个方法,但还有一种更为合理简单的方法，下面就通过this关键字来实现串联构造函数做一简单示例。</p>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using System;


namespace test1
&#123;
    public class student
    &#123;
        public string name;
        &#x2F;&#x2F;定义年龄为可空类型，这样就可以赋予其null值
        public int? age;

        &#x2F;&#x2F;下面前三个构造函数都是去调用参数最多的第四个构造函数，只取它们所需要的部分参数即可

        &#x2F;&#x2F;这样的作法就是用this串联构造函数


        public student() : this(&quot;&quot;, 0) &#123; &#125;

        public student(string name) : this(&quot;evan&quot;, null) &#123; &#125;

        public student(int? age) : this(&quot;&quot;, 20) &#123; &#125;

        public student(string name,int? age)
        &#123;
            this.name &#x3D; name;
            &#x2F;&#x2F;通过??判断传入的age是否null
            &#x2F;&#x2F;如果属于null,则赋值100
            this.age &#x3D; age ?? 100;
        &#125;

        public void Display()
        &#123;
            Console.WriteLine(&quot;Name:&#123;0&#125;,Age:&#123;1&#125;&quot;, name, age);
        &#125;


    &#125;
    class test
    &#123;
       
        
        static void Main(string[] args)
        &#123;
            student s1 &#x3D; new student();
            s1.Display();
            student s2 &#x3D; new student(20);
            s2.Display();
            student s3 &#x3D; new student(&quot;evan&quot;);
            s3.Display();
            student s4 &#x3D; new student(&quot;evan&quot;,20);
            s4.Display();
            Console.ReadLine();
        &#125;
    &#125;

   
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>运行结果如下：</p>
<pre class="line-numbers language-none"><code class="language-none">Name:,Age:0
Name:,Age:20
Name:evan,Age:100
Name:evan,Age:20<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>这样的做法就是让一个接受参数最多的构造函数做”主构造函数”, 且在主构造函数中实现必须的业务逻辑,其余的构造函数只要使用this关键字把传入的参数转发给主构造函数,并且提供必须的其它参数，这样子,我们整个类中需要我们操心的就是那个主构造函数了,其余构造函数基本上可以为空。</p>
<p>注意:如果构造函数链中还有实现各自的逻辑,那么实际上是先执行主构造函数的代码,再执行各自逻辑，使用这种做法,真正的工作都交给了一个构造函数,类定义就会更简洁、更易维护、简化了编程任务。</p>
<p>参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_56494923/article/details/125794784">https://blog.csdn.net/m0_56494923/article/details/125794784</a></p>
<h3 id="3-使用-this-关键字作为类的索引器"><a href="#3-使用-this-关键字作为类的索引器" class="headerlink" title="3) 使用 this 关键字作为类的索引器"></a>3) 使用 this 关键字作为类的索引器</h3><p>索引器可以同时给多个字段赋值，比属性功能多些</p>
<p>比较简单但并不完全正确的理解，索引器就是与对象同名的数组</p>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using System;


namespace test1
&#123;
    public class student
        &#123;
            int t1; &#x2F;&#x2F;index &#x3D; 0
            int t2;	&#x2F;&#x2F;index &#x3D; 1
           	&#x2F;&#x2F;索引器必须以this关键字定义，其实这个this就是类实例化之后的对象
            public int this[int index]
            &#123;
                get
                &#123;
                    return (0 &#x3D;&#x3D; index) ? t1 : t2;
                &#125;

                set
                &#123;
                    if (0 &#x3D;&#x3D; index) t1 &#x3D; value;
                    else t2 &#x3D; value;
                &#125;
            &#125;

        &#125;
    
    class test
    &#123;

        static void Main(string[] args)
        &#123;
            student a &#x3D; new student();
            Console.WriteLine(&quot;t1:&#123;0&#125;,t2:&#123;1&#125;&quot;, a[0], a[1]);
            &#x2F;&#x2F;调用set方法
            a[0] &#x3D; 15;		&#x2F;&#x2F;t1
            a[1] &#x3D; 20;		&#x2F;&#x2F;t2
            &#x2F;&#x2F;调用get方法
            Console.WriteLine(&quot;t1:&#123;0&#125;,t2:&#123;1&#125;&quot;, a[0], a[1]);
        &#125;
    &#125;

&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>运行结果如下：</p>
<pre class="line-numbers language-none"><code class="language-none">t1:0,t2:0
t1:15,t2:20<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h3 id="4-使用-this-关键字作为原始类型的扩展方法"><a href="#4-使用-this-关键字作为原始类型的扩展方法" class="headerlink" title="4) 使用 this 关键字作为原始类型的扩展方法"></a>4) 使用 this 关键字作为原始类型的扩展方法</h3><p>注意要写在静态类中的静态方法，不然有些情况下访问不到</p>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using System;


namespace test1
&#123;
    public static class student
    &#123;
        public static string ExpandString(this string name)
        &#123;
            return name + &quot;2333&quot;;
        &#125;
    &#125;
    class test
    &#123;
       
       
        static void Main(string[] args)
        &#123;
            string str &#x3D; &quot;666&quot;;
            string newstr &#x3D; str.ExpandString();
            Console.WriteLine(newstr);
            Console.ReadLine();
        &#125;
    &#125;

   
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>运行结果如下：</p>
<pre class="line-numbers language-none"><code class="language-none">6662333<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="26-C-static：静态成员"><a href="#26-C-static：静态成员" class="headerlink" title="26. C# static：静态成员"></a>26. C# static：静态成员</h2><p>在 C# 中，我们可以使用 static 关键字声明属于类型本身而不是属于特定对象的静态成员，因此不需要使用对象来访问静态成员。在类、接口和结构体中可以使用 static 关键字修饰变量、函数、构造函数、类、属性、运算符和事件。</p>
<p><strong>注意：索引器和析构函数不能是静态的。</strong></p>
<p>若在定义某个成员时使用 static 关键字，则表示该类仅存在此成员的一个实例，也就是说当我们将一个类的成员声明为静态成员时，无论创建多少个该类的对象，静态成员只会被创建一次，这个静态成员会被所有对象共享。</p>
<h3 id="1）静态属性"><a href="#1）静态属性" class="headerlink" title="1）静态属性"></a>1）静态属性</h3><p>使用 static 定义的成员属性称为“静态属性”，静态属性可以直接通过<code>类名.属性名</code>的形式直接访问，不需要事先创建类的实例。静态属性不仅可以使用成员函数来初始化，还可以直接在类外进行初始化。</p>
<p>下面通过一个示例来演示一下静态变量的使用：</p>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using System;


namespace test1
&#123;
    class student
    &#123;
        public static string Name;
        public void setName(string name)
        &#123;
            Name &#x3D; name;
        &#125;
        public void getName()
        &#123;
            Console.WriteLine(Name);
        &#125;
    &#125;
   
    class test
    &#123;
       
       
        static void Main(string[] args)
        &#123;
            student.Name &#x3D; &quot;8&quot;;
            Console.WriteLine(student.Name);

            student stu &#x3D; new student();
            stu.getName();

            student stu1 &#x3D; new student();
            stu1.getName();

            stu1.setName(&quot;666&quot;);
            stu1.getName();
            stu1.getName();
        &#125;
    &#125;

   
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>运行结果如下：</p>
<pre class="line-numbers language-none"><code class="language-none">8
8
8
666
666<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="2）静态函数"><a href="#2）静态函数" class="headerlink" title="2）静态函数"></a>2）静态函数</h3><p>除了可以定义静态属性外，static 关键字还可以用来定义成员函数，使用 static 定义的成员函数称为“静态函数”，<strong>静态函数只能访问静态属性</strong>。</p>
<p>下面通过示例来演示静态函数的使用：</p>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using System;


namespace test1
&#123;
    class student
    &#123;
        public static string Name;
        public void setName(string name)
        &#123;
            Name &#x3D; name;
        &#125;
        public static void getName()
        &#123;
            Console.WriteLine(Name);
        &#125;
    &#125;
   
    class test
    &#123;
       
       
        static void Main(string[] args)
        &#123;
            student.Name &#x3D; &quot;8&quot;;
            Console.WriteLine(student.Name);

            student stu &#x3D; new student();
            student.getName();	&#x2F;&#x2F;注意这里不能写出stu.getName();

            student stu1 &#x3D; new student();
            student.getName();

            stu1.setName(&quot;666&quot;);
            student.getName();
            student.getName();
        &#125;
    &#125;

   
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>运行结果如下：</p>
<pre class="line-numbers language-none"><code class="language-none">8
8
8
666
666<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="27-C-继承"><a href="#27-C-继承" class="headerlink" title="27. C#继承"></a>27. C#继承</h2><p>在创建一个新类时，我们可以使用这个新定义的类继承一个已有的类，<strong>通过继承可以在创建新类时重用、扩展和修改被继承类中定义的成员</strong>。<strong>被继承的类称为“基类（父类）”，继承基类的类称为“派生类（子类）”</strong>。</p>
<p>需要注意的是，<strong>C# 中只支持单继承，</strong>也就是说一个派生类只能继承一个基类，但是继承是可以传递的，例如 ClassC 继承了 ClassB，而 ClassB 继承了 ClassA，那么 ClassC 将继承 ClassB 和 ClassA 中的所有成员。</p>
<p>要使用一个类继承另一个类需要使用到**冒号<code>:</code>**，如下所示：</p>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">class 派生类 : 基类&#123;
  ... ...c
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>与单继承相反，多重继承则是指一个类可以同时继承多个基类，<strong>C# 并不支持多重继承，但是可以借助接口来实现多重继承</strong>。下面就通过一个示例来演示一下：</p>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using System;


namespace test1
&#123;
    
    class test
    &#123;

        static void Main(string[] args)
        &#123;
            &#x2F;&#x2F;定义一个对象
            Rectangle rec &#x3D; new Rectangle();
            rec.setHeight(4);
            rec.setWidth(3);
            Console.WriteLine(&quot;长方形的面积为：&quot; + rec.getArea());
            Console.WriteLine(&quot;长方形的周长为：&quot; + rec.getGirth());
        &#125;
    &#125;

    &#x2F;&#x2F;定义一个基类Shape
    class Shape &#123;
        protected int width, height;
        public void setWidth(int w)
        &#123;
            width &#x3D; w;
        &#125;

        public void setHeight(int h)
        &#123;
            height &#x3D; h;
        &#125;
    &#125;

    &#x2F;&#x2F;定义接口
    public interface Perimeter
    &#123;
        int getGirth();
    &#125;

    &#x2F;&#x2F;派生类
    class Rectangle : Shape, Perimeter
    &#123;
        public int getArea()
        &#123;
            return width * height;
        &#125;
        &#x2F;&#x2F;派生类必须实现接口的所有成员
        public int getGirth()
        &#123;
            return (width * height) * 2;
        &#125;
    &#125;

&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>运行结果如下：</p>
<pre class="line-numbers language-none"><code class="language-none">长方形的面积为：12
长方形的周长为：24<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h2 id="28-C-多态"><a href="#28-C-多态" class="headerlink" title="28. C#多态"></a>28. C#多态</h2><p>多态（Polymorphism）是一个希腊词，指“多种形态”，在 C# 中具有两种类型的多态：</p>
<ul>
<li>编译时多态：通过 C# 中的方法重载和运算符重载来实现编译时多态，也称为静态绑定或早期绑定；</li>
<li>运行时多态：通过方法重载实现的运行时多态，也称为动态绑定或后期绑定。</li>
</ul>
<h3 id="1）编译时多态"><a href="#1）编译时多态" class="headerlink" title="1）编译时多态"></a>1）编译时多态</h3><p>在编译期间将函数与对象链接的机制称为早期绑定，也称为静态绑定。C# 提供了两种技术来实现编译时多态，分别是函数重载和运算符重载，本节主要来介绍一下函数重载，运算符重载会在后面进行讲解。</p>
<h4 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h4><p>在同一个作用域中，可以定义多个同名的函数，但是这些函数彼此之间必须有所差异，比如参数个数不同或参数类型不同等等，返回值类型不同除外。</p>
<p>【示例】定义名为 print 的函数来打印不同类型的数据：</p>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using System;
namespace c.biancheng.net
&#123;
    class Demo
    &#123;
        void print(int i)&#123;
            Console.WriteLine(&quot;打印 int 类型的数据：&#123;0&#125;&quot;, i);
        &#125;
        void print(double d)&#123;
            Console.WriteLine(&quot;打印 double 类型的数据：&#123;0&#125;&quot;, d);
        &#125;
        void print(string s)&#123;
            Console.WriteLine(&quot;打印 string 类型的数据：&#123;0&#125;&quot;, s);
        &#125;
        static void Main(string[] args) 
        &#123;
            Demo p &#x3D; new Demo();
            p.print(123);
            p.print(&quot;C语言中文网&quot;);
            p.print(3.1415926);
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="2）运行时多态"><a href="#2）运行时多态" class="headerlink" title="2）运行时多态"></a>2）运行时多态</h3><p>C# 允许您使用 <strong>abstract</strong> 关键字来创建抽象类，抽象类用于实现部分接口。另外，抽象类包含抽象方法，可以在派生类中实现。</p>
<p>下面列举了一些有关抽象类的规则：</p>
<ul>
<li>不能创建一个抽象类的实例；</li>
<li>不能在一个抽象类外部声明抽象方法；</li>
<li>通过在类定义时使用 sealed 关键字，可以将类声明为密封类，密封类不能被继承，因此抽象类中不能声明密封类。</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using System;
namespace c.biancheng.net
&#123;
    &#x2F;&#x2F;创建一个抽象类Shape
    abstract class Shape&#123;
        &#x2F;&#x2F;抽象类包含抽象方法，可以在派生类中实现
        public abstract int area();
    &#125;
    class Rectangle : Shape&#123;
        private int width, height;
        public Rectangle(int w, int h)&#123;
            width &#x3D; w;
            height &#x3D; h;
        &#125;
        &#x2F;&#x2F;在派生类中实现抽象类中的抽象方法
        public override int area()&#123;
            return (width * height);
        &#125;
    &#125;
    class Demo
    &#123;
        static void Main(string[] args) 
        &#123;
            Rectangle r &#x3D; new Rectangle(12,15);
            double a &#x3D; r.area();
            Console.WriteLine(&quot;长方形的面积为： &#123;0&#125;&quot;,a);
            Console.ReadKey();
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="我们什么时候应该用抽象类呢？"><a href="#我们什么时候应该用抽象类呢？" class="headerlink" title="我们什么时候应该用抽象类呢？"></a>我们什么时候应该用抽象类呢？</h4><p><strong>如果一个类设计的目点是用来被其它类继承的</strong>，它代表一类对象的所具有的公共属性或方法，那个这个类就应该设置为抽象类。</p>
<h4 id="抽象类与其它的类有什么区别呢"><a href="#抽象类与其它的类有什么区别呢" class="headerlink" title="抽象类与其它的类有什么区别呢?"></a>抽象类与其它的类有什么区别呢?</h4><p>抽象类是不能够被实例化的。如果一个类中包含有抽象方法，那么这个类一定要声明为抽象类。同时，<strong>抽象方法一定需要在子类中重写</strong>，让抽象方法成为一个具体的实实在在的方法。</p>
<p>比如，我们要声明一个动物类animal，然后有其它的类Cat(猫)，Dog(狗)等具体的类来继承它，那么这个动物类就应该声明为抽象类。因为animal只是一个名词，不代表任何具体的对象，它只是代表所有动物所拥有的共同特征，所以animal类是根本不可能被实例化的。同时，如果所有动物都必须声明”叫”这样一个方法的话，那么，我们可以在animal类中声明一个抽象方法shout()，因为抽象方法是必须在子类中重写的，所以这就限制了所有继承自animal类都必须重写shout()方法。</p>
<h2 id="29-C-运算符重载"><a href="#29-C-运算符重载" class="headerlink" title="29. C#运算符重载"></a>29. C#运算符重载</h2><p>C# 中支持运算符重载，<strong>所谓运算符重载就是我们可以使用自定义类型来重新定义 C# 中大多数运算符的功能</strong>。运算符重载需要通过 <strong>operator</strong> 关键字后跟运算符的形式来定义的，我们可以将被重新定义的运算符看作是具有特殊名称的函数，与其他函数一样，该函数也有返回值类型和参数列表，如下例所示：</p>
<pre class="line-numbers language-none"><code class="language-none">public static Box operator+ (Box b, Box c) &#123;
  Box box &#x3D; new Box();
  box.length &#x3D; b.length + c.length;
  box.breadth &#x3D; b.breadth + c.breadth;
  box.height &#x3D; b.height + c.height;
  return box;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上述函数中实现了对加法运算符<code>+</code>的重载，该函数需要两个 Box 对象的属性，并返回一个 Box 对象。</p>
<h3 id="运算符重载的实现"><a href="#运算符重载的实现" class="headerlink" title="运算符重载的实现"></a>运算符重载的实现</h3><p>下面通过完整的示例来演示一下运算符重载：</p>
<pre class="line-numbers language-C#" data-language="C#"><code class="language-C#">using System;
namespace c.biancheng.net
&#123;
    class Box
    &#123;
        private double length;      &#x2F;&#x2F; 长度
        private double breadth;     &#x2F;&#x2F; 宽度
        private double height;      &#x2F;&#x2F; 高度
        public double getVolume()
        &#123;
            return length * breadth * height;
        &#125;
        public void setLength( double len )
        &#123;
            length &#x3D; len;
        &#125;
        public void setBreadth( double bre )
        &#123;
            breadth &#x3D; bre;
        &#125;
        public void setHeight( double hei )
        &#123;
            height &#x3D; hei;
        &#125;
        &#x2F;&#x2F; 重载 + 运算符，把两个 Box 对象相加
        public static Box operator+ (Box b, Box c)
        &#123;
            Box box &#x3D; new Box();
            box.length &#x3D; b.length + c.length;
            box.breadth &#x3D; b.breadth + c.breadth;
            box.height &#x3D; b.height + c.height;
            return box;
        &#125;
    &#125;
    class Demo
    &#123;
        static void Main(string[] args) 
        &#123;
            Box Box1 &#x3D; new Box();         &#x2F;&#x2F; 声明 Box1，类型为 Box
            Box Box2 &#x3D; new Box();         &#x2F;&#x2F; 声明 Box2，类型为 Box
            Box Box3 &#x3D; new Box();         &#x2F;&#x2F; 声明 Box3，类型为 Box
            double volume &#x3D; 0.0;          &#x2F;&#x2F; 体积
            &#x2F;&#x2F; Box1 详述
            Box1.setLength(6.0);
            Box1.setBreadth(7.0);
            Box1.setHeight(5.0);
            &#x2F;&#x2F; Box2 详述
            Box2.setLength(12.0);
            Box2.setBreadth(13.0);
            Box2.setHeight(10.0);
            &#x2F;&#x2F; Box1 的体积
            volume &#x3D; Box1.getVolume();
            Console.WriteLine(&quot;Box1 的体积： &#123;0&#125;&quot;, volume);
            &#x2F;&#x2F; Box2 的体积
            volume &#x3D; Box2.getVolume();
            Console.WriteLine(&quot;Box2 的体积： &#123;0&#125;&quot;, volume);
            &#x2F;&#x2F; 把两个对象相加
            Box3 &#x3D; Box1 + Box2;
            &#x2F;&#x2F; Box3 的体积
            volume &#x3D; Box3.getVolume();
            Console.WriteLine(&quot;Box3 的体积： &#123;0&#125;&quot;, volume);
            Console.ReadKey();
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>运行结果如下：</p>
<pre class="line-numbers language-none"><code class="language-none">Box1 的体积： 210
Box2 的体积： 1560
Box3 的体积： 5400<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h3 id="可重载与不可重载的运算符"><a href="#可重载与不可重载的运算符" class="headerlink" title="可重载与不可重载的运算符"></a>可重载与不可重载的运算符</h3><p>下表提供了 C# 运算符可重载性的相关信息：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>可重载性</th>
</tr>
</thead>
<tbody><tr>
<td>+、-、!、~、++、–</td>
<td>这些一元运算符可以进行重载</td>
</tr>
<tr>
<td>+、-、*、/、%、&amp;、|、^、&lt;&lt;、&gt;&gt;、=、!=、&lt;、&gt;、&lt;=、&gt;=</td>
<td>这些二元运算符可以进行重载，需要注意的是某些运算符必须成对重载</td>
</tr>
<tr>
<td>&amp;&amp;、||</td>
<td>无法重载逻辑运算符</td>
</tr>
<tr>
<td>(type)var_name</td>
<td>强制类型转换运算符不能重载</td>
</tr>
<tr>
<td>+=、-=、*=、/=、%=、&amp;=、|=、^=、&lt;&lt;=、&gt;&gt;=</td>
<td>复合赋值运算符不能显式重载。 但在重载二元运算符时，也会隐式重载相应的复合赋值运算符，例如重载了<code>+</code>运算符也会隐式的重载<code>+=</code></td>
</tr>
<tr>
<td>^、=、.、?.、?  : 、??、??=、..、-&gt;、=&gt;、as、await、checked、unchecked、default、delegate、is、nameof、new、sizeof、stackalloc、switch、typeof</td>
<td>这些运算符无法进行重载</td>
</tr>
</tbody></table>
<p><strong>注意：比较运算符必须成对重载，也就是说，如果重载一对运算符中的任意一个，则另一个运算符也必须重载。比如<code>==</code>和<code>!=</code>运算符、<code>&lt;</code>和<code>&gt;</code>运算符、<code>&lt;=</code>和<code>&gt;=</code>运算符。</strong></p>
<h2 id="30-C-接口（interface）"><a href="#30-C-接口（interface）" class="headerlink" title="30. C#接口（interface）"></a>30. C#接口（interface）</h2><p>接口可以看作是一个约定，其中定义了类或结构体继承接口后需要实现功能，接口的特点如下所示：</p>
<ul>
<li>接口是一个引用类型，通过接口可以实现多重继承；</li>
<li>接口中只能声明”抽象”成员，所以不能直接对接口进行实例化；</li>
<li>接口中可以包含方法、属性、事件、索引器等成员；</li>
<li>接口名称一般习惯使用字母“I”作为开头（不是必须的，不这样声明也可以）；</li>
<li>接口中成员的访问权限默认为 public，所以我们在定义接口时不用再为接口成员指定任何访问权限修饰符，否则编译器会报错；</li>
<li>在声明接口成员的时候，<strong>不能为接口成员编写具体的可执行代码</strong>，也就是说，只要在定义成员时指明成员的名称和参数就可以了；</li>
<li>接口一旦被实现（被一个类继承），<strong>派生类就必须实现接口中的所有成员</strong>，除非派生类本身也是抽象类。</li>
</ul>
<h3 id="声明接口"><a href="#声明接口" class="headerlink" title="声明接口"></a>声明接口</h3><p>在 C# 中声明接口需要使用 **interface **关键字，语法结构如下所示：</p>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public interface InterfaceName&#123;
  returnType funcName1(type parameterList);
  returnType funcName2(type parameterList);
  ... ...
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>其中，InterfaceName 为接口名称，returnType 为返回值类型，funcName 为成员函数的名称，parameterList 为参数列表。</p>
<p>【示例】下面通过具体的示例演示一下接口的使用：</p>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using System;
namespace c.biancheng.net
&#123;
    &#x2F;&#x2F;定义一个接口Iwebsite
    public interface Iwebsite&#123;
        void setValue(string str1, string str2);
        void disPlay();
    &#125;
    &#x2F;&#x2F;定义一个派生类Website，继承接口Iwebsite
    public class Website : Iwebsite&#123;
        public string name, url;
        &#x2F;&#x2F;派生类必须实现接口的所有成员
        public void setValue(string n, string u)&#123;
            name &#x3D; n;
            url &#x3D; u;
        &#125;
        public void disPlay()&#123;
            Console.WriteLine(&quot;&#123;0&#125; &#123;1&#125;&quot;, name, url);
        &#125;
    &#125;
    class Demo
    &#123;
        static void Main(string[] args) 
        &#123;
            Website web &#x3D; new Website();
            web.setValue(&quot;C语言中文网&quot;, &quot;http:&#x2F;&#x2F;c.biancheng.net&quot;);
            web.disPlay();
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>运行结果如下：</p>
<pre class="line-numbers language-none"><code class="language-none">C语言中文网 http:&#x2F;&#x2F;c.biancheng.net<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="接口继承"><a href="#接口继承" class="headerlink" title="接口继承"></a>接口继承</h3><p>在 C# 中，一个接口可以继承另一个接口，例如可以使用接口 1 继承接口 2，<strong>当用某个类来实现接口 1 时，必须同时实现接口 1 和接口 2 中的所有成员</strong>，下面通过一个示例来演示一下：</p>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using System;
namespace c.biancheng.net
&#123;
    &#x2F;&#x2F;定义一个接口IParentInterface
    public interface IParentInterface
    &#123;
        void ParentInterfaceMethod();
    &#125;
    &#x2F;&#x2F;定义一个接口IMyInterface，继承接口IParentInterface
    public interface IMyInterface : IParentInterface
    &#123;
        void MethodToImplement();
    &#125;
    &#x2F;&#x2F;定义一个类Demo，继承接口IMyInterface
    class Demo : IMyInterface
    &#123;
        static void Main(string[] args) 
        &#123;
            Demo demo &#x3D; new Demo();
            demo.MethodToImplement();
            demo.ParentInterfaceMethod();
        &#125;
        &#x2F;&#x2F;必须同时实现接口 IParentInterface 和接口 IMyInterface 中的所有成员
        public void MethodToImplement()&#123;
            Console.WriteLine(&quot;实现 IMyInterface 接口中的 MethodToImplement 函数&quot;);
        &#125;
        public void ParentInterfaceMethod()&#123;
            Console.WriteLine(&quot;实现 IParentInterface 接口中的 ParentInterfaceMethod 函数&quot;);
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>运行结果如下：</p>
<pre class="line-numbers language-none"><code class="language-none">实现 IMyInterface 接口中的 MethodToImplement 函数
实现 IParentInterface 接口中的 ParentInterfaceMethod 函数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h2 id="31-C-namespace：命名空间"><a href="#31-C-namespace：命名空间" class="headerlink" title="31. C# namespace：命名空间"></a>31. C# namespace：命名空间</h2><p>在 C# 中，可以将命名空间看作是一个范围，用来标注命名空间中成员的归属，一个命名空间中类与另一个命名空间中同名的类互不冲突，但在同一个命名空间中类的名称必须是唯一的。</p>
<p><strong>举个简单的例子，在一个简单的 C# 程序中，假如我们要输出某些数据，就需要使用<code>System.Console.WriteLine()</code>，</strong></p>
<p><strong>其中 System 就是命名空间，而 Console 是类的名字，WriteLine 则是具体要使用方法。</strong></p>
<p><strong>也就是说，如果要访问某个命名空间中的类，我们需要使用<code>namespacename.classname.funcname()</code>的形式。</strong></p>
<p><strong>当然也可以使用 using 关键字来引用需要的命名空间，例如<code>using System</code>，这样我们就可以直接使用<code>Console.WriteLine()</code>来输出指定的数据了。</strong></p>
<p>命名空间的结构类似于我们计算机系统中的目录，我们可以将某个目录看作是一个命名空间，在这个目录下可以存在若干不同的文件夹，这些文件夹就可以看作是命名空间下的类。而在每个文件夹下又存放着一些文件或文件夹，这些文件和文件夹则可以看作是类中的成员。</p>
<p>使用命名空间的好处是可以避免命名冲突，同时也便于查找类的位置。</p>
<h3 id="定义命名空间"><a href="#定义命名空间" class="headerlink" title="定义命名空间"></a>定义命名空间</h3><p>在 C# 中定义命名空间需要使用 namespace 关键字，语法格式如下：</p>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">namespace namespaceName&#123;
  &#x2F;&#x2F; 命名空间中的代码
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>若要调用指定命名空间下的成员，则需要使用<code>namespaceName.className.funcName()</code>的形式，下面通过一个示例来演示命名空间的使用：</p>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">namespace c.biancheng.net
&#123;
    class Demo
    &#123;
        static void Main(string[] args) 
        &#123;
            First.demoClass demo1 &#x3D; new First.demoClass();
            Second.demoClass demo2 &#x3D; new Second.demoClass();
            demo1.sayHello();
            demo2.sayHello();
        &#125;
    &#125;
&#125;
&#x2F;&#x2F;定义一个命名空间First
namespace First&#123;
    &#x2F;&#x2F;在命名空间First里定义一个类demoClass
    public class demoClass&#123;
        &#x2F;&#x2F;定义一个方法sayHello()
        public void sayHello()&#123;
            System.Console.WriteLine(&quot;First 命名空间下 demoClass 类中的 sayHello 函数&quot;);
        &#125;
    &#125;
&#125;
namespace Second&#123;
    public class demoClass&#123;
        public void sayHello()&#123;
            System.Console.WriteLine(&quot;Second 命名空间下 demoClass 类中的 sayHello 函数&quot;);
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>运行结果如下：</p>
<pre class="line-numbers language-none"><code class="language-none">First 命名空间下 demoClass 类中的 sayHello 函数
Second 命名空间下 demoClass 类中的 sayHello 函数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h3 id="using关键字"><a href="#using关键字" class="headerlink" title="using关键字"></a>using关键字</h3><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using System;
using first;	&#x2F;&#x2F;使用 using 关键字来引用需要的命名空间first

namespace test1
&#123;
    
    class test
    &#123;

        static void Main(string[] args)
        &#123;
            a aa &#x3D; new a();
            aa.hello();
        &#125;
    &#125;

&#125;

namespace first
&#123;
    public class a
    &#123;
        public void hello()
        &#123;
            Console.WriteLine(&quot;First&quot;);
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>运行结果如下：</p>
<pre class="line-numbers language-none"><code class="language-none">First<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="命名空间嵌套"><a href="#命名空间嵌套" class="headerlink" title="命名空间嵌套"></a>命名空间嵌套</h3><p>命名空间可以嵌套使用，也就是说我们可以在一个命名空间中再定义一个或几个命名空间，如下所示：</p>
<pre class="line-numbers language-none"><code class="language-none">namespace namespaceName1&#123;
  &#x2F;&#x2F; namespaceName1 下的代码
  namespace namespaceName2&#123;
    &#x2F;&#x2F; namespaceName2 下的代码
  &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>您可以使用点<code>.</code>运算符来访问嵌套的命名空间成员，例如<code>namespaceName1.namespaceName2</code>。下面通过示例来演示一下命名空间的嵌套使用：</p>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using System;
using first;
using first.second;

namespace test1
&#123;
    
    class test
    &#123;

        static void Main(string[] args)
        &#123;
            a aa &#x3D; new a();
            aa.hello();
            b bb &#x3D; new b();
            bb.hello();
        &#125;
    &#125;

&#125;

namespace first
&#123;
    public class a
    &#123;
        public void hello()
        &#123;
            Console.WriteLine(&quot;First&quot;);
        &#125;
    &#125;

    namespace second
    &#123;
        public class b
        &#123;
            public void hello()
            &#123;
                Console.WriteLine(&quot;First.second&quot;);
            &#125;
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>运行结果如下：</p>
<pre class="line-numbers language-none"><code class="language-none">First
First.second<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h2 id="32-C-预处理器指令"><a href="#32-C-预处理器指令" class="headerlink" title="32. C#预处理器指令"></a>32. C#预处理器指令</h2><p>预处理指令的作用主要是向编译器发出指令，以便在程序编译开始之前对信息进行一些预处理操作。在 C# 中，预处理器指令均以<code>#</code>开头，并且预处理器指令之前只能出现空格不能出现任何代码。另外，预处理器指令不是语句，因此它们不需要以分号<code>;</code>结尾。</p>
<p>在 C# 中，预处理指令用于帮助条件编译。不同于 C 和 C++ 中的指令，在 C# 中不能使用这些指令来创建宏，而且预处理器指令必须是一行中唯一的代码，不能掺杂其它。</p>
<h3 id="C-中的预处理器指令"><a href="#C-中的预处理器指令" class="headerlink" title="C# 中的预处理器指令"></a>C# 中的预处理器指令</h3><p>下表中列出了 C# 中提供的预处理器指令：</p>
<table>
<thead>
<tr>
<th>预处理器指令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>#define</td>
<td>用于定义一系列字符，可以将这些字符称为符号</td>
</tr>
<tr>
<td>#undef</td>
<td>用于取消一个已定义符号</td>
</tr>
<tr>
<td>#if</td>
<td>用于测试符号是否为真</td>
</tr>
<tr>
<td>#else</td>
<td>用于创建复合条件指令，与 #if 一起使用</td>
</tr>
<tr>
<td>#elif</td>
<td>用于创建复合条件指令</td>
</tr>
<tr>
<td>#endif</td>
<td>指定一个条件指令的结束</td>
</tr>
<tr>
<td>#line</td>
<td>用于修改编译器的行数以及（可选地）输出错误和警告的文件名</td>
</tr>
<tr>
<td>#error</td>
<td>用于在代码的指定位置生成一个错误</td>
</tr>
<tr>
<td>#warning</td>
<td>用于在代码的指定位置生成一级警告</td>
</tr>
<tr>
<td>#region</td>
<td>用于在使用 Visual Studio Code Editor 的大纲特性时，指定一个可展开或折叠的代码块</td>
</tr>
<tr>
<td>#endregion</td>
<td>用于标识 #region 块的结束</td>
</tr>
</tbody></table>
<h4 id="define-预处理器"><a href="#define-预处理器" class="headerlink" title="#define 预处理器"></a>#define 预处理器</h4><p>#define 预处理器指令用来创建符号常量，这个符号可以作为传递给 #if 指令的表达式，表达式将返回 true。#define 的语法格式如下：</p>
<pre class="line-numbers language-none"><code class="language-none">#define symbol<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>【示例】下面通过示例来演示 #define 预处理器指令的使用：</p>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">#define PI
using System;
namespace c.biancheng.net
&#123;
    class Demo
    &#123;
        static void Main(string[] args) 
        &#123;
            #if (PI)
                Console.WriteLine(&quot;PI 已定义&quot;);
            #else
                Console.WriteLine(&quot;PI 未定义&quot;);
            #endif
            Console.ReadKey();
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在C#中不能定义类似于这种</p>
<pre class="line-numbers language-none"><code class="language-none">#define inf 0x3f3f3f3f<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>会报错，<font color="red">应输入单行注释或行尾</font></p>
<ol>
<li><p>不能像在 C 和 C++ 中的通常做法一样，使用 <strong>#define</strong> 指令来声明常数值。最好是将 C# 中的常数定义为类或结构的静态成员。如果具有多个像这样的常数，可以考虑创建一个单独的“Constants”类来保存这些常数。</p>
</li>
<li><p>#define可以定义符号，但是无法对符号赋值。</p>
</li>
<li><p>对于<a target="_blank" rel="noopener" href="https://www.baidu.com/link?url=_2JL35X9_3fvhAKufZ7U5feJnH1LnYBRCUHS6dwMwaFbsePIeSZDva6jQBkW4QSrHg_iM8XQECwDWfjHrgjcpCHz-GUOLIUPfHIDPKcBlO3&wd=&eqid=97e0d3c90004b7f700000004630dce11">#IF</a>，C# 中的 #if 语句是 Boolean，仅测试符号是否已定义。</p>
</li>
<li><p>#define单独用没什么意义，一般是和#if或者Conditional特性结合使用</p>
</li>
<li><p>#define必须定义在所有using命名空间前面；</p>
</li>
</ol>
<p>可以参考：<a target="_blank" rel="noopener" href="https://article.itxueyuan.com/bKRL8x">C#—#define条件编译</a></p>
<h4 id="条件指令"><a href="#条件指令" class="headerlink" title="条件指令"></a>条件指令</h4><p>您可以使用 #if 来创建条件指令，条件指令可以用于测试一个或多个符号的值是否为 true 。如果符号的值为 true，那么编译器将评估 #if 指令和下一个指令之间的所有代码。在语法上 #if 预处理器语句与 C# 中的 if 条件判断语句比较相似，如下所示：</p>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">#if symbol_1
  &#x2F;&#x2F; 要执行的代码
#elif symbol_2
  &#x2F;&#x2F; 要执行的代码
#else
  &#x2F;&#x2F; 要执行的代码
#endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>其中，symbol 是要测试的符号的名称。</p>
<p>条件指令中仅可以使用运算符<code>==</code>（相等）和<code>!=</code>（不相等）来测试布尔值 true 或 false，例如 true 表示已定义该符号。另外，还可以使用<code>&amp;&amp; (and)</code>、<code>|| (or)</code>和<code>! (not)</code>运算符来同时测试多个符号，以及使用括号对符号和运算符分组。</p>
<pre class="line-numbers language-none"><code class="language-none">注意：以 #if 指令开头的条件指令必须以 #endif 指令显式结束。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>下面通过示例来演示条件指令的使用：</p>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">#define DEBUG
#define VC_V10
using System;
namespace c.biancheng.net
&#123;
    class Demo
    &#123;
        static void Main(string[] args) 
        &#123;
            #if (DEBUG &amp;&amp; !VC_V10)
                Console.WriteLine(&quot;DEBUG 已定义&quot;);
            #elif (!DEBUG &amp;&amp; VC_V10)
                Console.WriteLine(&quot;VC_V10 已定义&quot;);
            #elif (DEBUG &amp;&amp; VC_V10)
                Console.WriteLine(&quot;DEBUG and VC_V10 已定义&quot;);
            #else
                Console.WriteLine(&quot;DEBUG and VC_V10 未定义&quot;);
            #endif
            Console.ReadKey();
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>运行结果如下：</p>
<pre class="line-numbers language-none"><code class="language-none">DEBUG and VC_V10 已定义<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="33-C-正则表达式"><a href="#33-C-正则表达式" class="headerlink" title="33. C#正则表达式"></a>33. C#正则表达式</h2><p>正则表达式是一种匹配输入文本的模式，可以用于解析和验证给定文本以及模式之间是否匹配，模式可以包含运算符、字符字面值或结构。</p>
<p><strong>正则表达式的组成</strong></p>
<p>我们可以使用正则表达式检查给定字符串是否与指定模式相匹配。正则表达式的匹配模式由一系列字符组成，其中可以包括数子、文字、运算符、字符等等。我们可以使用这些模式来搜索字符串或文件，并查看是否找到了匹配的项。</p>
<p>开发中我们一般使用正则表达式来验证用户输入的信息是否正确，比如邮箱地址、手机号码等等。下面列举了用于定义正则表达式的各种类别的字符、运算符和结构：</p>
<ul>
<li>转义字符；</li>
<li>字符类；</li>
<li>定位符；</li>
<li>分组构造；</li>
<li>限定符；</li>
<li>反向引用构造；</li>
<li>备用构造；</li>
<li>替换；</li>
<li>杂项构造。</li>
</ul>
<h3 id="1-转义字符"><a href="#1-转义字符" class="headerlink" title="1) 转义字符"></a>1) 转义字符</h3><p>正则表达式中的反斜杠<code>\</code>用来表示它后面跟随的字符是特殊字符，具有特殊的含义</p>
<h3 id="2-字符类"><a href="#2-字符类" class="headerlink" title="2) 字符类"></a>2) 字符类</h3><p>字符类可以与一个字符串中的任何一个字符相匹配</p>
<h3 id="3-定位符"><a href="#3-定位符" class="headerlink" title="3) 定位符"></a>3) 定位符</h3><p>定位符可以根据字符串出现的具体位置来判断匹配是成功还是失败</p>
<h3 id="4-分组构造"><a href="#4-分组构造" class="headerlink" title="4) 分组构造"></a>4) 分组构造</h3><p>分组构造描述了正则表达式的子表达式，并捕获输入字符串的子字符串</p>
<h3 id="5-限定符"><a href="#5-限定符" class="headerlink" title="5) 限定符"></a>5) 限定符</h3><p>限定符用来指定在字符串中必须存在某个元素（可以是字符、组或字符类）才能匹配成功</p>
<h3 id="6-反向引用构造"><a href="#6-反向引用构造" class="headerlink" title="6) 反向引用构造"></a>6) 反向引用构造</h3><p>反向引用构造允许先前匹配的子表达式随后在相同的正则表达式中进行标识</p>
<h3 id="7-备用构造"><a href="#7-备用构造" class="headerlink" title="7) 备用构造"></a>7) 备用构造</h3><p>备用构造用于修改正则表达式以启用 either/or 匹配</p>
<h3 id="8-替换"><a href="#8-替换" class="headerlink" title="8) 替换"></a>8) 替换</h3><p>替换是替换模式中使用的正则表达式</p>
<p>具体可参考<a target="_blank" rel="noopener" href="http://m.biancheng.net/csharp/regular-expressions.html">C编程网</a></p>
<h2 id="34-C-异常处理"><a href="#34-C-异常处理" class="headerlink" title="34. C#异常处理"></a>34. C#异常处理</h2><p>在 C# 中，异常是在程序运行出错时引发的，例如以一个数字除以零，<strong>所有异常都派生自 System.Exception 类</strong>。异常处理则是处理运行时错误的过程，使用异常处理可以使程序在发生错误时保持正常运行。</p>
<p><strong>C# 中的异常处理基于四个关键字构建，分别是 try、catch、finally 和 throw。</strong></p>
<ul>
<li>try：try 语句块中通常用来存放容易出现异常的代码，其后面紧跟一个或多个 catch 语句块；</li>
<li>catch：catch 语句块用来捕获 try 语句块中的出现的异常；</li>
<li>finally：finally 语句块用于执行特定的语句，不管异常是否被抛出都会执行；</li>
<li>throw：throw 用来抛出一个异常。</li>
</ul>
<h3 id="1）try-catch语句"><a href="#1）try-catch语句" class="headerlink" title="1）try/catch语句"></a>1）try/catch语句</h3><p>假设一段代码引发了异常，则可以使用 try 和 catch 组合来捕获这个异常，其语法格式如下所示：</p>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">try&#123;
  &#x2F;&#x2F; 引起异常的语句
&#125;catch( ExceptionName e1 )&#123;
  &#x2F;&#x2F; 错误处理代码
&#125;catch( ExceptionName e2 )&#123;
  &#x2F;&#x2F; 错误处理代码
&#125;
...
catch( ExceptionName eN )&#123;
  &#x2F;&#x2F; 错误处理代码
&#125;finally&#123;
  &#x2F;&#x2F; 要执行的语句
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>如上所示，可以列出多个 catch 语句块来捕获不同类型的异常，以防止 try 语句块在不同的情况下产生多个异常。</p>
<p>【示例】使用 try/catch 语句捕获程序中的异常：</p>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using System;

namespace test1
&#123;
    class test
    &#123;
        static void Main(string[] args)
        &#123;
            &#x2F;&#x2F;try用来存放容易出现异常的代码
            try
            &#123;
                int a &#x3D; 123;
                int b &#x3D; 0;
                int x &#x3D; a &#x2F; b;      &#x2F;&#x2F;分母为0，会抛出异常，line 14
            &#125;
            &#x2F;&#x2F;catch用来捕获 try 语句块中的出现的异常
            catch(Exception e)
            &#123;
                Console.WriteLine(&quot;捕获到的异常：&quot; + e);
            &#125;
            &#x2F;&#x2F;finally用于执行特定的语句，不管异常是否被抛出都会执行
            finally
            &#123;
                Console.WriteLine(&quot;这是一定会执行的语句&quot;);
            &#125;
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>运行结果如下：</p>
<pre class="line-numbers language-none"><code class="language-none">捕获到的异常：System.DivideByZeroException: Attempted to divide by zero.
   at test1.test.Main(String[] args) in 
目录:line 14
这是一定会执行的语句<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="2）C-中的异常类"><a href="#2）C-中的异常类" class="headerlink" title="2）C#中的异常类"></a>2）C#中的异常类</h3><p><strong>C# 中的异常类主要是从 System.Exception 类派生的</strong>，比如 System.ApplicationException 和 System.SystemException 两个异常类就是从 System.Exception 类派生的。</p>
<ul>
<li>System.ApplicationException 类支持由程序产生的异常，因此我们<strong>自定义</strong>的异常都应继承此类；</li>
<li>System.SystemException 类是所有<strong>系统预定义</strong>异常的基类。</li>
</ul>
<p>下表中列举了一些从 Sytem.SystemException 类派生的预定义异常类：</p>
<table>
<thead>
<tr>
<th>异常类</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>System.IO.IOException</td>
<td>处理 I/O 错误</td>
</tr>
<tr>
<td>System.IndexOutOfRangeException</td>
<td>处理当方法引用超出范围的数组索引时产生的错误</td>
</tr>
<tr>
<td>System.ArrayTypeMismatchException</td>
<td>处理当数组类型不匹配时产生的错误</td>
</tr>
<tr>
<td>System.NullReferenceException</td>
<td>处理引用一个空对象时产生的错误</td>
</tr>
<tr>
<td>System.DivideByZeroException</td>
<td>处理当除以零时产生的错误</td>
</tr>
<tr>
<td>System.InvalidCastException</td>
<td>处理在类型转换期间产生的错误</td>
</tr>
<tr>
<td>System.OutOfMemoryException</td>
<td>处理空闲内存不足产生的错误</td>
</tr>
<tr>
<td>System.StackOverflowException</td>
<td>处理栈溢出产生的错误</td>
</tr>
</tbody></table>
<h3 id="3）自定义异常类"><a href="#3）自定义异常类" class="headerlink" title="3）自定义异常类"></a>3）自定义异常类</h3><p>除了可以使用系统预定义的异常类外，我们还可以自行定义异常类，自定义的异常类都应继承 System.ApplicationException 类。下面通过示例来演示一下自定义异常类的使用：</p>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using System;
namespace c.biancheng.net
&#123;
    class Demo
    &#123;
        static void Main(string[] args)
        &#123;
            TestUserDefinedException test &#x3D; new TestUserDefinedException();
            try
            &#123;
                test.validate(12);
            &#125;
            catch (InvalidAgeException e)
            &#123;
                Console.WriteLine(&quot;InvalidAgeException: &#123;0&#125;&quot;, e);
            &#125;
            Console.WriteLine(&quot;其它代码&quot;);
        &#125;
    &#125;
&#125;

&#x2F;&#x2F;自定义异常类，自定义的异常都应继承System.ApplicationException
public class InvalidAgeException : ApplicationException
&#123;
    &#x2F;&#x2F;构造函数, Base 是子类构造函数中引用父类构造函数
    public InvalidAgeException(string message) : base(message)
    &#123;
    &#125;
&#125;

public class TestUserDefinedException
&#123;
    public void validate(int age)
    &#123;
        if (age &lt; 18)
        &#123;
            throw (new InvalidAgeException(&quot;Sorry, Age must be greater than 18&quot;));
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在构造方法后面加上了:base(message)，该类如下：</p>
<p>public InvalidAgeException(string message)是InvalidAgeException的构造函数，base(message)是其父类的构造函数</p>
<p>public InvalidAgeException(string message) : base(message)指的是在InvalidAgeException中调用其父类的带string类型的构造函数。因为在子类不能直接继承父类的构造函数，</p>
<p>只能通过这种方式调用。</p>
<p>我的理解是，当父类有多个构造函数时，通过:base()来指定父类该调哪个构造函数</p>
<p>可参考<a target="_blank" rel="noopener" href="https://www.cnblogs.com/topsyuan/p/11243890.html">C# 构造函数base()实例演示 </a></p>
<h3 id="4）抛出异常"><a href="#4）抛出异常" class="headerlink" title="4）抛出异常"></a>4）抛出异常</h3><p>如果异常是直接或间接派生自 System.Exception 类，则可以在 catch 语句块中使用 throw 语句抛出该异常，所谓抛出异常这里可以理解为重新引发该异常。throw 语句的语法格式如下所示：</p>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">catch(Exception e) &#123;
  ...
  Throw e
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="35-C-文件读写"><a href="#35-C-文件读写" class="headerlink" title="35. C#文件读写"></a>35. C#文件读写</h2><p>文件是存储在磁盘中的具有特定名称和目录路径的数据集合，当我们使用程序对文件进行读取或写入时，程序会将文件以<strong>数据流（简称流）</strong>的形式读入内存中。我们<strong>可以将流看作是通过通信路径传递的字节序列</strong>，流主要分为<strong>输入流和输出流</strong>，输入流主要用于从文件读取数据（读操作），输出流主要用于向文件中写入数据（写操作）。</p>
<p>具体可参考C编程网<a target="_blank" rel="noopener" href="http://m.biancheng.net/csharp/file-io.html">C#文件读写</a></p>
<h3 id="C-中的-I-O-类"><a href="#C-中的-I-O-类" class="headerlink" title="C# 中的 I/O 类"></a>C# 中的 I/O 类</h3><p>System.IO 命名空间中包含了各种用于文件操作的类，例如文件的创建、删除、读取、写入等等。如下表中所示：</p>
<table>
<thead>
<tr>
<th>I/O 类</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>BinaryReader</td>
<td>从二进制流中读取原始数据</td>
</tr>
<tr>
<td>BinaryWriter</td>
<td>以二进制格式写入原始数据</td>
</tr>
<tr>
<td>BufferedStream</td>
<td>临时存储字节流</td>
</tr>
<tr>
<td>Directory</td>
<td>对目录进行复制、移动、重命名、创建和删除等操作</td>
</tr>
<tr>
<td>DirectoryInfo</td>
<td>用于对目录执行操作</td>
</tr>
<tr>
<td>DriveInfo</td>
<td>获取驱动器的信息</td>
</tr>
<tr>
<td>File</td>
<td>对文件进行操作</td>
</tr>
<tr>
<td>FileInfo</td>
<td>用于对文件执行操作</td>
</tr>
<tr>
<td>FileStream</td>
<td>用于文件中任何位置的读写</td>
</tr>
<tr>
<td>MemoryStream</td>
<td>用于随机访问存储在内存中的数据流</td>
</tr>
<tr>
<td>Path</td>
<td>对路径信息执行操作</td>
</tr>
<tr>
<td>StreamReader</td>
<td>用于从字节流中读取字符</td>
</tr>
<tr>
<td>StreamWriter</td>
<td>用于向一个流中写入字符</td>
</tr>
<tr>
<td>StringReader</td>
<td>用于从字符串缓冲区读取数据</td>
</tr>
<tr>
<td>StringWriter</td>
<td>用于向字符串缓冲区写入数据</td>
</tr>
</tbody></table>
<h4 id="1）FileStream-类"><a href="#1）FileStream-类" class="headerlink" title="1）FileStream 类"></a>1）FileStream 类</h4><p>FileStream 类在 System.IO 命名空间下，使用它可以读取、写入和关闭文件。创建 FileStream 类对象的语法格式如下所示：</p>
<pre class="line-numbers language-none"><code class="language-none">FileStream &lt;object_name&gt; &#x3D; new FileStream(&lt;file_name&gt;, &lt;FileMode Enumerator&gt;, &lt;FileAccess Enumerator&gt;, &lt;FileShare Enumerator&gt;);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>参数说明如下：</p>
<ul>
<li>object_name：创建的对象名称；</li>
<li>file_name：文件的路径（包含文件名在内）；</li>
<li>FileMode：枚举类型，用来设定文件的打开方式，可选值如下：<ul>
<li>Append：打开一个已有的文件，并将光标放置在文件的末尾。如果文件不存在，则创建文件；</li>
<li>Create：创建一个新的文件，如果文件已存在，则将旧文件删除，然后创建新文件；</li>
<li>CreateNew：创建一个新的文件，如果文件已存在，则抛出异常；</li>
<li>Open：打开一个已有的文件，如果文件不存在，则抛出异常；</li>
<li>OpenOrCreate：打开一个已有的文件，如果文件不存在，则创建一个新的文件并打开；</li>
<li>Truncate：打开一个已有的文件，然后将文件清空（删除原有内容），如果文件不存在，则抛出异常。</li>
</ul>
</li>
<li>FileAccess：枚举类型，用来设置文件的存取，可选值有 Read、ReadWrite 和 Write；</li>
<li>FileShare：枚举类型，用来设置文件的权限，可选值如下：<ul>
<li>Inheritable：允许子进程继承文件句柄，Win32 不直接支持此功能；</li>
<li>None：在文件关闭前拒绝共享当前文件，打开该文件的任何请求（由此进程或另一进程发出的请求）都将失败；</li>
<li>Read：允许随后打开文件读取，如果未指定此标志，则文件关闭前，任何打开该文件以进行读取的请求都将失败，需要注意的是，即使指定了此标志，仍需要附加权限才能够访问该文件；</li>
<li>ReadWrite：允许随后打开文件读取或写入，如果未指定此标志，则文件关闭前，任何打开该文件以进行读取或写入的请求都将失败，需要注意的是，即使指定了此标志，仍需要附加权限才能够访问该文件；</li>
<li>Write：允许随后打开文件写入，如果未指定此标志，则文件关闭前，任何打开该文件以进行写入的请求都将失败，需要注意的是，即使指定了此标志，仍可能需要附加权限才能够访问该文件；</li>
<li>Delete：允许随后删除文件。</li>
</ul>
</li>
</ul>
<p>例如，我们创建一个 FileStream 对象 F 来读取一个名为 sample.txt 的文件，示例代码如下所示：</p>
<pre class="line-numbers language-none"><code class="language-none">FileStream F &#x3D; new FileStream(&quot;sample.txt&quot;, FileMode.Open, FileAccess.Read, FileShare.Read);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>FileStream 类中的常用方法如下所示：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Close()</td>
<td>关闭当前流并释放与之关联的所有资源（如套接字和文件句柄）</td>
</tr>
<tr>
<td>CopyTo(Stream)</td>
<td>从当前流中读取字节并将其写入到另一流中</td>
</tr>
<tr>
<td>Dispose()</td>
<td>释放由 Stream 使用的所有资源</td>
</tr>
<tr>
<td>Equals(Object)</td>
<td>判断指定对象是否等于当前对象</td>
</tr>
<tr>
<td>Finalize()</td>
<td>确保垃圾回收器回收 FileStream 时释放资源并执行其他清理操作</td>
</tr>
<tr>
<td>Flush()</td>
<td>清除此流的缓冲区，使得所有缓冲数据都写入到文件中</td>
</tr>
<tr>
<td>GetHashCode()</td>
<td>默认哈希函数</td>
</tr>
<tr>
<td>GetType()</td>
<td>获取当前实例的 Type</td>
</tr>
<tr>
<td>Lock(Int64, Int64)</td>
<td>防止其他进程读取或写入 FileStream</td>
</tr>
<tr>
<td>Read(Byte[], Int32, Int32)</td>
<td>从流中读取字节块并将该数据写入给定缓冲区中</td>
</tr>
<tr>
<td>ReadByte()</td>
<td>从文件中读取一个字节，并将读取位置提升一个字节</td>
</tr>
<tr>
<td>ToString()</td>
<td>返回表示当前对象的字符串</td>
</tr>
<tr>
<td>Unlock(Int64, Int64)</td>
<td>允许其他进程访问以前锁定的某个文件的全部或部分</td>
</tr>
<tr>
<td>Write(Byte[], Int32, Int32)</td>
<td>将字节块写入文件流</td>
</tr>
<tr>
<td>WriteByte(Byte)</td>
<td>将一个字节写入文件流中的当前位置</td>
</tr>
</tbody></table>
<p>【示例】使用 FileStream 类读取指定的文件：</p>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using System;
using System.IO;
&#x2F;&#x2F;System.IO 命名空间中包含了各种用于文件操作的类

namespace test1
&#123;
    class test
    &#123;
        static void Main(string[] args)
        &#123;
            FileStream file &#x3D; new FileStream(&quot;test.txt&quot;, FileMode.OpenOrCreate, FileAccess.ReadWrite);
            
            &#x2F;*
            创建一个文件，名为test.txt；
            
			FileMode.OpenOrCreate 打开一个已有的文件，
            如果文件不存在，则创建一个新的文件并打开；
            
            FileAccess.ReadWrite 允许随后打开文件读取或写入，
            如果未指定此标志，则文件关闭前，任何打开该文件以进行
            读取或写入的请求都将失败，需要注意的是，即使指定了此
            标志，仍需要附加权限才能够访问该文件；
            *&#x2F;
            
            for(int i &#x3D; 0; i &lt; 20; i++)
            &#123;
                file.WriteByte((byte)i);
                &#x2F;&#x2F;将一个字节写入文件流中的当前位置
                &#x2F;&#x2F;byte为8位无符号整数，即一个字节
            &#125;
            file.Position &#x3D; 0;
            &#x2F;&#x2F;当前FileStream所在的流位置设置为0

            for(int i &#x3D; 0; i &lt; 20; i++)
            &#123;
                Console.Write(file.ReadByte() + &quot; &quot;);
                &#x2F;&#x2F;从流中读取字节块并将该数据写入给定缓冲区中
            &#125;
            file.Close();
            Console.ReadKey();
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>运行结果如下：</p>
<pre class="line-numbers language-none"><code class="language-none">0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>从文件夹中可以看到文件已被创建</p>
<p><strong>System.IO 命名空间下的 StreamReader 和 StreamWriter 类可以用于文本文件的数据读写。这些类继承自抽象基类 Stream，Stream 类提供了对文件流读写的功能。</strong></p>
<h3 id="文件流读写"><a href="#文件流读写" class="headerlink" title="文件流读写"></a>文件流读写</h3><h4 id="1）StreamReader"><a href="#1）StreamReader" class="headerlink" title="1）StreamReader"></a>1）StreamReader</h4><p>StreamReader 类继承自抽象基类 TextReader，用来从文件中读取一系列<strong>字符</strong>，下表列出了 StreamReader 类中一些常用的方法：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>public override void Close()</td>
<td>关闭 StreamReader 对象和基础流，并释放任何与之相关的系统资源</td>
</tr>
<tr>
<td>public override int Peek()</td>
<td>返回下一个可用的字符，但不使用它</td>
</tr>
<tr>
<td>public override int Read()</td>
<td>从输入流中读取下一个字符，并把字符位置往前移一个字符</td>
</tr>
</tbody></table>
<p>如果想查阅完整的方法列表，可以访问 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/dotnet/api/system.io.streamreader">C# 的官网文档</a>。</p>
<p>test.txt的内容为123</p>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using System;
using System.IO;
&#x2F;&#x2F;System.IO 命名空间中包含了各种用于文件操作的类

namespace test1
&#123;
    class test
    &#123;
        static void Main(string[] args)
        &#123;
            try
            &#123;
                &#x2F;&#x2F;创建StreamReader类的对象
                StreamReader sr &#x3D; new StreamReader(&quot;test.txt&quot;);
                string line;

                &#x2F;&#x2F;从文件中读取内容
                while ((line &#x3D; sr.ReadLine()) !&#x3D; null)
                    &#x2F;&#x2F;从当前流中读取一行字符并将数据作为字符串返回
                &#123;
                    Console.WriteLine(line);
                &#125;
            &#125;
            catch(Exception e)
            &#123;
                &#x2F;&#x2F;展示出错信息
                Console.WriteLine(&quot;无法读取文件&quot;);
                Console.WriteLine(e.Message);
            &#125;
            Console.ReadKey();
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="2）StreamWriter"><a href="#2）StreamWriter" class="headerlink" title="2）StreamWriter"></a>2）StreamWriter</h4><p>StreamWriter 类同样继承自抽象类 TextWriter，用来向文件中写入一系列<strong>字符</strong>，下表列出了 StreamWriter 类中一些常用的方法：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>public override void Close()</td>
<td>关闭当前的 StreamWriter 对象和基础流</td>
</tr>
<tr>
<td>public override void Flush()</td>
<td>清理当前所有的缓冲区，使所有缓冲数据写入基础流</td>
</tr>
<tr>
<td>public virtual void Write(bool value)</td>
<td>将布尔值的文本表示形式写入文本流</td>
</tr>
<tr>
<td>public override void Write(char value)</td>
<td>将一个字符写入流</td>
</tr>
<tr>
<td>public virtual void Write(decimal value)</td>
<td>将一个小数值的文本表示形式写入文本流</td>
</tr>
<tr>
<td>public virtual void Write(double value)</td>
<td>将一个 8 字节浮点值的文本表示形式写入文本流</td>
</tr>
<tr>
<td>public virtual void Write(int value)</td>
<td>将一个 4 字节有符号整数的文本表示形式写入文本流</td>
</tr>
<tr>
<td>public override void Write(string value)</td>
<td>将一个字符串写入文本流</td>
</tr>
<tr>
<td>public virtual void WriteLine()</td>
<td>将行结束符写入文本流</td>
</tr>
</tbody></table>
<p>完整的方法列表请查阅 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/dotnet/api/system.io.streamwriter">C# 的官方文档</a>。</p>
<h3 id="二进制文件读写"><a href="#二进制文件读写" class="headerlink" title="二进制文件读写"></a>二进制文件读写</h3><h4 id="1-BinaryReader-类"><a href="#1-BinaryReader-类" class="headerlink" title="1) BinaryReader 类"></a>1) BinaryReader 类</h4><p>BinaryReader 类用于从文件读取二进制数据，类中的常用方法如下所示：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>public override void Close()</td>
<td>关闭 BinaryReader 对象和基础流</td>
</tr>
<tr>
<td>public virtual int Read()</td>
<td>从基础流中读取字符，并根据所使用的编码和从流中读取的特定字符，将流的当前位置前移</td>
</tr>
<tr>
<td>public virtual bool ReadBoolean()</td>
<td>从当前流中读取一个布尔值，并将流的当前位置前移一个字节</td>
</tr>
<tr>
<td>public virtual byte ReadByte()</td>
<td>从当前流中读取下一个字节，并将流的当前位置前移一个字节</td>
</tr>
<tr>
<td>public virtual byte[] ReadBytes(int count)</td>
<td>从当前流中读取指定数目的字节到一个字节数组中，并将流的当前位置前移指定数目的字节</td>
</tr>
<tr>
<td>public virtual char ReadChar()</td>
<td>从当前流中读取下一个字节，并把流的当前位置按照所使用的编码和从流中读取的指定的字符往前移</td>
</tr>
<tr>
<td>public virtual char[] ReadChars(int count)</td>
<td>从当前流中读取指定数目的字符，并以字符数组的形式返回数据，并把流的当前位置按照所使用的编码和从流中读取的指定的字符往前移</td>
</tr>
<tr>
<td>public virtual double ReadDouble()</td>
<td>从当前流中读取一个 8 字节浮点值，并把流的当前位置前移八个字节</td>
</tr>
<tr>
<td>public virtual int ReadInt32()</td>
<td>从当前流中读取一个 4 字节有符号整数，并把流的当前位置前移四个字节</td>
</tr>
<tr>
<td>public virtual string ReadString()</td>
<td>从当前流中读取一个字符串，字符串以长度作为前缀，同时编码为一个七位的整数</td>
</tr>
</tbody></table>
<p>完整的方法列表请查阅 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/dotnet/api/system.io.binaryreader">C# 的官方文档</a>。</p>
<h4 id="2-BinaryWriter-类"><a href="#2-BinaryWriter-类" class="headerlink" title="2) BinaryWriter 类"></a>2) BinaryWriter 类</h4><p>BinaryWriter 类用于向文件写入二进制数据，类中的常用方法如下表所示：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>public override void Close()</td>
<td>关闭 BinaryWriter 对象和基础流</td>
</tr>
<tr>
<td>public virtual void Flush()</td>
<td>清理当前编写器的所有缓冲区，使得所有缓冲数据写入基础设备</td>
</tr>
<tr>
<td>public virtual long Seek(int offset,SeekOrigin origin)</td>
<td>设置当前流中的位置</td>
</tr>
<tr>
<td>public virtual void Write(bool value)</td>
<td>将一个字节的布尔值写入到当前流中，0 表示 false，1 表示 true</td>
</tr>
<tr>
<td>public virtual void Write(byte value)</td>
<td>将一个无符号字节写入到当前流中，并把流的位置前移一个字节</td>
</tr>
<tr>
<td>public virtual void Write(byte[] buffer)</td>
<td>将一个字节数组写入到基础流中</td>
</tr>
<tr>
<td>public virtual void Write(char ch)</td>
<td>将一个 Unicode 字符写入到当前流中，并把流的当前位置按照所使用的编码和要写入到流中的指定字符往前移</td>
</tr>
<tr>
<td>public virtual void Write(char[] chars)</td>
<td>将一个字符数组写入到当前流中，并把流的当前位置按照所使用的编码和要写入到流中的指定字符往前移</td>
</tr>
<tr>
<td>public virtual void Write(double value)</td>
<td>将一个 8 字节浮点值写入到当前流中，并把流位置前移八个字节</td>
</tr>
<tr>
<td>public virtual void Write(int value)</td>
<td>将一个 4 字节有符号整数写入到当前流中，并把流位置前移四个字节</td>
</tr>
<tr>
<td>public virtual void Write(string value)</td>
<td>将一个有长度前缀的字符串按 BinaryWriter 的当前编码写如到流中，并把流的当前位置按照所使用的编码和要写入到流中的指定字符往前移</td>
</tr>
</tbody></table>
<p>完整的方法列表请查阅 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/dotnet/api/system.io.binarywriter">C# 的官方文档</a>。</p>
<p>【示例】下面通过示例演示二进制文件的读取和写入：</p>
<pre class="line-numbers language-none"><code class="language-none"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">B b &#x3D; new B();
A a &#x3D; new A(b); 

&#x2F;&#x2F;这和 A a&#x3D;new A(new B())一样



class A&#123;
	&#x2F;&#x2F;在A中有这样一个有构造函数
    public A(B b)&#123;
    ...
    &#125;
&#125;
class B&#123;

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">8yyy</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="http://example.com/2022/08/21/CSharpNotes/">http://example.com/2022/08/21/CSharpNotes/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">8yyy</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/CSharp/">
                                    <span class="chip bg-color">CSharp</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/8yyy/8yyy.github.io/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="https://cdn.jsdelivr.net/gh/8yyy/8yyy.github.io/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="https://cdn.jsdelivr.net/gh/8yyy/8yyy.github.io/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="https://cdn.jsdelivr.net/gh/8yyy/8yyy.github.io/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2022/09/02/%E5%88%98%E9%93%81%E7%8C%9B%E3%80%8AC-%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E8%AF%A6%E8%A7%A3%E3%80%8B%E7%AC%94%E8%AE%B0/">
                    <div class="card-image">
                        
                        
                        <img src="https://cdn.jsdelivr.net/gh/8yyy/8yyy.github.io/medias/featureimages/12.jpg" class="responsive-img" alt="刘铁猛《C#语言入门详解》笔记">
                        
                        <span class="card-title">刘铁猛《C#语言入门详解》笔记</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2022-09-02
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            8yyy
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/CSharp/">
                        <span class="chip bg-color">CSharp</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2022/01/23/%E8%AE%B0%E5%BD%95%E4%B8%8B%E8%87%AA%E5%B7%B1%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%9A%84%E8%BF%87%E7%A8%8B%E5%92%8C%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/">
                    <div class="card-image">
                        
                        
                        <img src="https://cdn.jsdelivr.net/gh/8yyy/8yyy.github.io/medias/featureimages/5.jpg" class="responsive-img" alt="记录下自己搭建博客的过程和注意事项">
                        
                        <span class="card-title">记录下自己搭建博客的过程和注意事项</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2022-01-23
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            8yyy
                            
                        </span>
                    </div>
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/8yyy/8yyy.github.io/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/8yyy/8yyy.github.io/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/8yyy/8yyy.github.io/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/8yyy/8yyy.github.io/libs/codeBlock/codeShrink.js"></script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="https://cdn.jsdelivr.net/gh/8yyy/8yyy.github.io/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/8yyy/8yyy.github.io/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="503838841"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="https://cdn.jsdelivr.net/gh/8yyy/8yyy.github.io/libs/aplayer/APlayer.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/8yyy/8yyy.github.io/libs/aplayer/Meting.min.js"></script>

    

    <div class="container row center-align"
         style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2019-2022</span>
            
            <a href="/about" target="_blank">8yyy</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            
            
                
            
            
                <span id="busuanzi_container_site_pv">
                &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;
                    <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
                <span id="busuanzi_container_site_uv">
                &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;
                    <span id="busuanzi_value_site_uv" class="white-color"></span>
            </span>
            
            <br>

            <!-- 运行天数提醒. -->
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">


    <a href="mailto:1410868939@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=1410868939" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 1410868939" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="https://cdn.jsdelivr.net/gh/8yyy/8yyy.github.io/libs/materialize/materialize.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/8yyy/8yyy.github.io/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/8yyy/8yyy.github.io/libs/aos/aos.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/8yyy/8yyy.github.io/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/8yyy/8yyy.github.io/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/8yyy/8yyy.github.io/js/matery.js"></script>

    

    

    <!-- 雪花特效 -->
    

    <!-- 鼠标星星特效 -->
    

     
        <script src="https://ssl.captcha.qq.com/TCaptcha.js"></script>
        <script src="https://cdn.jsdelivr.net/gh/8yyy/8yyy.github.io/libs/others/TencentCaptcha.js"></script>
        <button id="TencentCaptcha" data-appid="xxxxxxxxxx" data-cbfn="callback" type="button" hidden></button>
    

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="https://cdn.jsdelivr.net/gh/8yyy/8yyy.github.io/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="https://cdn.jsdelivr.net/gh/8yyy/8yyy.github.io/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <!--腾讯兔小巢-->
    
    

    

    

    
    <script src="https://cdn.jsdelivr.net/gh/8yyy/8yyy.github.io/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
