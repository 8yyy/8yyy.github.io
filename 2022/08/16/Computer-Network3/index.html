<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="第三章 传输层, 8yyy&#39;s blog">
    <meta name="description" content="目标： 

理解传输层的工作原理
多路复用/解复用 
可靠数据传输
流量控制
拥塞控制 


学习Internet的传输层协议 
UDP：无连接传输 
TCP：面向连接的可靠传 输 
TCP的拥塞控制



1. 概述和传输层服务传输服务和">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>第三章 传输层 | 8yyy&#39;s blog</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/8yyy/8yyy.github.io/libs/awesome/css/all.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/8yyy/8yyy.github.io/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/8yyy/8yyy.github.io/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/8yyy/8yyy.github.io/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/8yyy/8yyy.github.io/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/8yyy/8yyy.github.io/css/matery.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/8yyy/8yyy.github.io/css/my.css">

    <script src="https://cdn.jsdelivr.net/gh/8yyy/8yyy.github.io/libs/jquery/jquery-3.6.0.min.js"></script>

<meta name="generator" content="Hexo 6.3.0"></head>



   <style>
    body{
       background-image: url(https://cdn.jsdelivr.net/gh/Tokisaki-Galaxy/res/site/medias/background.jpg);
       background-repeat:no-repeat;
       background-size: 100% 100%;
       background-attachment:fixed;
    }
</style>



<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">8yyy&#39;s blog</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="https://cdn.jsdelivr.net/gh/8yyy/8yyy.github.io/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">8yyy&#39;s blog</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        
    </ul>
</div>


        </div>

        
    </nav>

</header>

    
<script src="https://cdn.jsdelivr.net/gh/8yyy/8yyy.github.io/libs/cryptojs/crypto-js.min.js"></script>
<script>
    (function() {
        let pwd = '';
        if (pwd && pwd.length > 0) {
            if (pwd !== CryptoJS.SHA256(prompt('请输入访问本文章的密码')).toString(CryptoJS.enc.Hex)) {
                alert('密码错误，将返回主页！');
                location.href = '/';
            }
        }
    })();
</script>




<div class="bg-cover pd-header post-cover" style="background-image: url('https://cdn.jsdelivr.net/gh/8yyy/8yyy.github.io/medias/featureimages/14.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">第三章 传输层</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/8yyy/8yyy.github.io/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">
                                <span class="chip bg-color">计算机网络</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" class="post-category">
                                计算机基础
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2022-08-16
                </div>
                

                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    15k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    53 分
                </div>
                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/8yyy/8yyy.github.io/libs/prism/prism.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <p><u><font color="red">目标： </font></u></p>
<ul>
<li>理解传输层的工作原理<ul>
<li>多路复用/解复用 </li>
<li>可靠数据传输</li>
<li>流量控制</li>
<li>拥塞控制 </li>
</ul>
</li>
<li>学习Internet的传输层协议 <ul>
<li>UDP：无连接传输 </li>
<li>TCP：面向连接的可靠传 输 </li>
<li><font color="red">TCP的拥塞控制</font></li>
</ul>
</li>
</ul>
<h2 id="1-概述和传输层服务"><a href="#1-概述和传输层服务" class="headerlink" title="1. 概述和传输层服务"></a>1. 概述和传输层服务</h2><p>传输服务和协议 </p>
<ul>
<li>运输层协议为运行在不同主机上的应用进程提供<font color="red">逻辑通信</font>(logic communication)功能<ul>
<li>从应用程序的角度看，通过逻辑通信，运行不同进程的主机好像直接相连一样</li>
<li><blockquote>
<p>应用程序使用运输层提供的逻辑通信功能彼此发送报文，而无须考虑承载这些报文的物理设施节点的细节</p>
</blockquote>
</li>
</ul>
</li>
<li>传输协议运行在<strong>端系统</strong> <ul>
<li>发送方：将应用层的报文分成<font color="red">报文段</font>(segment)，然后传递给网络层 </li>
<li>接收方：将报文段重组成报文，然后传递给应用层 </li>
</ul>
</li>
<li>有多个传输层协议可供应用选择 <ul>
<li><strong>Internet: TCP(字节流的服务，不保证界限) 和 UDP</strong></li>
</ul>
</li>
</ul>
<h3 id="1-1-传输层和网络层的关系"><a href="#1-1-传输层和网络层的关系" class="headerlink" title="1.1 传输层和网络层的关系"></a>1.1 传输层和网络层的关系</h3><ul>
<li><p><font color="blue">网络层服务：</font>主机之间的逻辑通信 </p>
</li>
<li><p><font color="blue">传输层服务：</font>主机上的进程间的逻辑通信 </p>
<ul>
<li>依赖于网络层的服务 <ul>
<li>延时、带宽 </li>
</ul>
</li>
<li>并对网络层的服务进行增强<ul>
<li>数据丢失、顺序混乱、 加密</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><font color="red">有些服务是可以加强的：不可靠 -&gt; 可靠；安全</font></p>
<p><font color="red">但有些服务是不可以被加强的：带宽，延迟</font></p>
<p><img src="/images/Computer-Network3/image-20230622092809104.png"></p>
<p>Ann和Bill负责收发邮件，不参与任何一个中间邮件中心的功能工作，类似的，传输层协议只工作在端系统中。</p>
<h3 id="1-2-Internet传输层协议"><a href="#1-2-Internet传输层协议" class="headerlink" title="1.2 Internet传输层协议"></a>1.2 Internet传输层协议</h3><p><font color="blue">可靠的、保序的传输： <strong>TCP</strong>(字节流的服务)</font></p>
<ul>
<li>多路复用、解复用</li>
<li>拥塞控制</li>
<li>流量控制</li>
<li>建立连接</li>
</ul>
<p><font color="blue">不可靠、不保序的传输：&lt;**UDP**(用户数据报协议)</font></p>
<ul>
<li>多路复用、解复用 </li>
<li>没有为尽力而为的IP服务添加更多的其它额外服务 </li>
</ul>
<p><strong>都不提供的服务： 延时保证    带宽保证</strong></p>
<blockquote>
<p>因特网文献（如RFC）经常将TCP的运输层分组称为报文段，而UDP的分组称为数据报，同时将网络层分组也称为数据报！</p>
</blockquote>
<p><font color="red">统一将TCP和UDP的分组统称为 <strong>报文段</strong>，而将 <strong>数据报</strong> 名称保留给网络层分组不容易混淆。</font></p>
<p><font color="blue">因特网网际协议IP：</font></p>
<ul>
<li>IP的服务模型是<strong>尽力而为交付服务</strong>（best-effort delivery service）</li>
<li>不可靠服务</li>
<li>每台主机至少有一个网络层地址——IP地址</li>
</ul>
<p><font color="blue">UDP和TCP所提供的服务模型：</font></p>
<ul>
<li><p>最基本的职责：将两个端系统间IP的交付服务扩展为运行在端系统上的两个进程之间的交付服务。</p>
<ul>
<li>运输层的多路复用</li>
<li>多路分解</li>
</ul>
</li>
<li><p>进程到进程的数据交付和差错检查是两种最低限度的运输层服务，也是UDP所能提供的仅有的两种服务。</p>
</li>
</ul>
<h2 id="2-多路复用与解复用"><a href="#2-多路复用与解复用" class="headerlink" title="2. 多路复用与解复用"></a>2. 多路复用与解复用</h2><p>多路复用/解复用（一个TCP/UDP实体上有很多应用进程借助其发送）</p>
<p><font color="red">在发送方主机<strong>多路复用</strong></font></p>
<ul>
<li>从多个套接字接收来自多个进程的报文，根据套接字对应的<font color="red">IP地址和端口号</font>等信息对报文段用头部加以封装 (该头部信息用于以后的<strong>解复用</strong>)</li>
</ul>
<p><font color="red">在接收方主机<strong>多路解复用</strong></font>(多路分解)</p>
<ul>
<li>根据报文段的头部信息中的<font color="red">IP地址和端口号</font>将接收到的报文段发给正确的套接字(和对应的应用进程)</li>
</ul>
<blockquote>
<p>在前面的家庭类比中，当Bill从邮递员收到一批信件，并通过收信人名称分发给他的兄弟姐妹时，他执行的就是一个<font color="red">多路分解</font>操作；当Ann从兄弟姐妹中收集邮件并将它们交给邮递员时，她执行的就是一个<font color="red">多路复用</font>操作。</p>
</blockquote>
<p>多路解复用工作原理</p>
<ul>
<li>解复用作用：TCP或者UDP实体采用哪些信息，将报文段的数据部分交给正确的socket，从而交给正确的进程</li>
<li>主机收到IP数据报 <ul>
<li>每IP数据报有<font color="red">源IP地址和目标IP地址</font></li>
<li>IP数据报承载一个传输层报文段，每个段有一个<font color="red">源端口号和目标端口号 </font>(特定应用有著名的端口号)</li>
</ul>
</li>
<li>主机联合使用<font color="red">IP地址</font>和<font color="red">端口号</font>将报文段发送给合适的套接字，交给相应的进程（线程）<ul>
<li>TCP使用4元组</li>
<li>UDP使用2元组（目标IP，目标Port）</li>
</ul>
</li>
</ul>
<h3 id="2-1-无连接-UDP-多路复用和多路分解"><a href="#2-1-无连接-UDP-多路复用和多路分解" class="headerlink" title="2.1 无连接(UDP)多路复用和多路分解"></a>2.1 无连接(UDP)多路复用和多路分解</h3><p><strong>创建套接字：</strong>（Python）</p>
<ul>
<li><font color="blue">服务器端：</font><font color="red">serverSocket=socket(PF_INET,SOCK_DGRAM,O);bind(serverSocket,&amp;sad,sizeof(sad));</font></li>
</ul>
<p>serverSocket和Sad指定的端口号捆绑</p>
<ul>
<li><p><font color="blue">客户端：</font></p>
<p><font color="red">clientSocket=socket(PF_INET,SOCK_DGRAM,0);</font></p>
</li>
</ul>
<blockquote>
<p>没有Bind，clientSocket和OS为之分配的某个端口号捆绑（客户端使用什么端口号无所谓，客户端主动找服务器）,即运输层从1024~65535（非周知）中自动为该套接字分配一个端口号，该端口号是当前未被该主机中任何其他UDP端口使用的号。</p>
</blockquote>
<blockquote>
<p>通常，应用程序的客户端让运输层自动地分配端口号，而服务器端则分配一个特定的端口号。</p>
</blockquote>
<p><u><font color="red">示例：</font></u>假定在主机A中的一个进程具有UDP端口19157，它要发送一个应用程序数据库给位于主机B的另一个进程，该进程具有UDP端口46428。</p>
<ol>
<li>主机A的运输层创建一个运输层报文段：应用程序数据、源端口号（19157）、目的端口号（46428）和两个其他值。</li>
<li>运输层将得到的报文段传到网络层。</li>
<li>网络层将该报文段封装到一个IP数据报中，并尽力而为地将报文段交付给接收主机。</li>
<li>如果该报文段到达接收主机B，接收主机运输层就检查该报文段中的目的端口号（46428），并将该报文段交付给端口号46428所标识的套接字。</li>
</ol>
<ul>
<li>在接收端，UDP套接字用二元组标识<font color="red">(目标IP地址、目标端口号)</font></li>
<li>当主机收到UDP报文段：<ul>
<li>检查报文段的目标端口号</li>
<li>用该端口号将报文段定位给套接字</li>
</ul>
</li>
<li>如果两个不同源IP地址/源端口号的数据报，但是<font color="red">有相同的目标IP地址和端口号</font>，则被定位到相同的套接字</li>
</ul>
<p><img src="/images/Computer-Network3/image-20230622162412620.png" alt="image-20230622162412620"></p>
<ul>
<li>回顾：创建拥有本地端口号的套接字：</li>
</ul>
<p>DatagramSocket mySocket1 = New DatagramSocket(12534)；</p>
<ul>
<li>回顾：当创建UDP段采用端口号，可以指定： <ul>
<li>目标IP地址 </li>
<li>目标端口号</li>
</ul>
</li>
<li>当主机接收到UDP段时： <ul>
<li>检查UDP段中的目标端口号 </li>
<li>将UDP段交给具备那个端口号的套接字</li>
</ul>
</li>
</ul>
<p>具备相同目标IP地址和目标端口号，即使是源IP地址或源端口号不同的IP数据报，将会被传到相同的目标UDP套接字上（目标IP地址，目标端口号一样发送给同一个进程）</p>
<p><img src="/images/Computer-Network3/image-20230622162849196.png" alt="image-20230622162849196"></p>
<p><img src="/images/Computer-Network3/image-20230622162906105.png" alt="image-20230622162906105"></p>
<h3 id="2-2-面向连接-TCP-的多路复用"><a href="#2-2-面向连接-TCP-的多路复用" class="headerlink" title="2.2 面向连接(TCP)的多路复用"></a>2.2 面向连接(TCP)的多路复用</h3><ul>
<li><p>TCP套接字:四元组本地标识： </p>
<ul>
<li>源IP地址 </li>
<li>源端口号 </li>
<li>目的IP地址 </li>
<li>目的端口号</li>
</ul>
</li>
<li><p><font color="red">解复用：</font>接收主机用这四个值来将数据报定位到合适的套接字</p>
</li>
<li><p>服务器能够在一个TCP端口上同时支持多个TCP套接字：</p>
<ul>
<li>每个套接字由其四元组标识（有不同的源IP和源PORT）</li>
</ul>
</li>
<li><p>Web服务器对每个连接客户端有不同的套接字</p>
<ul>
<li>非持久对每个请求有不同的套接字</li>
</ul>
</li>
</ul>
<p><img src="/images/Computer-Network3/image-20230622163146934.png" alt="image-20230622163146934"></p>
<p>尽管主机A和主机C向服务器B发送的报文段的目标IP地址和目标端口号一致，但是源IP地址或源端口号不一致，因此服务器B仍然能够正确地分解这几个具有相同源端口号的连接。</p>
<p><img src="/images/Computer-Network3/image-20230622163158005.png" alt="image-20230622163158005"></p>
<p><img src="/images/Computer-Network3/image-20230622163210503.png" alt="image-20230622163210503"></p>
<p><img src="/images/Computer-Network3/image-20230622163229815.png" alt="image-20230622163229815"></p>
<p>连接套接字与进程之间并非总是有着一一对应的关系。事实上，当今的高性能Web服务器通常只使用一个进程，但是为每个新的客户连接创建一个具有新连接套接字的新线程。（线程可被看作是一个轻量级的子线程）对于这样一台服务器，在任意给定的时间内都可能有（具有不同标识的）许多连接套接字连接到相同的进程。</p>
<p>UDP无非就是对网络层协议增加了一点多路复用/多路分解服务而已。</p>
<h2 id="3-无连接传输：UDP"><a href="#3-无连接传输：UDP" class="headerlink" title="3. 无连接传输：UDP"></a>3. 无连接传输：UDP</h2><p>UDP: User Datagram Protocol  用户数据报协议<br>在IP（主机到主机）所提供的基础上增加了一个多路复用/解复用（进程到进程）的服务</p>
<blockquote>
<p>运输层最低限度必须提供一种复用/分解服务，以便在网络层与正确的应用级进程之间传递数据。</p>
</blockquote>
<p><font color="red">由 RFC 768 定义的 UDP 只是做了运输协议能够做的最少工作。除了复用/分解功能及少量的差错检测外，它几乎没有对 IP 增加别的东西。</font></p>
<ul>
<li>“尽力而为”的服务，报文段可能 <ul>
<li>丢失 </li>
<li>送到应用进程的报文段乱序（延迟不一样）</li>
</ul>
</li>
<li><font color="red">无连接：</font><ul>
<li>UDP发送端和接收端之间没有握手 </li>
<li>每个UDP报文段都被独立地处理</li>
</ul>
</li>
<li>UDP 被用于: <ul>
<li>（实时）流媒体（丢失不敏感， 速率敏感、应用可控制 传输速率）</li>
<li>DNS</li>
<li>SNMP</li>
<li>事务性的应用(一次性往返搞定)</li>
</ul>
</li>
<li>在UDP上可行可靠传输：<ul>
<li><strong>在应用层增加可靠性</strong> </li>
<li><strong>应用特定的差错恢复</strong></li>
</ul>
</li>
</ul>
<h3 id="3-1-为什么要有UDP"><a href="#3-1-为什么要有UDP" class="headerlink" title="3.1 为什么要有UDP?"></a>3.1 为什么要有UDP?</h3><ul>
<li><p>不建立连接 (会增加延时) </p>
</li>
<li><p>简单：在发送端和接收端没有连接状态 </p>
<ul>
<li>不需要像TCP那样在端系统中维护连接状态</li>
</ul>
</li>
<li><p>报文段的头部很小(开销小)</p>
<ul>
<li>每个TCP报文段都有20字节的首部开销，而UDP仅有8字节的开销</li>
</ul>
</li>
<li><p>无拥塞控制和流量控制：UDP可以尽可能快的发送报文段</p>
<ul>
<li><strong>应用-&gt;传输的速率 = 主机-&gt;网络的速率 (忽略头部时)</strong></li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>使用 UDP 的应用是可能实现可靠数据传输的。</strong>这可通过在应用程序自身中建立可靠性机制来完成，例如谷歌浏览器所使用的QUIC协议在UDP之上的应用层协议中实现了可靠性。</p>
</blockquote>
<h3 id="3-2-UDP-报文段结构"><a href="#3-2-UDP-报文段结构" class="headerlink" title="3.2 UDP 报文段结构"></a>3.2 UDP 报文段结构</h3><p><img src="/images/Computer-Network3/image-20210725134800713.png" alt="image-20210725134800713"></p>
<p>UDP报文段如上图所示，它由 RFC 768 定义。应用程序数据占用UDP报文段的数据字段。</p>
<ul>
<li>例如，对于DNS应用，数据字段要么包含一个查询报文，要么包含一个响应报文</li>
<li>对于流式音频应用，音频抽样数据填充到数据字段。</li>
</ul>
<p>UDP首部只有<font color="red">4</font>个字段，每个字段由<font color="red">2</font>个字节组成：</p>
<ul>
<li>通过<strong>端口号</strong>可以使目的主机将应用程序数据交给运行在目的端系统的响应进行（即执行分解功能）</li>
<li><strong>长度</strong>字段指示了在UDP报文段中的字节数（首部+数据）</li>
<li>接收方通过<strong>检验和</strong>来检查在该报文段中是否出现了差错</li>
</ul>
<h3 id="3-3-UDP-检验和"><a href="#3-3-UDP-检验和" class="headerlink" title="3.3 UDP 检验和"></a>3.3 UDP 检验和</h3><p><u><font color="red">目标： 检测在被传输报文段中的差错 (如比特反转)</font></u></p>
<p><u><font color="red">发送方：</font></u> </p>
<ul>
<li>将报文段的内容视为16 比特的整数 </li>
<li>校验和：报文段的加法和的反码运算</li>
<li>发送方将校验和放在 UDP的校验和字段</li>
</ul>
<p><u><font color="red">接收方：</font></u> </p>
<ul>
<li>计算接收到的报文段的校验和 </li>
<li>检查计算出的校验和与校验和字段的内容是否相等：<ul>
<li>不相等––检测到差错 </li>
<li><strong>相等––没有检测到差错 ，但也许还是有差错 (残存错误，未检测出来)</strong></li>
</ul>
</li>
</ul>
<h3 id="Internet校验和的例子"><a href="#Internet校验和的例子" class="headerlink" title="Internet校验和的例子"></a>Internet校验和的例子</h3><p>注意：当数字相加时，在最高位的进位要回卷（加到最低位上），再加到结果上</p>
<p><img src="/images/Computer-Network3/image-20210725135335276.png" alt="image-20210725135335276"></p>
<ul>
<li><strong>目标端：校验范围+校验和=1111111111111111 通过校验</strong> <ul>
<li>否则没有通过校验 </li>
</ul>
</li>
<li>注：求和时，必须将进位回卷到结果上</li>
</ul>
<h2 id="4-可靠数据传输的原理"><a href="#4-可靠数据传输的原理" class="headerlink" title="4. 可靠数据传输的原理"></a>4. 可靠数据传输的原理</h2><ul>
<li>rdt在应用层、传输层和数据链路层都很重要</li>
<li>是网络Top 10问题之一，榜首的候选者</li>
<li><font color="red">为上层实体提供的服务抽象是：</font>数据通过一条可靠的信道进行传输<ul>
<li>借助于可靠信道，传输数据比特就不会收到损坏（由0变为1，或者相反）或丢失</li>
<li>所有数据都是按照其发送顺寻进行交付</li>
<li>这恰好是TCP向调用它的因特网应用所提供的服务模型</li>
</ul>
</li>
</ul>
<p><img src="/images/Computer-Network3/image-20230624142354098.png" alt="可靠数据传输：服务模型和服务实现"></p>
<ul>
<li>实现这种服务抽象是可靠传输数协议（reliable data transfer protocol）的责任</li>
<li>信道的不可靠特点决定了可靠数据传输协议（ rdt ）的复杂性<ul>
<li>可靠数据传输协议的<strong>下层协议</strong>也许是不可靠的</li>
<li>例如<strong>TCP</strong>是不可靠的<strong>IP</strong>端到端网络层之上实现的可靠数据传输协议</li>
</ul>
</li>
</ul>
<p><img src="/images/Computer-Network3/image-20230624140559067.png"></p>
<ul>
<li>使用<font color="red">“分组”</font>，而不使用运输层的<font color="red">“报文段”</font>，是因为可靠数据传输的理论适用于更一般的计算机网络，而不只是用于运输层</li>
<li>渐增式地开发可靠数据传输协议（ rdt ）的发送方和接收方</li>
<li>只考虑单向数据传输（unidirectional data transfer）<ul>
<li> 但控制信息是双向（bidirectional）流动的！</li>
</ul>
</li>
<li><strong>双向的数据传输问题实际上是2个单向数据传输问题的综合</strong> </li>
</ul>
<h3 id="4-1-构造可靠数据传输协议"><a href="#4-1-构造可靠数据传输协议" class="headerlink" title="4.1 构造可靠数据传输协议"></a>4.1 构造可靠数据传输协议</h3><h4 id="4-1-1-经完全可靠信道上的可靠数据传输：rdt1-0"><a href="#4-1-1-经完全可靠信道上的可靠数据传输：rdt1-0" class="headerlink" title="4.1.1 经完全可靠信道上的可靠数据传输：rdt1.0"></a>4.1.1 经完全可靠信道上的可靠数据传输：rdt1.0</h4><ul>
<li>使用<strong>有限状态机 (FSM)</strong> 来描述发送方和接收方</li>
</ul>
<p><img src="/images/Computer-Network3/image-20230624140657161.png" alt="image-20230624140657161"></p>
<p><strong>下层的信道是完全可靠的</strong> </p>
<ul>
<li>没有比特出错 </li>
<li>没有分组丢失 </li>
</ul>
<p>发送方和接收方的FSM </p>
<ul>
<li>发送方将数据发送到下层信道 </li>
<li>接收方从下层信道接收数据</li>
</ul>
<p><img src="/images/Computer-Network3/image-20230624140743260.png"></p>
<p>可以看到每一个FSM都只有一个状态。</p>
<p>发送方：接收–封装–打走       </p>
<p>接收方：解封装–交付          什么都不用干      </p>
<h4 id="4-1-2-经具有比特差错信道的可靠数据传输：rdt2-0"><a href="#4-1-2-经具有比特差错信道的可靠数据传输：rdt2-0" class="headerlink" title="4.1.2 经具有比特差错信道的可靠数据传输：rdt2.0"></a>4.1.2 经具有比特差错信道的可靠数据传输：rdt2.0</h4><p>下层信道可能会出错：将分组中的比特翻转</p>
<ul>
<li>用校验和来检测比特差错</li>
</ul>
<p>问题：怎样从差错中恢复：</p>
<ul>
<li><font color="red">确认(ACK)：</font>接收方显式地告诉发送方分组已被正确接收</li>
<li><font color="red">否定确认(NAK)：</font>接收方显式地告诉发送方分组发生了差错<ul>
<li>发送方收到NAK后，发送方重传分组</li>
</ul>
</li>
</ul>
<p>在计算机网络环境中，基于这样重传机制的可靠数据传输协议称为<font color="red">自动重传请求（Automatic Repeat reQuest，ARQ）协议。</font></p>
<p>ARQ协议需要另外三种协议功能来处理存在比特差错的情况：</p>
<ul>
<li>差错检测</li>
<li>接收方反馈</li>
<li>重传</li>
</ul>
<p>rdt2.0中的新机制：采用差错控制编码进行差错检测</p>
<ul>
<li>发送方差错控制编码、缓存 </li>
<li>接收方使用编码检错 </li>
<li>接收方的反馈：控制报文（ACK，NAK）：接收方-&gt;发送方 </li>
<li>发送方收到反馈相应的动作</li>
</ul>
<h4 id="Rdt2-0：FSM描述"><a href="#Rdt2-0：FSM描述" class="headerlink" title="Rdt2.0：FSM描述"></a>Rdt2.0：FSM描述</h4><p><img src="/images/Computer-Network3/image-20230624141001637.png" alt="image-20230624141001637"></p>
<p>发送方接收nak (接收方检测出错) ，将之前封装的package重传，直到收到ack才开始下一轮的发送</p>
<p>rdt2.0：没有差错时的操作</p>
<p><img src="/images/Computer-Network3/image-20230624141038029.png"></p>
<p>rdt2.0：有差错时</p>
<p><img src="/images/Computer-Network3/image-20230624141058767.png" alt="image-20230624141058767"></p>
<h4 id="4-1-3-rdt2-0的致命缺陷！-gt-rdt2-1"><a href="#4-1-3-rdt2-0的致命缺陷！-gt-rdt2-1" class="headerlink" title="4.1.3 rdt2.0的致命缺陷！-&gt; rdt2.1"></a>4.1.3 rdt2.0的致命缺陷！-&gt; rdt2.1</h4><p><font color="red">致命缺陷：如果ACK/NAK出错？ </font></p>
<ul>
<li>发送方不知道接收方发生了什么事情！ </li>
<li>发送方如何做？ <ul>
<li>重传？可能重复 </li>
<li>不重传？可能死锁(或出错) </li>
</ul>
</li>
<li>需要引入新的机制 <ul>
<li>在数据分组中添加一字段，让发送方对其数据分组编号，即将发送数据分组的<strong>序号</strong>（sequence number）放在该字段。</li>
</ul>
</li>
</ul>
<p><font color="red">处理重复：</font> </p>
<ul>
<li>发送方在每个分组中加入<font color="blue">序号</font></li>
<li>如果<strong>ACK/NAK</strong>出错，发送方<font color="red">重传</font>当前分组 </li>
<li><strong><u>接收方丢弃（不发给上层）重复分组</u></strong> </li>
</ul>
<p>​    <strong>接收方通过序号判断，是否重复接收同样的包，在进行下一次流程/发送ack</strong></p>
<blockquote>
<p><font color="red">停等协议：</font>发送方发送一个分组， 然后等待接收方的应答 </p>
</blockquote>
<p><img src="/images/Computer-Network3/image-20230624141430798.png" alt="image-20230624141430798"></p>
<p><img src="/images/Computer-Network3/image-20230624141440162.png" alt="image-20230624141440162"></p>
<p><FONT color="RED">发送方： </FONT></p>
<ul>
<li>在分组中加入序列号</li>
<li>两个序列号（0，1）就足够了<ul>
<li>一次只发送一个未经确认的分组</li>
</ul>
</li>
<li>必须检测ACK/NAK是否出错（需要EDC ）</li>
<li>状态数变成了两倍 <ul>
<li>必须记住当前分组的序列号为0还是1</li>
</ul>
</li>
</ul>
<p><FONT color="RED">接收方： </FONT></p>
<ul>
<li>必须检测接收到的分组是否是重复的<ul>
<li>状态会指示希望接收到的分组的序号为0还是1 </li>
</ul>
</li>
<li>注意：接收方并不知道 发送方是否正确收到了 其ACK/NAK<ul>
<li>没有安排确认的确认</li>
</ul>
</li>
</ul>
<p><strong>rdt2.1的运行</strong></p>
<p><img src="/images/Computer-Network3/image-20210725154944808.png" alt="image-20210725154944808"></p>
<p>接收方不知道它最后发送的ACK/NAK是否被正确地收到</p>
<ul>
<li>发送方不对收到的ack/nak给确认，<font color="red">没有所谓的确认的确认；</font></li>
<li>接收方发送ack，如果后面接收方收到的是：<ul>
<li>老分组p0？则之前的ack 错误 </li>
<li>下一个分组？P1，之前的ack正确</li>
</ul>
</li>
</ul>
<h4 id="4-1-4-有比特差错信道实现的无NAK的协议：rdt2-2"><a href="#4-1-4-有比特差错信道实现的无NAK的协议：rdt2-2" class="headerlink" title="4.1.4 有比特差错信道实现的无NAK的协议：rdt2.2"></a>4.1.4 有比特差错信道实现的无NAK的协议：rdt2.2</h4><ul>
<li>功能同rdt2.1，但只使用ACK(ack 要编号） </li>
<li>接收方对最后正确接收的分组发ACK，以替代NAK <ul>
<li>接收方必须显式地包含被正确接收分组的序号 </li>
</ul>
</li>
<li><strong>当收到重复的ACK（如：再次收到ack0）时，发送方与收到NAK采取相同的动作：重传当前分组</strong> </li>
<li>为后面的一次发送多个数据单位做一个准备 <ul>
<li>一次能够发送多个 </li>
<li>每一个的应答都有：ACK，NACK；麻烦 </li>
<li>使用对前一个数据单位的ACK，代替本数据单位的nak </li>
<li>确认信息减少一半，协议处理简单</li>
</ul>
</li>
</ul>
<p>NAK free </p>
<p><img src="/images/Computer-Network3/image-20210725155525434.png" alt="image-20210725155525434"></p>
<p><strong>rdt2.2的运行</strong></p>
<p><img src="/images/Computer-Network3/image-20210725155546252.png" alt="image-20210725155546252"></p>
<p><img src="/images/Computer-Network3/image-20210725155624953.png" alt="image-20210725155624953"></p>
<p>1、No error        2、packet error        3、ack error</p>
<p><img src="/images/Computer-Network3/image-20230624170128991.png" alt="image-20230624170128991"></p>
<h4 id="4-1-5-rdt3-0：具有比特差错和分组丢失的信道"><a href="#4-1-5-rdt3-0：具有比特差错和分组丢失的信道" class="headerlink" title="4.1.5 rdt3.0：具有比特差错和分组丢失的信道"></a>4.1.5 rdt3.0：具有比特差错和分组丢失的信道</h4><p><font color="red">新的假设：</font>下层信道可能会丢失分组（数据或ACK）</p>
<ul>
<li>会死锁 </li>
<li>机制还不够处理这种状况： <ul>
<li>检验和 </li>
<li>序列号</li>
<li>ACK </li>
<li>重传</li>
</ul>
</li>
</ul>
<p><font color="red">方法：</font>发送方等待ACK一段<font color="red">合理的时间</font> </p>
<ul>
<li><p>发送端<strong>超时重传</strong>：如果到时没有收到ACK-&gt;重传 </p>
</li>
<li><p>问题：如果分组（或ACK ）只是被延迟了： </p>
<ul>
<li>重传将会导致数据重复，但利用序列号已经可以处理这个问题 </li>
<li> 接收方必须指明被正确接收的序列号 </li>
</ul>
</li>
<li><p>需要一个倒计数定时器（countdown timer）：在一个给定的时间量过期后，可中断发送方</p>
<ul>
<li>每次发送一个分组（包括第一次分组和重传分组）时，便启动一个定时器</li>
<li>响应定时器中断（采取适当的动作）</li>
<li>终止定时器</li>
</ul>
</li>
</ul>
<p><font color="blue">链路层的timeout时间确定的  （比较集中）</font><br><font color="blue">传输层timeout时间是适应式的 （不太集中）</font></p>
<p><img src="/images/Computer-Network3/image-20230624170342026.png" alt="image-20230624170342026"></p>
<p><strong>rdt3.0的运行</strong></p>
<p><img src="/images/Computer-Network3/image-20210725161318287.png" alt="image-20210725161318287"></p>
<p><img src="/images/Computer-Network3/image-20230625092736031.png" alt="image-20230625092736031"></p>
<p><img src="/images/Computer-Network3/image-20230624170356297.png" alt="image-20230624170356297"></p>
<p><img src="/images/Computer-Network3/image-20230625092750509.png" alt="image-20230625092750509"></p>
<p>因此分组序号在0和1之间交替，因此rdt3.0有时也被称为<font color="red">比特交替协议</font>（alternating-bit protocol）。</p>
<p><strong>rdt3.0的性能</strong></p>
<p><font color="red">rdt3.0可以工作，但链路容量比较大的情况下，性能很差</font></p>
<ul>
<li>链路容量比较大，一次发一个PDU 的不能够充分利用链路的传输能力</li>
</ul>
<p><img src="/images/Computer-Network3/image-20210725171743570.png" alt="image-20210725171743570"></p>
<ul>
<li>U<sub>sender</sub>：<font color="red">利用率</font> – 忙于发送的时间比例 </li>
<li>每30ms发送1KB的分组 -&gt; 270kbps=33.75kB/s 的吞吐量（在1 Gbps 链路上） </li>
<li><font color="red">瓶颈</font>在于：<font color="blue"><strong>网络协议限制了物理资源的利用！</strong></font></li>
</ul>
<p><strong>rdt3.0：停-等操作  stop-wait</strong></p>
<p><img src="/images/Computer-Network3/image-20230624170530829.png" alt="image-20230624170530829"></p>
<p><strong>一次收发一个</strong>，可以看到停等协议有着非常低的发送方利用率，发送方只有万分之2.7时间是忙的。</p>
<h3 id="4-2-流水线：提高链路利用率"><a href="#4-2-流水线：提高链路利用率" class="headerlink" title="4.2 流水线：提高链路利用率"></a>4.2 流水线：提高链路利用率</h3><p>rdt3.0是一个<font color="red">功能正确</font>的协议，但并非人人对它的<font color="red">性能</font>满意。<strong>rdt3.0性能问题的核心在于它是一个<font color="red">停等协议。</font></strong></p>
<p><img src="/images/Computer-Network3/image-20210725175741034.png" alt="image-20210725175741034"></p>
<ul>
<li>增加n，能提高链路利用率</li>
<li>但当达到某个n，其u=100%时,无法再通过增加n，提高利用率 </li>
<li>瓶颈转移了-&gt;链路带宽</li>
</ul>
<p><strong>流水线协议/管道化协议</strong></p>
<p><font color="red">流水线(pipelining)：</font>允许发送方在<font color="red">未得到对方确认</font>的情况下一次发送多个分组 </p>
<ul>
<li><p>必须增加序号的范围：用多个bit表示分组的序号 </p>
</li>
<li><p>在发送方/接收方要有缓冲区</p>
<ul>
<li>发送方缓冲：<strong>未得到确认</strong>，可能需要重传； </li>
<li>接收方缓存：上层用户取用数据的速率≠接收到的数据速率；接收到的数据可能乱序，排序交付（可靠）</li>
</ul>
</li>
<li><p>两种通用的流水线协议：<font color="red">回退N步(GBN)</font>和<font color="red">选择重传(SR)</font></p>
</li>
</ul>
<h3 id="4-3-通用：滑动窗口协议"><a href="#4-3-通用：滑动窗口协议" class="headerlink" title="4.3 通用：滑动窗口协议"></a>4.3 通用：滑动窗口协议</h3><h4 id="回退N步（GBN）"><a href="#回退N步（GBN）" class="headerlink" title="回退N步（GBN）"></a>回退N步（GBN）</h4><p>在GBN协议中，允许发送方发送多个分组（当有多个分组可用时）而不需等待确认，但它也受限于在流水线中未确认的分组数不能超过某个最大允许数N。</p>
<p><img src="/images/Computer-Network3/image-20230625095941938.png" alt="在GBN中发送方看到的序号"></p>
<p>我们将基序号（base）定义为最早未确认分组的序号，将下一个序号（nextseqnum）定义未最小的未使用序号（即下一个待发送分组的序号）：</p>
<ul>
<li>在[ 0 , base-1 ]段内的序号对应于<font color="red">已经发送并被确认</font>的分组</li>
<li>在[ base , nextseqnum-1 ]段内对应<font color="red">已经发送但未被确认</font>的分组</li>
<li>在[ nextseqnum , base+N-1 ]段内的序号能用于那些<font color="red">要被立即发送</font>的分组，如果有数据来自上层的话</li>
<li>大于base+N的序号是不能使用的，直到当前流水线中<font color="red">未被确认的分组（特别是base分组）已得到确认</font>为止</li>
</ul>
<p>那些已被发送但还未被确认的分组的许可号范围可用被看成是一个在序号范围内长度未N的窗口。随着协议的运行，该窗口在序号空间向滑动。因此，N常被称为<font color="red">窗口长度</font>（window size），GBN协议也常被称为<font color="red">窗口滑动协议</font>（sliding-window protocol）。</p>
<blockquote>
<p>为什么要限制分组的数目？将在流量控制和拥塞控制中分析原因。</p>
</blockquote>
<p><strong>发送缓冲区</strong></p>
<ul>
<li><strong>形式：内存中的一个区域，<u>落入缓冲区的分组可以发送</u></strong> </li>
<li><strong>功能：用于存放已发送，但是没有得到确认的分组</strong> </li>
<li><strong>必要性：需要重发时可用</strong> </li>
</ul>
<p>发送缓冲区的大小：一次最多可以发送多少个未经确认的分组 </p>
<ul>
<li>停止等待协议=1</li>
<li>流水线协议&gt;1，合理的值，不能很大，链路利用率不能够超100% </li>
</ul>
<p><strong>发送缓冲区中的分组</strong> </p>
<ul>
<li><font color="red">未发送的：</font>落入发送缓冲区的分组，可以连续发送出去； </li>
<li><font color="red">已经发送出去的、等待对方确认的分组：</font>发送缓冲区的分组只有得到确认才能删除</li>
</ul>
<p>发送窗口滑动过程-相对表示方法</p>
<ul>
<li>采用相对移动方式表示，分组不动</li>
<li>可缓冲范围移动，代表一段可以发送的权力</li>
</ul>
<p><img src="/images/Computer-Network3/image-20230624170951209.png" alt="image-20230624170951209"></p>
<p><img src="/images/Computer-Network3/image-20230625170435273.png" alt="image-20230625170435273"></p>
<ul>
<li><p>发送窗口：发送缓冲区内容的一个范围</p>
<ul>
<li>那些已发送但是未经确认分组的序号构成的空间 </li>
</ul>
</li>
<li><p>发送窗口的最大值&lt;=发送缓冲区的值 </p>
</li>
<li><p>一开始：没有发送任何一个分组 </p>
<ul>
<li>后沿=前沿 </li>
<li>之间为发送窗口的尺寸=0 </li>
</ul>
</li>
<li><p>每发送一个分组，前沿前移一个单位</p>
</li>
</ul>
<p><img src="/images/Computer-Network3/image-20210725180820132.png" alt="image-20210725180820132"></p>
<ul>
<li>发送窗口前沿移动的极限：不能够超过<strong>发送缓冲区的大小</strong></li>
</ul>
<p><img src="/images/Computer-Network3/image-20230624171107501.png" alt="image-20230624171107501"></p>
<p><img src="/images/Computer-Network3/image-20230625170251430.png" alt="image-20230625170251430"></p>
<ul>
<li>发送窗口后沿移动<ul>
<li>条件：收到老分组的确认</li>
<li>结果：发送缓冲区罩住新的分组，来了分组可以发送</li>
<li> 移动的极限：不能够超过前沿</li>
</ul>
</li>
</ul>
<p><img src="/images/Computer-Network3/image-20230624171236036.png" alt="image-20230624171236036"></p>
<p><img src="/images/Computer-Network3/image-20230624171253263.png" alt="image-20230624171253263"></p>
<p><img src="/images/Computer-Network3/image-20210725181322552.png" alt="image-20210725181322552"></p>
<p>接收窗口 (receiving window)=接收缓冲区 </p>
<ul>
<li>接收窗口用于控制哪些分组可以接收；<ul>
<li>只有收到的分组序号落入接收窗口内才允许接收</li>
<li>若序号在接收窗口之外，则丢弃；</li>
</ul>
</li>
<li><strong>接收窗口尺寸Wr=1，则只能顺序接收；</strong></li>
<li><strong>接收窗口尺寸Wr&gt;1 ，则可以乱序接收</strong><ul>
<li>但提交给上层的分组，要按序</li>
</ul>
</li>
</ul>
<p>例子：Wr＝1，在0的位置；只有0号分组可以接收；向前滑动一个，罩在1的位置，如果来了第2号分组，则丢弃。</p>
<p>接收窗口的滑动和发送确认 </p>
<ul>
<li>滑动： <ul>
<li>低序号的分组到来，接收窗口移动； </li>
<li>高序号分组乱序到，缓存但不交付（因为要实现rdt，不允许失序），不滑动 </li>
</ul>
</li>
<li>发送确认： <ul>
<li><strong>接收窗口尺寸=1 ； 发送连续收到的最大的分组确认（累计确认）</strong> </li>
<li><strong>接收窗口尺寸&gt;1 ； 收到分组，发送那个分组的确认（非累计确认）</strong></li>
</ul>
</li>
</ul>
<p><img src="/images/Computer-Network3/image-20210725184310106.png" alt="image-20210725184310106"></p>
<h4 id="正常情况下的2个窗口互动"><a href="#正常情况下的2个窗口互动" class="headerlink" title="正常情况下的2个窗口互动"></a>正常情况下的2个窗口互动</h4><p><img src="/images/Computer-Network3/image-20210725184748257.png" alt="image-20210725184748257"></p>
<h4 id="异常情况下GBN的2窗口互动"><a href="#异常情况下GBN的2窗口互动" class="headerlink" title="异常情况下GBN的2窗口互动"></a>异常情况下GBN的2窗口互动</h4><p>发送窗口</p>
<ul>
<li><p>新分组落入发送缓冲区范围，发送-&gt;前沿滑动</p>
</li>
<li><p><strong>超时重发机制让发送端将发送窗口中的所有分组发送出去</strong></p>
</li>
<li><p>来了老分组的重复确认-&gt;后沿不向前滑动-&gt;新的分组无法落入发送缓冲区的范围团(此时如果发送缓冲区有新的分组可以发送)</p>
</li>
</ul>
<p>接收窗口</p>
<ul>
<li>收到乱序分组，没有落入到接收窗口范界内，抛弃</li>
<li>(重复）发送老分组的确认，<strong>累计确认</strong></li>
</ul>
<h4 id="异常情况下SR的2窗口互动"><a href="#异常情况下SR的2窗口互动" class="headerlink" title="异常情况下SR的2窗口互动"></a>异常情况下SR的2窗口互动</h4><p>发送窗口</p>
<ul>
<li>新分组落入发送缓冲区范围，发送-&gt;前沿滑动</li>
<li><strong>超时重发机制让发送端将超对的分组重新发送出去</strong></li>
<li>来了乱序分组的确认-&gt;后沿不向前滑动-&gt;新的分组无法落入发送缓冲区的范围（此时如果发送缓冲率有新的分组可以发送)</li>
</ul>
<p>接收窗口</p>
<ul>
<li>收到乱序分组，落入到接收窗口范围内，接收</li>
<li>发送该分组的确认，<strong>单独确认</strong></li>
</ul>
<h4 id="GBN协议和SR协议的异同"><a href="#GBN协议和SR协议的异同" class="headerlink" title="GBN协议和SR协议的异同"></a>GBN协议和SR协议的异同</h4><p><font color="red">相同之处</font>    </p>
<ul>
<li>发送窗口&gt;1     </li>
<li>一次能够可发送多个 未经确认的分组</li>
</ul>
<p><font color="red">不同之处</font></p>
<p>GBN :接收窗口尺寸=1 </p>
<ul>
<li><strong>接收端：只能顺序接收</strong> </li>
<li><strong>发送端：从表现来看，一旦一个 分组没有发成功，如：0,1,2,3,4 ; 假如1未成功，234都发送出去 了，<font color="red">要返回1再发送；GB1</font>(go back 1)</strong> </li>
</ul>
<p>SR: 接收窗口尺寸&gt;1 </p>
<ul>
<li><strong>接收端：可以乱序接收</strong> </li>
<li><strong>发送端：发送0,1,2,3,4，一旦1 未成功，2,3,4,已发送，无需重发，<font color="red">选择性发送1</font></strong></li>
</ul>
<p><font color="red"><strong>Go-back-N:</strong> </font></p>
<ul>
<li>发送端最多在流水线中有N个未确认的分组</li>
<li><strong>接收端只是发送<u>累计型确认</u>(<font color="red">cumulative ack</font>)</strong> <ul>
<li>接收端如果发现gap，不确认新到来的分组</li>
</ul>
</li>
<li>发送端拥有对最老的未确认分组的定时器<ul>
<li> 只需设置<font color="red">一个定时器</font></li>
<li> 当定时器到时时，<font color="red">重传所有未确认分组</font></li>
</ul>
</li>
</ul>
<p><font color="red"><strong>Selective Repeat:</strong> </font></p>
<ul>
<li>发送端最多在流水线中有N个未确认的分组</li>
<li>接收方对每个到来的分组单独确认<font color="red">individual ack （非累计确认）</font></li>
<li>发送方为每个<font color="red">未确认的分组保持一个定时器</font><ul>
<li>当超时定时器到时，只是重发到时的未确认分组</li>
</ul>
</li>
</ul>
<p><img src="/images/Computer-Network3/image-20230624194426183.png" alt="image-20230624194426183"></p>
<p><img src="/images/Computer-Network3/image-20230624194455561.png" alt="image-20230624194455561"></p>
<ul>
<li>只发送ACK：对顺序接收的最高序号的分组<ul>
<li>可能会产生重复的ACK</li>
<li>只需记住expectedseqnum；接收窗口=1<ul>
<li><strong>只一个变量就可以表示接收窗口</strong></li>
</ul>
</li>
</ul>
</li>
<li>对乱序的分组：<ul>
<li>丢弃（不缓存）-&gt; <font color="red">在接收方不被缓存！</font></li>
<li>对顺序接收的最高序号的分组进行确认-累计确认</li>
</ul>
</li>
</ul>
<h4 id="运行中的GBN"><a href="#运行中的GBN" class="headerlink" title="运行中的GBN"></a>运行中的GBN</h4><p><img src="/images/Computer-Network3/image-20210725191547108.png" alt="image-20210725191547108"></p>
<p><img src="/images/Computer-Network3/image-20230625105047259.png" alt="运行中的GBN"></p>
<h4 id="选择重传SR"><a href="#选择重传SR" class="headerlink" title="选择重传SR"></a>选择重传SR</h4><p><font color="red">GBN协议存在着性能问题：单个分组的差错就能引起重传大量分组。</font></p>
<p><font color="blue">选择重传（SR）协议通过让发送方<strong>仅重传那些它怀疑在接收方出错（即丢失或受损）的分组</strong>而避免了不必要的重传。</font></p>
<ul>
<li><p>接收方对每个正确接收的分组，分别发送<strong>ACKn</strong>（非累积确认）</p>
<ul>
<li>接收窗口&gt;1<ul>
<li>可以缓存乱序的分组</li>
</ul>
</li>
<li>最终将分组按顺序交付给上层</li>
</ul>
</li>
<li><p>发送方只对那些没有收到<strong>ACK</strong>的分组进行重发-选择性重发</p>
<ul>
<li>发送方为每个未确认的分组设定一个定时器</li>
</ul>
</li>
<li><p>发送窗口的最大值（发送缓冲区）限制发送未确认分组的个数</p>
</li>
</ul>
<p><font color="blue">发送方</font></p>
<p><font color="red">从上层接收数据： </font></p>
<p>如果下一个可用于该分组的序号可在发送窗口中，则发送<br><font color="red">超时 timeout(n)：</font> </p>
<ul>
<li>重新发送分组<strong>n</strong>，重新设定定时器</li>
</ul>
<p><font color="red">ACK(n)</font> in [sendbase,sendbase+N]: </p>
<ul>
<li>将分组<strong>n</strong>标记为已接收</li>
<li>如<strong>n</strong>为最小未确认的分组序号， 将<strong>base</strong>移到下一个未确认序号</li>
</ul>
<p><font color="blue">接收方</font></p>
<p><font color="red">分组n</font> [rcvbase, rcvbase+N-1] </p>
<ul>
<li>发送<strong>ACK(n)</strong></li>
<li>乱序：缓存 </li>
<li>有序：该分组及以前缓存的序号连续的分组交付给上层 ，然后将窗口移到下一个仍未被接收的分组</li>
</ul>
<p><font color="red">分组n</font> [rcvbase-N, rcvbase-1] </p>
<ul>
<li>ACK(n)</li>
</ul>
<p><font color="red">其它：</font> </p>
<ul>
<li>忽略该分组</li>
</ul>
<p><img src="/images/Computer-Network3/image-20210725191937619.png" alt="image-20210725191937619"></p>
<p><img src="/images/Computer-Network3/image-20230625110353723.png" alt="SR操作"></p>
<h4 id="发送方和接收方窗口间缺乏同步产生的后果"><a href="#发送方和接收方窗口间缺乏同步产生的后果" class="headerlink" title="发送方和接收方窗口间缺乏同步产生的后果"></a>发送方和接收方窗口间缺乏同步产生的后果</h4><p><img src="/images/Computer-Network3/image-20230625141829927.png" alt="image-20230625141829927"></p>
<p>a）种情况下，前3个分组的ACK丢失，因此发送方重传这些分组。</p>
<p><img src="/images/Computer-Network3/image-20230625141841283.png" alt="image-20230625141841283"></p>
<p>b）种情况下，前3个分组的ACK都被正确交付。因此发送方向前移动窗口并发送第4、5、6个分组，其序号分别为3、0、1。序号为3的分组丢失，但序号为0的分组到达（一个新分组）。</p>
<p><font color="red">SR窗口接收方太大的困境：是一个新分组还是一次重传</font></p>
<p><font color="blue">作为接收方<strong>没办法区分是重传还是初次传输</strong>，显然<strong>窗口长度</strong>和<strong>序号空间</strong>的关系是值得商榷的</font></p>
<h4 id="对比GBN和SR"><a href="#对比GBN和SR" class="headerlink" title="对比GBN和SR"></a>对比GBN和SR</h4><table>
<thead>
<tr>
<th></th>
<th>GBN</th>
<th>SR</th>
</tr>
</thead>
<tbody><tr>
<td>优点</td>
<td>简单，所需资源少（接收方一个缓存单元）</td>
<td>出错时，重传一个代价小</td>
</tr>
<tr>
<td>缺点</td>
<td>一旦出错，回退N步代价大</td>
<td>复杂，所需要资源多（接收方多个缓存单元）</td>
</tr>
</tbody></table>
<ul>
<li><p>GBN只有在窗口内的所有分组都被确认后才滑动窗口。</p>
</li>
<li><p>SR在窗口内的第一个分组被确认后就滑动窗口，并且可以跳过一些还没有被确认的分组。</p>
</li>
</ul>
<p><strong>适用范围</strong> </p>
<ul>
<li>出错率低：比较适合GBN，出错非常罕见，没有必要用复杂的SR，为罕见的事件做日常的准备和复杂处理 </li>
<li>链路容量大<strong>（延迟大、带宽大）</strong>：比较适合SR而不 是GBN，一点出错代价太大</li>
</ul>
<h4 id="窗口的最大尺寸"><a href="#窗口的最大尺寸" class="headerlink" title="窗口的最大尺寸"></a>窗口的最大尺寸</h4><ul>
<li>GBN: 2<sup>n</sup> -1</li>
<li>SR:2<sup>n-1</sup> </li>
<li>例如：n=2; 序列号：0, 1, 2, 3 <ul>
<li>GBN =3</li>
<li>SR=2</li>
</ul>
</li>
<li>SR的例子： <ul>
<li>接收方看不到二者的区别！ </li>
<li>将重复数据误认为新数据 (a) </li>
</ul>
</li>
</ul>
<p>Q: 序号大小与窗口大小之间的关系？</p>
<p><font color="red">窗口长度必须小于或等于序列空间大小的一半</font></p>
<h3 id="4-4-可靠传输机制及其用途的总结"><a href="#4-4-可靠传输机制及其用途的总结" class="headerlink" title="4.4 可靠传输机制及其用途的总结"></a>4.4 可靠传输机制及其用途的总结</h3><table>
<thead>
<tr>
<th><center>机制</center></th>
<th><center>用途和说明</center></th>
</tr>
</thead>
<tbody><tr>
<td><div style="width: 80pt">检验和</div></td>
<td>用于监测在一个传输分组中的比特错误</td>
</tr>
<tr>
<td><center>定时器</center></td>
<td>用于超时/重传一个分组，可能因为该分组（或其ACK）在信道中丢失了。由于当一个分组延时但未丢失，或当一个分组已被接收方接收但从接收方到发送方的ACK丢失时,可能产生超时事件，所以接收方可能会收到一个分组的多个冗余副本</td>
</tr>
<tr>
<td><center>序号</center></td>
<td>用于为从发送方流向接收方的数据分组按序号编号。所接受分组的序号的空隙可是的接收方检测除丢失的分组。具有相同序号的分组可使接收方检测出一个分组的冗余副本</td>
</tr>
<tr>
<td><center>肯定确认</center></td>
<td>接收方用于告诉发送方一个分组或一组分组已经被正确地接收到了。确认报文通常携带着被确认的分组或多个分组的序号。确认可以是逐个的或积累的，这取决于协议</td>
</tr>
<tr>
<td><center>否定确认</center></td>
<td>接收方用于告诉发送方某个分组未被正确的接收。否则人确定报文通常携带着未被正确接收的分组的序号</td>
</tr>
<tr>
<td><center>窗口、流水线</center></td>
<td>发送方也许被限制仅发送那些序号落在一个指定范围内的分组。通过允许一次发送多个分组但未被确认，发送方的利用率可以在停等操作模式上得到增加。我们很快将会看到，窗口长度可根据接收方接收和缓存报文的能力、网络中的拥塞程度或两者的情况来进行设置</td>
</tr>
</tbody></table>
<p>​    避免重新排序问题：</p>
<ul>
<li>实际应用种采用的方法是，确保一个序号不被重新使用，直到发送方“确信”任何先前发送的序号为x的分组都不再在网络中为止。</li>
<li>通过<font color="red">假定一个分组在网络中的“存活”时间不会超过某个固定最大时间量</font>来做到这一点。</li>
<li>TCP最长的分组寿命被假定为3分钟。</li>
</ul>
<h2 id="5-面向连接的传输：-TCP"><a href="#5-面向连接的传输：-TCP" class="headerlink" title="5. 面向连接的传输： TCP"></a>5. 面向连接的传输： TCP</h2><h3 id="5-1-TCP-连接"><a href="#5-1-TCP-连接" class="headerlink" title="5.1 TCP 连接"></a>5.1 TCP 连接</h3><ul>
<li><p><font color="red">点对点：</font>一个发送方，一个接收方</p>
</li>
<li><p><font color="red">可靠的、按顺序的字节流：</font>没有报文边界</p>
</li>
<li><p><font color="red">管道化（流水线）：</font>TCP拥塞控制和流量控制设置窗口大小</p>
</li>
<li><p><font color="red">发送和接收缓存</font></p>
<ul>
<li><font color="blue">TCP连接的组成：</font><ul>
<li>一台主机上的缓存、变量和进程连接的套接字</li>
<li>另一台主机上的缓存、变量和进程连接的套接字</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/images/Computer-Network3/image-20230627094750302.png" alt="image-20230627094750302"></p>
<ul>
<li><p><font color="red">全双工数据：</font></p>
<ul>
<li>在同一连接中数据流双向流动</li>
<li>MSS：最大报文段大小(Maxinum Segment Size)    <ul>
<li>TCP 可从缓存中取出并放入报文段中的数据数量 </li>
<li>通常根据本地发送主机的最大链路层帧长度（<strong>最大传输单元</strong>（MTU））设置<ul>
<li>以太网和PPP链路层协议都具有1500字节的MTU，因此MSS的典型值为1460字节</li>
</ul>
</li>
<li>MSS的大小  + TCP头部 + IP头部 = 一个报文段</li>
<li>MSS是指在<strong>报文段里应用层数据的最大长度</strong>，而不是指包括TCP包首部的TCP报文段的最大长度</li>
</ul>
</li>
</ul>
</li>
<li><p><font color="red">面向连接：</font>在数据交换之前，通过<strong>握手</strong>（交换控制报文） 初始化发送方、接收方的状态变量 </p>
</li>
<li><p><font color="red">有流量控制：</font>发送方不会淹没接收方</p>
</li>
</ul>
<h3 id="5-2-TCP报文段结构"><a href="#5-2-TCP报文段结构" class="headerlink" title="5.2 TCP报文段结构"></a>5.2 TCP报文段结构</h3><p><img src="/images/Computer-Network3/image-20230627095205434.png" alt="image-20230627095205434"></p>
<p><font color="red">TCP报文段首部：</font></p>
<ul>
<li>16比特的<font color="red">源端口号</font>和<font color="red">目的端口号</font>。用于多路复用和解复用来自或送到上层应用的数据。</li>
<li>32比特的<font color="red">序号</font>字段和<font color="red">确认号</font>字段。这些字段被TCP发送方或接收方用来实现可靠数据传输服务。</li>
<li>16比特的<font color="red">接收窗口</font>字段。用于流量控制。</li>
<li>4比特的<font color="red">首部长度</font>字段。指使了以32比特的字尾单位的TCP首部长度。<ul>
<li>由于TCP选项字段的原因，TCP首部的长度是可变的（通常，选项字段为空，所以TCP首部的典型长度是20字节）</li>
</ul>
</li>
<li>可选与变长的<font color="red">选项</font>字段。该字段用于发送方与接收方协商最大报文段长度(MSS)时，或在高速网络环境下用作窗口调节因子时使用。首部字段中 还定义了一个时间戳选项</li>
<li>6比特的<font color="red">标志</font>字段。</li>
</ul>
<p>TCP报文段中<font color="red">两个最重要的字段</font>是序号和确认号字段。</p>
<p>TCP把数据看成一个<font color="red">无结构的、有序的字节流</font>。</p>
<p><u><font color="red">序号：</font></u></p>
<ul>
<li><p><strong>报文段首字节的在字节流的编号</strong></p>
</li>
<li><p>示例：假设主机A上的一个进程想通过一条TCP连接向主机B上的一个进程发送一个数据流（500000字节，MSS为1000字节，首字节编号是0）</p>
<ul>
<li>首字节编号可以随机选择，有利于减少误认的可能性</li>
<li>TCP将为数据流构建500个报文段，给第1个报文段分配<strong>序号为0</strong>，第二个报文段分配<strong>序号为1000</strong>，以此类推</li>
</ul>
</li>
</ul>
<p><img src="/images/Computer-Network3/image-20230627135202008.png" alt="文件数据划分为TCP报文段"></p>
<p><u><font color="red">确认号：</font></u></p>
<ul>
<li>**期望从另一方收到的下一个字节的序号 **</li>
<li><strong>累积确认</strong>（TCP只确认该流中至第一个丢失字节为止的字节）</li>
<li>示例1：假设主机A已收到了来自主机B的<strong>编号为0~535</strong>的所有字节，同时他打算发送一个报文段给主机B。主机A等待主机B的数据流中编号536及之后的所有字节。<ul>
<li>确认号为536</li>
</ul>
</li>
<li>示例2：在示例1的基础上，主机A还收到了<strong>编号为900~1000</strong>的所有字节。<ul>
<li>确认号为536</li>
</ul>
</li>
</ul>
<p>有趣的问题是：当主机在一条TCP连接中收到失序报文段时该怎么办？（留给实现TCP变成的人员自己选择）</p>
<ul>
<li>接收方立即丢弃失序报文段</li>
<li>接收方保留失序的字节，并等待缺少的字节以填充该间隔</li>
</ul>
<p><img src="/images/Computer-Network3/image-20230627095234726.png" alt="image-20230627095234726"></p>
<h3 id="5-3-TCP-往返延时（RTT）和超时"><a href="#5-3-TCP-往返延时（RTT）和超时" class="headerlink" title="5.3 TCP  往返延时（RTT）和超时"></a>5.3 TCP  往返延时（RTT）和超时</h3><p>怎样设置TCP超时间隔？ </p>
<ul>
<li>显然要比RTT长 <ul>
<li>但RTT是变化的</li>
</ul>
</li>
<li>太短：太早超时<ul>
<li>不必要的重传</li>
</ul>
</li>
<li>太长：对报文段丢失反应太慢，消极</li>
</ul>
<h4 id="5-3-1-怎样估计RTT？"><a href="#5-3-1-怎样估计RTT？" class="headerlink" title="5.3.1 怎样估计RTT？"></a>5.3.1 怎样估计RTT？</h4><p>TCP定时器的管理问题</p>
<ul>
<li>SampleRTT：测量从报文段发出到收到确认的时间 <ul>
<li>如果有重传，忽略此次测量（绝不为重传的报文段计算SampleRTT）</li>
</ul>
</li>
<li>SampleRTT会变化，因此估计的RTT应该比较平滑 <ul>
<li>对几个最近的测量值求平均，而不是仅用当前的SampleRTT</li>
</ul>
</li>
</ul>
<p>TCP维持一个SampleRTT均值 （称为<strong>EstimatedRTT</strong>）</p>
<p>EstimatedRTT = (1- α)*EstimatedRTT + α*SampleRTT </p>
<ul>
<li><strong><u>指数加权移动平均</u></strong> </li>
<li><strong>过去样本的影响呈指数衰减</strong> </li>
<li>推荐值：α = 0.125</li>
</ul>
<p><img src="/images/Computer-Network3/image-20230627095521629.png" alt="image-20230627095521629"></p>
<h4 id="5-3-2-设置超时"><a href="#5-3-2-设置超时" class="headerlink" title="5.3.2 设置超时"></a>5.3.2 设置超时</h4><p><img src="/images/Computer-Network3/image-20230627095553920.png" alt="image-20230627095553920"></p>
<h3 id="5-4-TCP：可靠数据传输"><a href="#5-4-TCP：可靠数据传输" class="headerlink" title="5.4 TCP：可靠数据传输"></a>5.4 TCP：可靠数据传输</h3><blockquote>
<p>因特网的网络层服务（IP服务）是不可靠的。IP不保证数据报的交付, 不保证数据报的按序交付，也不保证数据报中数据的完整性。对于IP服务，数据报能够溢出路由器缓存而永远不能到达目的地，数据报也可能是乱序到达，而且数据报中的比特可能损坏（由0变为1或者相反）。由于运输层报文段是被IP数据报携带着在网络中传输的，所以运输层的报文段也会遇到这些问题。</p>
</blockquote>
<ul>
<li><p>TCP在IP不可靠服务的基础上建立了种<strong>可靠数据传输服务rdt</strong> </p>
<ul>
<li>管道化（流水线）的报文段 • GBN or SR </li>
<li>累积确认（像GBN）</li>
<li>单个重传定时器（像GBN）</li>
<li>是否可以接受乱序的，没有规范</li>
</ul>
</li>
<li><p>通过以下事件<strong>触发重传</strong> </p>
<ul>
<li>超时（只重发那个最早的未确认段：SR）</li>
<li>重复的确认<ul>
<li> 例子：收到了ACK50,之后又收到3个ACK50</li>
</ul>
</li>
</ul>
</li>
<li><p>首先考虑简化的TCP发送方： </p>
<ul>
<li>忽略重复的确认 </li>
<li>忽略流量控制和拥塞控制</li>
</ul>
</li>
</ul>
<p><img src="/images/Computer-Network3/image-20230627095831186.png" alt="image-20230627095831186"></p>
<p><img src="/images/Computer-Network3/image-20230627100135450.png" alt="image-20230627100135450"></p>
<p><strong>TCP发送方事件：</strong></p>
<p><u><font color="red">从应用层接收数据：</font></u></p>
<ul>
<li>用nextseq创建报文段</li>
<li>序号nextseq为报文段首字节的字节流编号 </li>
<li>如果还没有运行，启动定时器<ul>
<li>定时器与最早未确认的报文段关联</li>
<li>过期间隔：TimeOutInterval</li>
</ul>
</li>
</ul>
<p><u><font color="red">超时：</font></u> </p>
<ul>
<li>重传后沿最老的报文段</li>
<li>重新启动定时器</li>
</ul>
<p><u><font color="red">收到确认：</font></u></p>
<ul>
<li>如果是对尚未确认的报文段确认</li>
<li>更新已被确认的报文序号</li>
<li>如果当前还有未被确认的报文段，重新启动定时器 (发完，就关掉定时器)</li>
</ul>
<p><img src="/images/Computer-Network3/image-20230627100152795.png" alt="image-20230627100152795"></p>
<p><img src="/images/Computer-Network3/image-20230627100209622.png" alt="image-20230627100209622"></p>
<p><strong>产生TCP ACK的建议</strong></p>
<table>
<thead>
<tr>
<th>接收方的事件</th>
<th>TCP接收方动作</th>
</tr>
</thead>
<tbody><tr>
<td>所期望序号的报文段按序到达。 所有在期望序号之前的数据都已经被确认</td>
<td>延迟的ACK（提高效率，少发一个ACK）。对另一个按序报文段的到达最多等待500ms。如果下一个报文段<strong>在这个时间间隔内没有到达</strong>，则发送一个ACK。</td>
</tr>
<tr>
<td>有期望序号的报文段到达。 另一个按序报文段等待发送ACK</td>
<td><strong>立即发送单个累积ACK，以确认两个按序报文段。</strong></td>
</tr>
<tr>
<td>比期望序号大的报文段乱序到达。 检测出数据流中的间隔</td>
<td>立即发送重复的ACK，<strong>指明下一个期待字节的序号</strong>（其为间隔的低端的序号）</td>
</tr>
<tr>
<td>能部分或完全填充接收数据间隔的报文段到达</td>
<td>若该报文段起始于间隔（gap）的低端， 则立即发送ACK（给确认。反映下一段的需求）。</td>
</tr>
</tbody></table>
<p><strong>快速重传</strong></p>
<ul>
<li><p>超时周期往往太长：</p>
<ul>
<li>在重传丢失报文段之前的延时太长</li>
</ul>
</li>
<li><p>通过重复的ACK来检测报文段丢失 </p>
<ul>
<li>发送方通常连续发送大量报文段 </li>
<li>如果报文段丢失，通常会引起多个重复的ACK</li>
</ul>
</li>
</ul>
<p><img src="/images/Computer-Network3/image-20210726083307463.png" alt="image-20210726083307463"></p>
<ul>
<li><p>如果发送方收到同一数据的<strong>3个冗余ACK</strong>，重传最小序号的段： </p>
<ul>
<li><font color="red">快速重传：</font>在定时器过时之前重发报文段 </li>
</ul>
</li>
<li><p>它假设跟在被确认的数据后面的数据丢失了 </p>
<ul>
<li> 第一个ACK是正常的； </li>
<li>收到第二个该段的ACK，表示接收方收到一个该段后的乱序段； </li>
<li>收到第3，4个该段的ack，表示接收方收到该段之后的2个 ，3个乱序段，可能性非常大段丢失了</li>
</ul>
</li>
</ul>
<p><strong>三重ACK接收后的快速重传</strong></p>
<p><img src="/images/Computer-Network3/image-20210726083418896.png" alt="image-20210726083418896"></p>
<p><img src="/images/Computer-Network3/image-20230627100532529.png" alt="image-20230627100532529"></p>
<h3 id="5-5-TCP-流量控制"><a href="#5-5-TCP-流量控制" class="headerlink" title="5.5 TCP 流量控制"></a>5.5 TCP 流量控制</h3><blockquote>
<p>一条TCP连接的每一侧主机都为该连接设置了<strong>接收缓存</strong>。当该TCP连接收到正确、按序的字节后，它就将数 据放入接收缓存。<strong>相关联的应用进程会从该缓存中读取数据</strong>，但不必是数据刚一到达就立即读取。事实上，接收方应用也许正忙于其他任务，甚至要过很长时间后才去读取该数据。如果某应用程序读取数据时相对缓慢，而发送方发送得太多、太快，发送的数据就会很容易地使该连接的接收缓存溢出。</p>
</blockquote>
<ul>
<li>TCP为它的引用程序提供了<font color="red">流量控制服务</font>（flow-control service）以消除发送方使接收方缓存溢出的可能性。</li>
</ul>
<p><img src="/images/Computer-Network3/image-20230627100634311.png" alt="image-20230627100634311"></p>
<ul>
<li>TCP通过让发送方维护一个称为<font color="red">接收窗口</font>(receive window)的变量来提供流量控制<ul>
<li>接受窗口用于给发送方一个指示：接收方还有多少可用的缓存空间</li>
<li>由于TCP是全双工通信，在连接两端的发送方都各自维护一个接收窗口</li>
</ul>
</li>
<li>假设主机A通过一条TCP连接向主机B发送一个大文件。主机B为该连接分配了一个接收缓存，并用<font color="red">RcvBuffer</font>来表示其大小。主机B上的应用进程不时地从该缓存中读取数据。我们定义以下变量：<ul>
<li><font color="red">LastByteRead</font>：主机B上的应用进程从缓存读出的数据流的最后一个字节的编号 </li>
<li><font color="red">LastByteRcvd</font>：从网络中到达的并且已放入主机B接收缓存中的数据流的最后一个 字节的编号</li>
</ul>
</li>
<li> 由于<strong>TCP不允许已分配的缓存溢岀</strong>，下式必须成立: </li>
<li><font color="blue">LastByteRcvd - LastByteRead ≤ RcvBuffer</font></li>
<li>接收窗口用<font color="red">rwnd</font>表示，根据缓存可用空间的数量来设置: <ul>
<li><font color="blue">rwnd = RcvBuffer - [ LastByteRcvd - LastByteRead ]</font></li>
</ul>
</li>
<li>由于该空间是随着时间变化的，所以<font color="red">rwnd是动态的</font><ul>
<li>一开始设定 rwnd = RcvBuffer</li>
</ul>
</li>
<li>接收方在其向发送方的TCP段头部的rwnd字段“通告”其空闲buffer大小 <ul>
<li>RcvBuffer大小通过socket选项设置 (典型默认大小为4096 字节) </li>
<li>很多操作系统自动调整 RcvBuffer</li>
</ul>
</li>
<li>发送方限制未确认(“in-flight”)字节的个数≤接收方发送过来的值<ul>
<li>在连接的整个生命周期须保证：LastByteSent - LastByteAcked  ≤ rwnd</li>
</ul>
</li>
</ul>
<p><img src="/images/Computer-Network3/image-20230628104213166.png" alt="接收窗口rwnd和接收缓存RcvBuffer"></p>
<p><img src="/images/Computer-Network3/image-20230628104825177.png" alt="image-20230628104825177"></p>
<h3 id="5-6-TCP连接管理"><a href="#5-6-TCP连接管理" class="headerlink" title="5.6 TCP连接管理"></a>5.6 TCP连接管理</h3><p>在正式交换数据之前，发送方和接收方握手建立通信关系: </p>
<ul>
<li><strong>同意建立连接（每一方都知道对方愿意建立连接）</strong></li>
<li><strong>同意连接参数</strong></li>
</ul>
<p><img src="/images/Computer-Network3/image-20230628155737476.png"></p>
<h4 id="同意建立连接"><a href="#同意建立连接" class="headerlink" title="同意建立连接"></a>同意建立连接</h4><p><img src="/images/Computer-Network3/image-20230627100829946.png" alt="image-20230627100829946"></p>
<p>在网络中，2次握手建立连接总是可行吗？</p>
<ul>
<li> 变化的延迟（连接请求的段没有丢，但可能超时） </li>
<li>由于丢失造成的重传 (e.g. req_conn(x)) </li>
<li>报文乱序 </li>
<li>相互看不到对方</li>
</ul>
<p><img src="/images/Computer-Network3/image-20230627100943643.png" alt="image-20230627100943643"></p>
<p>1、可能发送半连接（只在服务器维护了连接）<br>2、老的数据被当成新的数据接收了    <strong><u>seq  x 和 x + 1</u></strong></p>
<p>TCP 3次握手</p>
<p><img src="/images/Computer-Network3/image-20230627101005853.png" alt="image-20230627101005853"></p>
<p><strong>解决方案：变化的初始序号+双方确认对方的序号 (3次握手)</strong></p>
<ul>
<li><strong>第一次</strong>：客户端的TCP首先向服务器端的TCP发送一个特殊的TCP报文段（该报文段不包含数据部分的）<ul>
<li>报文段首部标志位SYNbit置为1</li>
<li>随机初始序号（client_isn）</li>
<li><font color="red">SYN=1，seq=client_isn</font></li>
</ul>
</li>
<li><strong>第二次</strong>：一旦包含TCP SYN报文段的IP数据报到达服务器主机，服务器会从该数据报中提取出TCP SYN报文段，为该TCP连接分配TCP缓存和变量，并向该客户TCP发送允许连接的报文段（SYNACK报文段）<ul>
<li>报文段首部标志位SYNbit置为1</li>
<li>首部确认号字段为client_isn+1</li>
<li>随机初始序号（server_isn）</li>
<li><font color="red">SYN=1，seq=server_isn，ack=client_isn+1</font></li>
</ul>
</li>
<li><strong>第三次</strong>：在收到SYNACK报文段后，客户也要给该连接分配缓存和变量。<ul>
<li>报文段首部标志位SYNbit置为0</li>
<li>首部确认号字段为server_isn+1</li>
<li><font color="red">SYN=0，seq=client_isn+1，ack=server_isn+1</font></li>
</ul>
</li>
</ul>
<p><img src="/images/Computer-Network3/image-20230628114847616.png" alt="TCP 三次握手"></p>
<h4 id="3次握手解决：半连接和接收老数据问题"><a href="#3次握手解决：半连接和接收老数据问题" class="headerlink" title="3次握手解决：半连接和接收老数据问题"></a><u>3次握手解决：半连接和接收老数据问题</u></h4><p><img src="/images/Computer-Network3/image-20210726121605926.png" alt="image-20210726121605926"></p>
<p><img src="/images/Computer-Network3/image-20230627101049118.png" alt="image-20230627101049118"></p>
<p><strong>二次握手：可能发送半连接（只在服务器维护了连接）</strong><br><strong>三次握手：客户端在第三次握手拒绝连接请求服务器二次握手后的连接请求</strong></p>
<p><strong>二次握手：老的数据被当成新的数据接收了</strong><br><strong>三次握手：未建立连接（无半连接），故将发来的数据丢掉</strong></p>
<p>扔掉：连接不存在， 没建立起来；连接的 序号不在当前连接的 范围之内</p>
<p><strong>若一个数据滞留时间足够长导致</strong><br><strong>在TCP第二次连接（两个三次握手后）到来，这个数据包大概率也会被丢弃，因为seq不一样，而seq又与时间有关</strong></p>
<h4 id="TCP-关闭连接"><a href="#TCP-关闭连接" class="headerlink" title="TCP: 关闭连接"></a>TCP: 关闭连接</h4><p><img src="/images/Computer-Network3/image-20230628141949619.png" alt="关闭一条TCP连接"></p>
<ul>
<li><strong>客户端，服务器分别关闭它自己这一侧的连接</strong> <ul>
<li><strong>发送FIN bit = 1的TCP段</strong></li>
</ul>
</li>
<li><strong>一旦接收到FIN，用ACK回应</strong><ul>
<li><strong>接到FIN段，ACK可以和它自己发出的FIN段一起发 送</strong></li>
</ul>
</li>
<li><strong>可以处理同时的FIN交换</strong></li>
</ul>
<p><img src="/images/Computer-Network3/image-20230627101142747.png" alt="image-20230627101142747"></p>
<p><img src="/images/Computer-Network3/image-20230628142028195.png" alt="TCP客户经历的典型的TCP状态序列"></p>
<p><img src="/images/Computer-Network3/image-20230628142059621.png" alt="TCP服务器经历的典型的TCP状态序列"></p>
<p>假设Client端发起中断连接请求，也就是发送FIN报文。Server端接到FIN报文后，意思是说”我Client端没有数据要发给你了”，但是如果你还有数据没有发送完成，则不必急着关闭Socket，可以继续发送数据。所以你先发送ACK，”告诉Client端，你的请求我收到了，但是我还没准备好，请继续你等我的消息”。这个时候Client端就进入FIN_WAIT状态，继续等待Server端的FIN报文。当Server端确定数据已发送完成，则向Client端发送FIN报文，”告诉Client端，好了，我这边数据发完了，准备好关闭连接了”。Client端收到FIN报文后，”就知道可以关闭连接了，但是他还是不相信网络，怕Server端不知道要关闭，所以发送ACK后进入TIME_WAIT状态，如果Server端没有收到ACK则可以重传。“，Server端收到ACK后，”就知道可以断开连接了”。Client端等待了2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，我Client端也可以关闭连接了。Ok，TCP连接就这样关闭了！</p>
<p>【问题1】为什么连接的时候是三次握手，关闭的时候却是四次握手？<br>答：因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。</p>
<h2 id="3-6-拥塞控制原理"><a href="#3-6-拥塞控制原理" class="headerlink" title="3.6 拥塞控制原理"></a>3.6 拥塞控制原理</h2><p><font color="red">拥塞：</font></p>
<ul>
<li>非正式的定义: “太多的数据需要网络传输，超过了网络的处理能力” </li>
<li>与流量控制不同</li>
<li>拥塞的表现：<ul>
<li><strong><u>分组丢失 (路由器缓冲区溢出)</u></strong> </li>
<li><strong><u>分组经历比较长的延迟(在路由器的队列中排队)</u></strong></li>
</ul>
</li>
<li>网络中前10位的问题!</li>
</ul>
<h3 id="拥塞的原因-代价-场景1"><a href="#拥塞的原因-代价-场景1" class="headerlink" title="拥塞的原因/代价: 场景1"></a>拥塞的原因/代价: 场景1</h3><p><img src="/images/Computer-Network3/image-20210726125936998.png" alt="image-20210726125936998"></p>
<h3 id="拥塞的原因-代价-场景2"><a href="#拥塞的原因-代价-场景2" class="headerlink" title="拥塞的原因/代价: 场景2"></a>拥塞的原因/代价: 场景2</h3><ul>
<li>一个路由器，<font color="blue">有限的缓冲</font></li>
<li>分组丢失时，发送端重传<ul>
<li>应用层的输入=应用层输出:  λ<sub>in</sub> =  λ<sub>out</sub> </li>
<li>传输层的输入包括重传:  λ<sub>in’’</sub>&gt;=  λ<sub>in</sub></li>
</ul>
</li>
</ul>
<p><img src="/images/Computer-Network3/image-20210726130345272.png" alt="image-20210726130345272"></p>
<p><font color="blue">理想化: 发送端有完美的信息</font></p>
<p>发送端知道什么时候路由器的缓冲是可用的 </p>
<ul>
<li>只在缓冲可用时发送 </li>
<li>不会丢失: λ<sub>in’’</sub> =  λ<sub>in</sub></li>
</ul>
<p><em><font color="blue">理想化：</font><font color="red">掌握丢失信息</font></em> </p>
<p>分组可以丢失，在路由器由于缓冲器满而被丢弃</p>
<ul>
<li>如果知道分组丢失了，发送方重传分组</li>
</ul>
<p><em><font color="blue">现实情况：</font><font color="red">重复</font></em> </p>
<ul>
<li>分组可能丢失，由于缓冲器满而被丢弃 </li>
<li>发送端最终<font color="red">超时</font>，发送第2个拷贝，2个分组都被传出</li>
</ul>
<p><img src="/images/Computer-Network3/image-20230628182224224.png" alt="image-20230628182224224"></p>
<p><img src="/images/Computer-Network3/image-20230628182236334.png" alt="image-20230628182236334"></p>
<p><font color="red">拥塞的“代价”：</font></p>
<ul>
<li>为了达到一个有效输出，网络需要做更多的工作（重传） </li>
<li>没有必要的重传，链路中包括了多个分组的拷贝 <ul>
<li>是那些没有丢失，经历的时间比较长（拥塞状态）但是超时的分组 </li>
<li>降低了的“goodput”</li>
</ul>
</li>
</ul>
<p><u><strong>输出比输入少原因：1）重传的丢失分组；2） 没有必要重传的重复分组</strong></u></p>
<h3 id="拥塞的原因-代价-场景3"><a href="#拥塞的原因-代价-场景3" class="headerlink" title="拥塞的原因/代价: 场景3"></a>拥塞的原因/代价: 场景3</h3><ul>
<li><p>4个发送端        </p>
</li>
<li><p>多重路径        </p>
</li>
<li><p>超时／重传</p>
</li>
</ul>
<p>Q：当λ<sub>in’’</sub>   λ<sub>in</sub> 增加时，会发生什么？</p>
<p>A：当红色的 λ<sub>in’’</sub> 增加时，所有到来的蓝色分组都在最上方的队列中丢弃了，蓝色吞吐-&gt;0</p>
<p><img src="/images/Computer-Network3/image-20210726131141125.png" alt="image-20210726131141125"></p>
<p><img src="/images/Computer-Network3/image-20210726131409102.png" alt="image-20210726131409102"></p>
<p><font color="red">又一个拥塞的代价：</font></p>
<ul>
<li>当分组丢失时，<strong>任何“关于这个分组的上游传输能力” 都被浪费了</strong></li>
</ul>
<h3 id="拥塞控制方法"><a href="#拥塞控制方法" class="headerlink" title="拥塞控制方法"></a>拥塞控制方法</h3><p>**2种常用的拥塞控制方法: **</p>
<p><font color="red">端到端拥塞控制:</font> </p>
<ul>
<li>没有来自网络的显式反馈 </li>
<li>端系统根据延迟和丢失事件推断是否有拥塞 </li>
<li>TCP采用的方法</li>
</ul>
<p><font color="red">网络辅助的拥塞控制: </font></p>
<ul>
<li>路由器提供给端系统以反馈信息 </li>
<li>单个bit置位，显示有拥塞 (SNA, DECbit, TCP/IP ECN, ATM) </li>
<li>显式提供发送端可以采用的速率</li>
</ul>
<h3 id="案例学习-ATM-ABR-拥塞控制"><a href="#案例学习-ATM-ABR-拥塞控制" class="headerlink" title="案例学习: ATM ABR 拥塞控制"></a>案例学习: ATM ABR 拥塞控制</h3><p><font color="red">ABR: available bit rate: </font></p>
<ul>
<li>“弹性服务” </li>
<li>如果发送端的路径“轻载 ”    <ul>
<li>发送方使用可用带宽 </li>
</ul>
</li>
<li>如果发送方的路径拥塞了    <ul>
<li>发送方限制其发送的速度到一个最小保障速率上</li>
</ul>
</li>
</ul>
<p><font color="red">RM (资源管理) 信元:</font></p>
<ul>
<li>由发送端发送,在数据信元中间隔插入</li>
<li>RM信元中的比特被交换机设置 (“网络辅助”)<ul>
<li>NI bit: no increase in rate (轻微拥塞)速率不要增加了</li>
<li> CI bit: congestion indication 拥塞指示</li>
</ul>
</li>
<li> 发送端发送的RM信元被接收端返回，接收端不做任何改变</li>
</ul>
<p><img src="/images/Computer-Network3/image-20230628183033914.png" alt="image-20230628183033914"></p>
<ul>
<li>在RM信元中的2个字节 ER (explicit rate)字段<ul>
<li>拥塞的交换机可能会降低信元中ER的值</li>
<li>发送端发送速度因此是最低的可支持速率(交换机)</li>
</ul>
</li>
<li>数据信元中的EFCI bit：被拥塞的交换机设置成1 <ul>
<li>如果在管理信元RM前面的数据信元EFCI被设置成了1, 接收端在返回的RM信元中设置CI bit</li>
</ul>
</li>
</ul>
<p>总结：网络提供一些信息，包括一些标志位的置位以及字段 (为两主机间的通信提供多大的带宽)</p>
<h2 id="3-7-TCP-拥塞控制"><a href="#3-7-TCP-拥塞控制" class="headerlink" title="3.7 TCP 拥塞控制"></a>3.7 TCP 拥塞控制</h2><h3 id="TCP-拥塞控制：机制"><a href="#TCP-拥塞控制：机制" class="headerlink" title="TCP 拥塞控制：机制"></a>TCP 拥塞控制：机制</h3><p><strong><font color="red">端到端的拥塞控制机制</font></strong> </p>
<ul>
<li><p>路由器不向主机有关拥塞的反馈信息 </p>
<ul>
<li>路由器的负担较轻 </li>
<li>符合网络核心简单的 TCP/IP架构原则</li>
</ul>
</li>
<li><p>端系统根据自身得到的信息 ，判断是否发生拥塞，从而采取动作</p>
</li>
</ul>
<p><strong><font color="red">拥塞控制的几个问题 </font></strong></p>
<ul>
<li>如何检测拥塞 <ul>
<li>轻微拥塞 </li>
<li>拥塞 </li>
</ul>
</li>
<li>控制策略 <ul>
<li>在拥塞发送时如何动作，降低速率 <ul>
<li>轻微拥塞，如何降低 </li>
<li>拥塞时，如何降低 </li>
</ul>
</li>
<li>在拥塞缓解时如何动作，增加速率</li>
</ul>
</li>
</ul>
<h3 id="TCP-拥塞控制：拥塞感知"><a href="#TCP-拥塞控制：拥塞感知" class="headerlink" title="TCP 拥塞控制：拥塞感知"></a>TCP 拥塞控制：拥塞感知</h3><p><u><font color="red">发送端如何探测到拥塞?</font></u></p>
<ul>
<li>某个段超时了（丢失事件 ）：<font color="red">拥塞</font><ul>
<li>超时时间到，某个段的确认没有来 </li>
<li><strong>原因1：网络拥塞（某个路由器缓冲区没空间了，被丢弃）概率大</strong> </li>
<li><strong>原因2：<u>出错被丢弃了（各级错误，没有通过校验，被丢弃）概率小</u></strong> </li>
<li>一旦超时，就认为拥塞了，有一定误判，但是总体控制方向是对的</li>
</ul>
</li>
<li>有关某个段的3次重复ACK：<font color="red">轻微拥塞</font><ul>
<li>段的第1个ack，正常，确认绿段，期待红段 </li>
<li>段的第2个重复ack，意味着红段的后一段收到了，蓝段乱序到达 </li>
<li>段的第2、3、4个ack重复，意味着红段的后第2、3、4个段收到了 ，橙段乱序到达，同时红段丢失的可能性很大（后面3个段都到了， 红段都没到） </li>
<li><strong>网络这时还能够进行一定程度的传输，拥塞但情况要比第一种好</strong></li>
</ul>
</li>
</ul>
<h3 id="TCP-拥塞控制：速率控制方法"><a href="#TCP-拥塞控制：速率控制方法" class="headerlink" title="TCP 拥塞控制：速率控制方法"></a>TCP 拥塞控制：速率控制方法</h3><p><u><font color="red">如何控制发送端发送的速率</font></u> </p>
<ul>
<li><p>维持一个拥塞窗口的值：CongWin (主要手段)</p>
</li>
<li><p>发送端限制<font color="red">已发送但是未确认</font>的数据量（的上限: </p>
<p><font color="green">LastByteSent-LastByteAcked  &lt;= CongWin</font></p>
</li>
<li><p>从而<strong>粗略地控制</strong>发送方的往网络中注入的速率</p>
</li>
</ul>
<p><strong>RTT 往返延时</strong></p>
<p><img src="/images/Computer-Network3/image-20210726150610364.png" alt="image-20210726150610364"></p>
<ul>
<li>CongWin是动态的，是感知到的网络拥塞程度的函数 <ul>
<li>超时或者3个重复ack，CongWin↓（下降）<ul>
<li><font color="red">超时时：</font><strong>CongWin降为1MSS</strong>，<strong>进入SS阶段</strong>然后再倍增到 <font color="red">CongWin(原) / 2（每个RTT</font>，从而<strong>进入CA阶段</strong> </li>
<li><font color="red">3个重复ack ：</font>CongWin降为CongWin/2,CA阶段 </li>
</ul>
</li>
<li>否则（正常收到Ack，没有发送以上情况）：CongWin跃跃欲试↑ （上升）<ul>
<li><font color="red">SS阶段：加倍增加(每个RTT)</font></li>
<li><font color="red">CA阶段：线性增加(每个RTT)</font></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="TCP拥塞控制和流量控制的联合动作"><a href="#TCP拥塞控制和流量控制的联合动作" class="headerlink" title="TCP拥塞控制和流量控制的联合动作"></a>TCP拥塞控制和流量控制的联合动作</h3><p><u><font color="red">联合控制的方法: </font></u> </p>
<ul>
<li>发送端控制发送但是未确认的量同时也不能够超过接收 窗口，满足流量控制要求 <ul>
<li><strong>SendWin=min{CongWin, RecvWin}</strong> </li>
<li>同时满足 拥塞控制和流量控制要求</li>
</ul>
</li>
</ul>
<p><u><font color="red">拥塞控制策略:</font></u> </p>
<ul>
<li>慢启动 </li>
<li>AIMD：线性增、乘性减少 </li>
<li>超时事件后的保守策略</li>
</ul>
<h4 id="TCP-慢启动"><a href="#TCP-慢启动" class="headerlink" title="TCP 慢启动"></a>TCP 慢启动</h4><ul>
<li><p>连接刚建立, CongWin = 1 MSS </p>
<ul>
<li>如: MSS = 1460bytes &amp; RTT = 200 msec </li>
<li>初始速率 = 58.4kbps </li>
</ul>
</li>
<li><p>可用带宽可能 &gt;&gt; MSS/RTT </p>
<ul>
<li>应该尽快加速，到达希望的速率</li>
</ul>
</li>
<li><p>当连接开始时，指数性增加发送速率，直到发生丢失的事件 </p>
<ul>
<li>启动初值很低</li>
<li>但是速度很快</li>
</ul>
</li>
<li><p>当连接开始时，指数性增加（每个RTT）发送速率 直到发生丢失事件 </p>
<ul>
<li>每一个RTT， CongWin加倍 </li>
<li>每收到一个ACK时， CongWin加1（why） </li>
<li>慢启动阶段：只要不超时或 3个重复ack，一个RTT， CongWin加倍</li>
</ul>
</li>
<li><p><u><font color="red">总结: </font></u> 初始速率很慢，但是加速却是指数性的</p>
<ul>
<li>指数增加，SS时间很短，长期来看可以忽略</li>
</ul>
</li>
</ul>
<h4 id="TCP-拥塞控制：AIMD"><a href="#TCP-拥塞控制：AIMD" class="headerlink" title="TCP 拥塞控制：AIMD"></a>TCP 拥塞控制：AIMD</h4><p><u><font color="red">乘性减: </font></u></p>
<p>丢失事件后将CongWin降为1(ss阶段通常可忽略，故相当于直接减少到 CongWin/2 )，将CongWin/2作为阈值，进入慢启动阶段（倍增直到 CongWin/2）</p>
<p><u><font color="red">加性增： </font></u> </p>
<p><strong>当 CongWin &gt;阈值时</strong>，一个 RTT 如没有发生丢失事件，将 CongWin 加1MSS : 探测</p>
<p><img src="/images/Computer-Network3/image-20230628195550458.png" alt="image-20230628195550458"></p>
<p>当收到<font color="red">3个重复的ACKs: </font></p>
<ul>
<li>CongWin 减半 </li>
<li>窗口（缓冲区大小）之后 线性增长</li>
</ul>
<p>当<font color="red">超时</font>事件发生时: </p>
<ul>
<li><strong>CongWin被设置成 1 MSS</strong>，进入SS阶段</li>
<li>之后窗口指数增长</li>
<li>增长到一个阈值（上次发 生拥塞的窗口的一半）时 ，再线性增加</li>
</ul>
<blockquote>
<p><font color="red">思路</font></p>
<ul>
<li>3个重复的ACK表示网络还有一定的段输出能力</li>
<li>超过之前的3个重复的ACK表示“警报”</li>
</ul>
</blockquote>
<h3 id="总结-TCP拥塞控制"><a href="#总结-TCP拥塞控制" class="headerlink" title="总结: TCP拥塞控制"></a>总结: TCP拥塞控制</h3><p>出现丢失，Threshold设置成 CongWin的1/2</p>
<ul>
<li><p>当<strong>CongWin＜Threshold</strong>, 发送端处于慢启动阶段<font color="blue">（ slow-start）</font>, 窗口指数性增长. </p>
</li>
<li><p>当<strong>CongWin &gt; Threshold</strong>, 发送端处于拥塞避免阶段 <font color="blue">（congestion-avoidance）</font>, 窗口线性增长. </p>
</li>
<li><p>当收到三个重复的ACKs <font color="blue">(triple duplicate ACK)</font>, Threshold设置成 <strong>CongWin/2， CongWin=Threshold+3</strong>. </p>
</li>
<li><p>当超时事件发生时<font color="blue">timeout</font>, <strong>Threshold=CongWin/2 CongWin=1 MSS</strong>，进入SS阶段</p>
</li>
</ul>
<h4 id="TCP-发送端拥塞控制"><a href="#TCP-发送端拥塞控制" class="headerlink" title="TCP 发送端拥塞控制"></a>TCP 发送端拥塞控制</h4><p>状态转换</p>
<p><img src="/images/Computer-Network3/image-20230628200108431.png" alt="image-20230628200108431"></p>
<p><img src="/images/Computer-Network3/image-20230628200133257.png" alt="image-20230628200133257"></p>
<h3 id="TCP-吞吐量"><a href="#TCP-吞吐量" class="headerlink" title="TCP 吞吐量"></a>TCP 吞吐量</h3><ul>
<li><p>TCP的平均吞吐量是多少，使用窗口window尺寸W和RTT来描述? </p>
<ul>
<li>忽略慢启动阶段，假设发送端总有数据传输</li>
</ul>
</li>
<li><p>W：发生丢失事件时的窗口尺寸（单位：字节）</p>
<ul>
<li><p>平均窗口尺寸（#in-flight字节）：3/4W</p>
</li>
<li><p>平均吞吐量：一个RTT时间吞吐3/4W</p>
<p> avg TCP thruput = 3/4 * (W/RTT) bytes/sec</p>
</li>
</ul>
<p><img src="/images/Computer-Network3/image-20230628200251578.png" alt="image-20230628200251578"></p>
</li>
</ul>
<p><img src="/images/Computer-Network3/image-20230628200310577.png" alt="image-20230628200310577"></p>
<h3 id="TCP-公平性"><a href="#TCP-公平性" class="headerlink" title="TCP 公平性"></a>TCP 公平性</h3><p><font color="red">公平性目标：</font>如果 <strong>K个TCP会话</strong>分享一个链路带宽为R的 瓶颈，每一个会话的有效带宽为 <strong>R/K</strong></p>
<p><img src="/images/Computer-Network3/image-20230628200323222.png" alt="image-20230628200323222"></p>
<p>为什么TCP是公平的？</p>
<p>2个竞争的TCP会话: </p>
<ul>
<li>加性增加，斜率为1, 吞吐量增加 </li>
<li>乘性减，吞吐量比例减少</li>
</ul>
<p><img src="/images/Computer-Network3/image-20230628200420928.png" alt="image-20230628200420928"></p>
<p><strong><u>往返延迟相同时，TCP会话竞争的最终，双方的 有效的带宽 将收敛到 链路带宽 的一半。</u></strong><br><u><strong>所以相互竞争时 应用建立的TCP会话越多，占有带宽一般越大。</strong></u></p>
<p><u><font color="red">公平性和 UDP</font></u></p>
<ul>
<li>多媒体应用通常不是用 TCP <ul>
<li>应用发送的数据速率希望 不受拥塞控制的节制</li>
</ul>
</li>
<li>使用UDP: <ul>
<li>音视频应用泵出数据的速率是恒定的, 忽略数据的丢失 </li>
</ul>
</li>
<li>研究领域: TCP 友好性</li>
</ul>
<p><u><font color="red">公平性和并行TCP连接</font></u> </p>
<ul>
<li><p>2个主机间可以打开多个并行的TCP连接 </p>
</li>
<li><p>Web浏览器 </p>
</li>
<li><p>例如: 带宽为R的链路支持了 9个连接; </p>
<ul>
<li>如果新的应用要求建1个TCP连接,获得带宽R/10 </li>
<li>如果新的应用要求建11个TCP连接,获得带宽R/2</li>
</ul>
</li>
</ul>
<p><img src="/images/Computer-Network3/image-20230628200604313.png" alt="image-20230628200604313"></p>
<h2 id="第三章-总结"><a href="#第三章-总结" class="headerlink" title="第三章 总结"></a>第三章 总结</h2><ul>
<li><p>传输层提供的服务 </p>
<ul>
<li>应用进程间的逻辑通信<ul>
<li>Vs 网络层提供的是主机到主机的通信服务 </li>
</ul>
</li>
<li>互联网上传输层协议：UDP TCP <ul>
<li>特性 </li>
</ul>
</li>
</ul>
</li>
<li><p>多路复用和解复用 </p>
<ul>
<li>端口：传输层的SAP </li>
<li>无连接的多路复用和解复用 </li>
<li>面向连接的多路复用和解复用 </li>
</ul>
</li>
<li><p>实例1：无连接传输层协议 UDP </p>
<ul>
<li>多路复用解复用</li>
<li>UDP报文格式</li>
<li>检错机制：校验和</li>
</ul>
</li>
<li><p>可靠数据传输原理</p>
<ul>
<li>问题描述</li>
<li>停止等待协议<ul>
<li>Rdt1.0 rdt2.0,2.1 ,2.2 Rdt 3.0 </li>
</ul>
</li>
<li>流水线协议 <ul>
<li>GBN</li>
<li>SR（Selective Repeat）</li>
</ul>
</li>
</ul>
</li>
<li><p>实例2：面向连接的 传输层协议-TCP </p>
<ul>
<li>概述：TCP特性 </li>
<li>报文段格式<ul>
<li>序号，超时机制及时间</li>
</ul>
</li>
<li>TCP可靠传输机制</li>
<li>重传，快速重传</li>
<li>流量控制</li>
<li>连接管理<ul>
<li>三次握手</li>
<li>对称连接释放</li>
</ul>
</li>
<li>拥塞控制原理<ul>
<li>网络辅助的拥塞控制</li>
<li>端到端的拥塞控制</li>
</ul>
</li>
<li>TCP的拥塞控制<ul>
<li>AIMD</li>
<li>慢启动</li>
<li>超时之后的保守策略</li>
</ul>
</li>
</ul>
</li>
</ul>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">8yyy</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="http://8yyy.github.io/2022/08/16/Computer-Network3/">http://8yyy.github.io/2022/08/16/Computer-Network3/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">8yyy</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">
                                    <span class="chip bg-color">计算机网络</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/8yyy/8yyy.github.io/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="https://cdn.jsdelivr.net/gh/8yyy/8yyy.github.io/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.png" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2022/08/21/CSharpNotes/">
                    <div class="card-image">
                        
                        <img src="/images/CSharpNotes/note.jpeg" class="responsive-img" alt="CSharpNotes">
                        
                        <span class="card-title">CSharpNotes</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2022-08-21
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E7%AC%94%E8%AE%B0/" class="post-category">
                                    笔记
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/CSharp/">
                        <span class="chip bg-color">CSharp</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2022/07/30/Computer-Network2/">
                    <div class="card-image">
                        
                        
                        <img src="https://cdn.jsdelivr.net/gh/8yyy/8yyy.github.io/medias/featureimages/18.jpg" class="responsive-img" alt="第二章 应用层">
                        
                        <span class="card-title">第二章 应用层</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2022-07-30
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" class="post-category">
                                    计算机基础
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">
                        <span class="chip bg-color">计算机网络</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>


<script>
    $('#articleContent').on('copy', function (e) {
        // IE8 or earlier browser is 'undefined'
        if (typeof window.getSelection === 'undefined') return;

        var selection = window.getSelection();
        // if the selection is short let's not annoy our users.
        if (('' + selection).length < Number.parseInt('50')) {
            return;
        }

        // create a div outside of the visible area and fill it with the selected text.
        var bodyElement = document.getElementsByTagName('body')[0];
        var newdiv = document.createElement('div');
        newdiv.style.position = 'absolute';
        newdiv.style.left = '-99999px';
        bodyElement.appendChild(newdiv);
        newdiv.appendChild(selection.getRangeAt(0).cloneContents());

        // we need a <pre> tag workaround.
        // otherwise the text inside "pre" loses all the line breaks!
        if (selection.getRangeAt(0).commonAncestorContainer.nodeName === 'PRE' || selection.getRangeAt(0).commonAncestorContainer.nodeName === 'CODE') {
            newdiv.innerHTML = "<pre>" + newdiv.innerHTML + "</pre>";
        }

        var url = document.location.href;
        newdiv.innerHTML += '<br />'
            + '来源: 8yyy&#39;s blog<br />'
            + '文章作者: 8yyy<br />'
            + '文章链接: <a href="' + url + '">' + url + '</a><br />'
            + '本文章著作权归作者所有，任何形式的转载都请注明出处。';

        selection.selectAllChildren(newdiv);
        window.setTimeout(function () {bodyElement.removeChild(newdiv);}, 200);
    });
</script>


<!-- 代码块功能依赖 -->
<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/8yyy/8yyy.github.io/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/8yyy/8yyy.github.io/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/8yyy/8yyy.github.io/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/8yyy/8yyy.github.io/libs/codeBlock/codeShrink.js"></script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="https://cdn.jsdelivr.net/gh/8yyy/8yyy.github.io/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/8yyy/8yyy.github.io/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="7668596917"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="https://cdn.jsdelivr.net/gh/8yyy/8yyy.github.io/libs/aplayer/APlayer.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/8yyy/8yyy.github.io/libs/aplayer/Meting.min.js"></script>

    

    <div class="container row center-align"
         style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2019-2023</span>
            
            <a href="/about" target="_blank">8yyy</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
                &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                        class="white-color">281.9k</span>
            
            
            
                
            
            
                <span id="busuanzi_container_site_pv">
                &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;
                    <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
                <span id="busuanzi_container_site_uv">
                &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;
                    <span id="busuanzi_value_site_uv" class="white-color"></span>
            </span>
            
            <br>

            <!-- 运行天数提醒. -->
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/8yyy" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:1410868939@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=1410868939" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 1410868939" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="https://cdn.jsdelivr.net/gh/8yyy/8yyy.github.io/libs/materialize/materialize.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/8yyy/8yyy.github.io/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/8yyy/8yyy.github.io/libs/aos/aos.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/8yyy/8yyy.github.io/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/8yyy/8yyy.github.io/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/8yyy/8yyy.github.io/js/matery.js"></script>

    

    

    <!-- 雪花特效 -->
    

    <!-- 鼠标星星特效 -->
    

     
        <script src="https://ssl.captcha.qq.com/TCaptcha.js"></script>
        <script src="https://cdn.jsdelivr.net/gh/8yyy/8yyy.github.io/libs/others/TencentCaptcha.js"></script>
        <button id="TencentCaptcha" data-appid="xxxxxxxxxx" data-cbfn="callback" type="button" hidden></button>
    

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="https://cdn.jsdelivr.net/gh/8yyy/8yyy.github.io/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="https://cdn.jsdelivr.net/gh/8yyy/8yyy.github.io/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <!--腾讯兔小巢-->
    
    

    

    

    
    <script src="https://cdn.jsdelivr.net/gh/8yyy/8yyy.github.io/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
