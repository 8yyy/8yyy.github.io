<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="刘铁猛《C#语言入门详解》笔记, 8yyy&#39;s blog">
    <meta name="description" content="0. 导读根据B站视频刘铁猛《C#语言入门详解》做的笔记。
课程内容
完整讲述C#语言在实际软件开发中的应用
采用知识讲述加实际程序的形式

C#语言简介怎样编写程序和程序语言的选择
​    编辑 -&amp;gt; 编译 -&amp;gt; 调试 -&amp;">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>刘铁猛《C#语言入门详解》笔记 | 8yyy&#39;s blog</title>
    <link rel="icon" type="image/png" href="https://cdn.jsdelivr.net/gh/8yyy/8yyy.github.io/favicon.png">

    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/8yyy/8yyy.github.io/libs/awesome/css/all.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/8yyy/8yyy.github.io/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/8yyy/8yyy.github.io/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/8yyy/8yyy.github.io/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/8yyy/8yyy.github.io/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/8yyy/8yyy.github.io/css/matery.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/8yyy/8yyy.github.io/css/my.css">

    <script src="https://cdn.jsdelivr.net/gh/8yyy/8yyy.github.io/libs/jquery/jquery-3.6.0.min.js"></script>

<meta name="generator" content="Hexo 6.3.0"></head>




<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="https://cdn.jsdelivr.net/gh/8yyy/8yyy.github.io/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">8yyy&#39;s blog</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="https://cdn.jsdelivr.net/gh/8yyy/8yyy.github.io/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">8yyy&#39;s blog</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/blinkfox/hexo-theme-matery" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/blinkfox/hexo-theme-matery" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('https://cdn.jsdelivr.net/gh/8yyy/8yyy.github.io/medias/featureimages/12.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">刘铁猛《C#语言入门详解》笔记</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/8yyy/8yyy.github.io/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/CSharp/">
                                <span class="chip bg-color">CSharp</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2022-10-02
                </div>
                

                

                

                

                
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/8yyy/8yyy.github.io/libs/prism/prism.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h2 id="0-导读"><a href="#0-导读" class="headerlink" title="0. 导读"></a>0. 导读</h2><p>根据<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV13b411b7Ht?spm_id_from=333.788.top_right_bar_window_custom_collection.content.click&vd_source=794a7fc718885ad84490c05351dcf216">B站视频</a>刘铁猛《C#语言入门详解》做的笔记。</p>
<h3 id="课程内容"><a href="#课程内容" class="headerlink" title="课程内容"></a>课程内容</h3><ul>
<li>完整讲述C#语言在实际软件开发中的应用</li>
<li>采用知识讲述加实际程序的形式</li>
</ul>
<h3 id="C-语言简介"><a href="#C-语言简介" class="headerlink" title="C#语言简介"></a>C#语言简介</h3><p><strong>怎样编写程序和程序语言的选择</strong></p>
<p>​    编辑 -&gt; 编译 -&gt; 调试 -&gt; 发布</p>
<p><strong>编程的学习路径</strong></p>
<ul>
<li>纵向  ：语言 -&gt; 类库 -&gt; 框架</li>
<li>横向  ：命令行程序，桌面程序，设备（平板/手机）程序，Web（网站/服务）程序，游戏…</li>
</ul>
<p><strong>学习资料</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/visualstudio/get-started/csharp/?view=vs-2022">Visual Studio 教程 | C#</a></li>
<li><a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1H4MFrhR3LOu2a3HaAq2qag">C# Language Specification</a></li>
<li>离线MSDN文档</li>
</ul>
<hr>


<h2 id="1-第一个程序：Hello-World"><a href="#1-第一个程序：Hello-World" class="headerlink" title="1. 第一个程序：Hello,World!"></a>1. 第一个程序：Hello,World!</h2><h3 id="1-1-Solutoin与Project"><a href="#1-1-Solutoin与Project" class="headerlink" title="1.1 Solutoin与Project"></a>1.1 Solutoin与Project</h3><ul>
<li>Solution是针对客户需求的总的<strong>解决方案</strong>。举例：汽车经销商需要一套销售软件</li>
<li>Project(<strong>项目</strong>)解决具体的某个问题</li>
</ul>
<h3 id="1-2-在Console输出Hello-World"><a href="#1-2-在Console输出Hello-World" class="headerlink" title="1.2 在Console输出Hello,World!"></a>1.2 在Console输出Hello,World!</h3><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using System;

namespace test
&#123;
    class Program
    &#123;
        static void Main(string[] args)
        &#123;
            Console.WriteLine(&quot;Hello,World!&quot;);
        &#125;
    &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="1-3-在Windows-Forms输出Hello-World"><a href="#1-3-在Windows-Forms输出Hello-World" class="headerlink" title="1.3 在Windows Forms输出Hello,World!"></a>1.3 在Windows Forms输出Hello,World!</h3><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Windows.Forms;

namespace test
&#123;
    public partial class Form1 : Form
    &#123;
        public Form1()
        &#123;
            InitializeComponent();
        &#125;

        private void buttonShowHello_Click(object sender, EventArgs e)
        &#123;
            textBoxShowHello.Text &#x3D; &quot;Hello,World!&quot;;
        &#125;
    &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="1-4-在WPF输出Hello-World"><a href="#1-4-在WPF输出Hello-World" class="headerlink" title="1.4 在WPF输出Hello,World!"></a>1.4 在WPF输出Hello,World!</h3><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Navigation;
using System.Windows.Shapes;

namespace test
&#123;
    &#x2F;&#x2F;&#x2F; &lt;summary&gt;
    &#x2F;&#x2F;&#x2F; Interaction logic for MainWindow.xaml
    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;
    public partial class MainWindow : Window
    &#123;
        public MainWindow()
        &#123;
            InitializeComponent();
        &#125;
       
        private void ButtonShowHello_Click(object sender, RoutedEventArgs e)
        &#123;
            textBoxShowHello.Text &#x3D; &quot;Hello,World!&quot;;
        &#125;
    &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="1-5-在ASP-NET-Web-Forms输出Hello-World"><a href="#1-5-在ASP-NET-Web-Forms输出Hello-World" class="headerlink" title="1.5 在ASP.NET Web Forms输出Hello,World!"></a>1.5 在ASP.NET Web Forms输出Hello,World!</h3><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">&lt;%@ Page Language&#x3D;&quot;C#&quot; AutoEventWireup&#x3D;&quot;true&quot; CodeBehind&#x3D;&quot;Default.aspx.cs&quot; Inherits&#x3D;&quot;WebApplication1.Default&quot; %&gt;

&lt;!DOCTYPE html&gt;

&lt;html xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;1999&#x2F;xhtml&quot;&gt;
&lt;head runat&#x3D;&quot;server&quot;&gt;
&lt;meta http-equiv&#x3D;&quot;Content-Type&quot; content&#x3D;&quot;text&#x2F;html; charset&#x3D;utf-8&quot;&#x2F;&gt;
    &lt;title&gt;&lt;&#x2F;title&gt;
&lt;&#x2F;head&gt;
&lt;body&gt;
   &lt;h1&gt;Hello,World!&lt;&#x2F;h1&gt;
&lt;&#x2F;body&gt;
&lt;&#x2F;html&gt;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="1-6-在ASP-NET-MVC输出Hello-World"><a href="#1-6-在ASP-NET-MVC输出Hello-World" class="headerlink" title="1.6 在ASP.NET MVC输出Hello,World!"></a>1.6 在ASP.NET MVC输出Hello,World!</h3><p>一种架构，取代了Web Forms.</p>
<p>将.NET Framework框加版本,设置为4.5或者4.5以上版本</p>
<p>views -&gt; Home -&gt; Index.cshtml  <code>&lt;h2&gt;Hello,World!&lt;/h2&gt;</code></p>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">@&#123;
    ViewBag.Title &#x3D; &quot;Home Page&quot;;
&#125;

&lt;h2&gt;Hello,World!&lt;&#x2F;h2&gt;

&lt;div class&#x3D;&quot;jumbotron&quot;&gt;
    &lt;h1&gt;ASP.NET&lt;&#x2F;h1&gt;
    &lt;p class&#x3D;&quot;lead&quot;&gt;ASP.NET is a free web framework for building great Web sites and Web applications using HTML, CSS and JavaScript.&lt;&#x2F;p&gt;
    &lt;p&gt;&lt;a href&#x3D;&quot;https:&#x2F;&#x2F;asp.net&quot; class&#x3D;&quot;btn btn-primary btn-lg&quot;&gt;Learn more &amp;raquo;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;

&lt;div class&#x3D;&quot;row&quot;&gt;
    &lt;div class&#x3D;&quot;col-md-4&quot;&gt;
        &lt;h2&gt;Getting started&lt;&#x2F;h2&gt;
        &lt;p&gt;
            ASP.NET MVC gives you a powerful, patterns-based way to build dynamic websites that
            enables a clean separation of concerns and gives you full control over markup
            for enjoyable, agile development.
        &lt;&#x2F;p&gt;
        &lt;p&gt;&lt;a class&#x3D;&quot;btn btn-default&quot; href&#x3D;&quot;https:&#x2F;&#x2F;go.microsoft.com&#x2F;fwlink&#x2F;?LinkId&#x3D;301865&quot;&gt;Learn more &amp;raquo;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
    &lt;&#x2F;div&gt;
    &lt;div class&#x3D;&quot;col-md-4&quot;&gt;
        &lt;h2&gt;Get more libraries&lt;&#x2F;h2&gt;
        &lt;p&gt;NuGet is a free Visual Studio extension that makes it easy to add, remove, and update libraries and tools in Visual Studio projects.&lt;&#x2F;p&gt;
        &lt;p&gt;&lt;a class&#x3D;&quot;btn btn-default&quot; href&#x3D;&quot;https:&#x2F;&#x2F;go.microsoft.com&#x2F;fwlink&#x2F;?LinkId&#x3D;301866&quot;&gt;Learn more &amp;raquo;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
    &lt;&#x2F;div&gt;
    &lt;div class&#x3D;&quot;col-md-4&quot;&gt;
        &lt;h2&gt;Web Hosting&lt;&#x2F;h2&gt;
        &lt;p&gt;You can easily find a web hosting company that offers the right mix of features and price for your applications.&lt;&#x2F;p&gt;
        &lt;p&gt;&lt;a class&#x3D;&quot;btn btn-default&quot; href&#x3D;&quot;https:&#x2F;&#x2F;go.microsoft.com&#x2F;fwlink&#x2F;?LinkId&#x3D;301867&quot;&gt;Learn more &amp;raquo;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
    &lt;&#x2F;div&gt;
&lt;&#x2F;div&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="1-7-在Azure-Cloud-Service输出Hello-World"><a href="#1-7-在Azure-Cloud-Service输出Hello-World" class="headerlink" title="1.7 在Azure Cloud Service输出Hello,World!"></a>1.7 在Azure Cloud Service输出Hello,World!</h3><ul>
<li>将ASP.NET Web角色添加到云服务器解决方案</li>
<li>MVC</li>
<li>![image-20220906103230967](G:\8yyy’s blog\source\images\刘铁猛《C-语言入门详解》笔记\image-20220906103230967.png)</li>
</ul>
<p>和6）一样views -&gt; Home -&gt; Index.cshtml  <code>&lt;h2&gt;Hello,World!&lt;/h2&gt;</code></p>
<p>老版本的VS需要启动云平台模拟器运行程序</p>
<h3 id="1-8-在Workflow输出Hello-World"><a href="#1-8-在Workflow输出Hello-World" class="headerlink" title="1.8 在Workflow输出Hello,World!"></a>1.8 在Workflow输出Hello,World!</h3><p>搜索工作流</p>
<p>在工具箱搜索Writeline，然后在Writeline里输入<code>“Hello,World!”</code></p>
<h3 id="1-9-在WCF输出Hello-World"><a href="#1-9-在WCF输出Hello-World" class="headerlink" title="1.9 在WCF输出Hello,World!"></a>1.9 在WCF输出Hello,World!</h3><p>第一步，在App_Code -&gt; Iservice.cs里，</p>
<p>大概在20行左右，添加如下代码</p>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">[OperationContract]
	string sayhello();
	&#x2F;&#x2F; TODO: 在此添加您的服务操作<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>第二步，在App_Code -&gt; Service.cs里，</p>
<p>在public class Service : IService中的IService，Ctrl+.，添加接口</p>
<p>然后在底部会自动添加如下代码</p>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public string sayhello()
    &#123;
        throw new NotImplementedException();
    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>将该代码改为如下代码即可</p>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public string sayhello()
    &#123;
		return &quot;Hello,World!&quot;;
    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<hr>


<h2 id="2-初识类与空间名称"><a href="#2-初识类与空间名称" class="headerlink" title="2. 初识类与空间名称"></a>2. 初识类与空间名称</h2><h3 id="2-1-剖析Hello，World程序"><a href="#2-1-剖析Hello，World程序" class="headerlink" title="2.1 剖析Hello，World程序"></a>2.1 剖析Hello，World程序</h3><ul>
<li><p>初识类（class）与空间名称（namespace）</p>
<ul>
<li>类为<img src="/.com//Users\8y\AppData\Roaming\Typora\typora-user-images\image-20220906202819812.png" alt="image-20220906202819812">的样子，空间名称为{ }</li>
</ul>
</li>
<li><p>类是构成程序的主体</p>
</li>
<li><p>名称空间以树型结构组织类（和其他类型）</p>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using System;

namespace test
&#123;
    class Program
    &#123;
        static void Main(string[] args)
        &#123;
            Console.WriteLine(&quot;Hello,World!&quot;);
        &#125;
    &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>程序中有2个类，一个是Program(自己写的)，一个是Console(引用的类)</p>
</li>
</ul>
<h3 id="2-2-类库的引用"><a href="#2-2-类库的引用" class="headerlink" title="2.2 类库的引用"></a>2.2 类库的引用</h3><p>Ctrl+Alt+J 对象浏览器，VS会自动根据加载的不同的模板，引用不同的类库</p>
<h4 id="2-2-1-类库引用是使用名称空间的物理基础"><a href="#2-2-1-类库引用是使用名称空间的物理基础" class="headerlink" title="2.2.1 类库引用是使用名称空间的物理基础"></a>2.2.1 类库引用是使用名称空间的物理基础</h4><ul>
<li>不同技术类型的项目会默认引用不同的类库</li>
</ul>
<h4 id="2-2-2-DLL应用（黑盒引用，无源代码）"><a href="#2-2-2-DLL应用（黑盒引用，无源代码）" class="headerlink" title="2.2.2 DLL应用（黑盒引用，无源代码）"></a>2.2.2 DLL应用（黑盒引用，无源代码）</h4><p>右键依赖项 -&gt; 添加项目引用 -&gt;浏览</p>
<ul>
<li>黑盒引用的缺点是如果代码有错，你就只能把错误告诉编写类库的人，让他改之后编译再重新把DLL发给你</li>
<li>意味存在着很强的依赖关系</li>
<li>NuGet简介<ul>
<li>Nuget是一个VS的扩展插件。我们在使用VS开发时，Nuget能把在项目中添加、移除和更新引用的工作变得更加快捷方便。</li>
<li>右键引用 -&gt; 管理NuGet程序包</li>
</ul>
</li>
</ul>
<h4 id="2-2-3项目引用（白盒引用，有源代码）"><a href="#2-2-3项目引用（白盒引用，有源代码）" class="headerlink" title="2.2.3项目引用（白盒引用，有源代码）"></a>2.2.3项目引用（白盒引用，有源代码）</h4><ul>
<li><p>一个项目(Project)可以隶属于不同的解决方案(Solution)</p>
</li>
<li><p>现在解决方案test下有一个项目test，里面有一个类Calculator，类里的主要代码如下：</p>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using System;

namespace Tools
&#123;
    public class Calculator
    &#123;
        public static double Add(double a,double b)
        &#123;
            return a + b;
        &#125;

        public static double Sub(double a, double b)
        &#123;
            return a - b - 10;
        &#125;
    &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>然后打开解决方案Sample，里面有个项目sample，右键解决方案sample -&gt; 添加 -&gt; 添加先有项，找到上面的test.csproj</p>
<p>之后如下图所示</p>
<p><img src="/.com//Users\8y\AppData\Roaming\Typora\typora-user-images\image-20220906202018586.png" alt="image-20220906202018586"></p>
</li>
<li><p>这样一个解决方案就有2个项目了，一个叫sample，一个叫test，之后右键在项目sample右键引用，发现test已经在那了</p>
</li>
<li><p><img src="/.com//Users\8y\AppData\Roaming\Typora\typora-user-images\image-20220906202251533.png" alt="image-20220906202251533"></p>
</li>
</ul>
<p><img src="/.com//Users\8y\AppData\Roaming\Typora\typora-user-images\image-20220906202330829.png" alt="image-20220906202330829"></p>
<ul>
<li>可以看到test在引用里了(底部)</li>
</ul>
<p><code>我这里因为一个项目指向“netcoreapp3.1”，一个项目指向“.NETFramework,Version=v4.7.2”，所以不能引用            </code></p>
<ul>
<li>我这里重新创建了一个项目，名为sample2</li>
<li><img src="/.com//Users\8y\AppData\Roaming\Typora\typora-user-images\image-20220906203222664.png" alt="image-20220906203222664"></li>
<li>将sample2的Program.cs的代码改为上述test代码，然后重新打开sample1</li>
<li>我发现这样虽然能正常引用类库了，但是因为是.net framework框架，导致不能正常显示console的结果</li>
<li>使用.net core console</li>
<li><img src="/.com//Users\8y\AppData\Roaming\Typora\typora-user-images\image-20220906204737434.png" alt="image-20220906204737434"></li>
<li>后来我发现都不行，因为我做了一个很大的错误，我都是新建了两个.net framework或者是两个.net core console，其中一个得是类库(classlibrary),如下</li>
<li><img src="/.com//Users\8y\AppData\Roaming\Typora\typora-user-images\image-20220906210110681.png" alt="image-20220906210110681"></li>
<li>正常运行了</li>
<li><img src="/.com//Users\8y\AppData\Roaming\Typora\typora-user-images\image-20220906210510077.png" alt="image-20220906210510077"></li>
<li>发现结果是错的，这时我们需要在如下代码进行断点调试</li>
<li><img src="/.com//Users\8y\AppData\Roaming\Typora\typora-user-images\image-20220906210557240.png" alt="image-20220906210557240"></li>
<li>按<code>F5</code>开始调试</li>
<li><img src="/.com//Users\8y\AppData\Roaming\Typora\typora-user-images\image-20220906210733333.png" alt="image-20220906210733333"></li>
<li>result结果为0</li>
<li>之后按<code>F11</code>逐语句调试</li>
<li>然后执行指针就进入到了类库里的Sub函数，然后就可以发现这个简单的错误了</li>
<li><img src="/.com//Users\8y\AppData\Roaming\Typora\typora-user-images\image-20220906210838383.png" alt="image-20220906210838383"></li>
</ul>
<p><strong>尝试直接在解决方案里写一个类库，然后引用</strong></p>
<ul>
<li><p>右键解决方案，添加一个新项目</p>
</li>
<li><p><img src="/.com//Users\8y\AppData\Roaming\Typora\typora-user-images\image-20220906211748154.png" alt="image-20220906211748154"></p>
</li>
<li><p>类库(classlibrary)编译出来的结果就是一个DLL文件</p>
</li>
<li><p>修改如下，你会发现类库默认的类就是public类型的</p>
</li>
<li><p><img src="/.com//Users\8y\AppData\Roaming\Typora\typora-user-images\image-20220906212122712.png" alt="image-20220906212122712"></p>
</li>
<li><p>编写代码如下：</p>
</li>
<li><p>```c#<br>using System;</p>
<p>namespace Tools<br>{</p>
<pre><code>public class Calculator
&#123;
    public static double Add(double a, double b)
    &#123;
        return a + b;
    &#125;

    public static double Sub(double a, double b)
    &#123;
        return a - b - 10;
    &#125;

    public static double Mul(double a, double b)
    &#123;
        return a * b;
    &#125;

    public static double Div(double a, double b)
    &#123;
        if (b == 0)
        &#123;
            return double.PositiveInfinity; //无穷大
        &#125;
        else
        &#123;
            return a / b;
        &#125;
           
    &#125;
&#125;
</code></pre>
<p>}</p>
<pre class="line-numbers language-none"><code class="language-none">
- 之后在项目sample添加项目引用，然后在Program.cs写点代码调试，如下所示：

- ![image-20220906212511088](C:\Users\8y\AppData\Roaming\Typora\typora-user-images\image-20220906212511088.png)

#### 2.2.4依赖关系

- 类（或对象）之间的耦合关系
- 优秀的程序追求&#96;高内聚，低耦合&#96;
  - 高内聚：一些数据、功能，该属于哪个类就该放到哪个类里面
  - 低耦合：类和类之间的依赖关系尽可能低
  - 教学程序往往会违反这个原则

- UML（通用建模语言）类图
  - 用来展示类和类之间的关系
  - ![image-20220906213301526](C:\Users\8y\AppData\Roaming\Typora\typora-user-images\image-20220906213301526.png)
  - 就比如&#96;hello,world&#96;这个来说，我们自己写的类叫&#96;Program类&#96;，里面有一个方法叫&#96;Main()方法&#96;，然后我们在&#96;Main()方法&#96;里调用了&#96;Console类&#96;里面的&#96;WriteLine()方法&#96;



&lt;hr&gt;


## 3. 类、对象、类成员简介

&lt;font size&#x3D;5&gt;类（class）是现实世界事物的模型&lt;&#x2F;font&gt;

- 类是对现实世界事物进行抽象所得到的结果
  - 事物包括&quot;物质&quot;(实体)与&quot;运动&quot;(逻辑)
  - 建模是一个去伪存真，由表及里的过程

![image-20220907093936767](C:\Users\8y\AppData\Roaming\Typora\typora-user-images\image-20220907093936767.png)

- 飞行员依赖战斗机

### 3.1 类与对象的关系

- 对象也叫实例，是类经过&quot;实例化&quot;后得到的内存中的实体
  - 对象和实例是一回事
  - &quot;飞机&quot;与&quot;一架飞机&quot;有何区别？天上有(一架)飞机——必须是实例飞，概念是不能飞的
  - 有些类是不能实例化的，比如&quot;数学&quot;(Math class)，我们不能说&quot;一个数字&quot;
  - &quot;可数名词与不可数名词&quot;
- 依照类，我们可以创建对象，这就是&#96;实例化&#96;
  - 现实世界中常称&#96;对象&#96;，程序世界中常称&#96;实例&#96;
  - 两者并无太大区别，常常混用，初学者不必迷惑
- 使用&#96;new&#96;操作符创建类的实例

- 引用变量与实例的关系
  - 孩子(引用变量)与气球(实例)
  - 气球不一定有孩子&#96;牵着&#96;(相当于赋值符号&#x3D;)
  - 多个孩子可以使用各自的绳子牵着同一个气球，也可以都通过一根绳子牵着气球(引用变量指向同一个地址)

&#96;&#96;&#96;c#
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace ClassAndInstance
&#123;
    class Program
    &#123;
        static void Main(string[] args)
        &#123;
            &#x2F;&#x2F;new Form();
            &#x2F;&#x2F;创建了一个气球，但是没有孩子牵着，就飞走了，内存垃圾收集器很快收回去了，释放掉了

            Form myForm1;&#x2F;&#x2F;第一个引用变量，相当于第一个孩子
            Form myForm2;&#x2F;&#x2F;第二个引用变量，相当于第一个孩子
            myForm1 &#x3D; new Form();
            myForm2 &#x3D; myForm1;    &#x2F;&#x2F;两个引用变量指向同一个对象
            myForm1.Text &#x3D; &quot;My Form&quot;;
            myForm2.Text &#x3D; &quot;I changed it!&quot;;
            myForm1.ShowDialog();
        &#125;
    &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
<p>运行结果如下：</p>
<p><img src="/.com//Users\8y\AppData\Roaming\Typora\typora-user-images\image-20220907101852929.png" alt="image-20220907101852929"></p>
<h3 id="3-2-类的三大成员"><a href="#3-2-类的三大成员" class="headerlink" title="3.2 类的三大成员"></a>3.2 类的三大成员</h3><ul>
<li><p>属性（Property）</p>
<ul>
<li>存储数据，组合起来表示类或对象当前的状态</li>
</ul>
</li>
<li><p>方法（Method）</p>
<ul>
<li>由C语言中的函数（Function）进化而来，表示类或对象”能做什么”</li>
<li>工作中90%的时间是在与方法打交道，因为它是”真正做事”、”构成逻辑”的成员</li>
</ul>
</li>
<li><p>事件（Event）</p>
<ul>
<li>类或对象通知其它类或对象的机制，为C#所特有（Java通过其它办法实现这个机制）</li>
<li>善用事件机制非常重要</li>
</ul>
</li>
<li><p>使用MSDN文档。在VS中，你把光标定位到某个类上，按<code>F1</code>，会自动在浏览器上打开MSDN文档，显示这个类的详细信息</p>
</li>
<li><p>某些特殊类或对象在成员方面侧重点不同</p>
<ul>
<li>模型类或对象重在<strong>属性</strong>，如EF（Entity Framework）</li>
<li>工具类或对象重在<strong>方法</strong>，如Math，Console</li>
<li>通知类或对象重在<strong>事件</strong>，如各种Timer</li>
</ul>
</li>
<li><p>接下来开始写一个实例程序，使用EF数据模型</p>
</li>
<li><p>使用.net framework框架，我这里用的4.72的</p>
</li>
<li><p>需要用到SQL Server，我这里用的是SSMS 18</p>
</li>
<li><p>回到VS，右击项目，添加新建项，如下图所示</p>
</li>
<li><p><img src="/.com//Users\8y\AppData\Roaming\Typora\typora-user-images\image-20220907105639515.png" alt="image-20220907105639515"></p>
</li>
<li><p>添加，选择来自数据库的EF设计器</p>
</li>
<li><p><img src="/.com//Users\8y\AppData\Roaming\Typora\typora-user-images\image-20220907105723149.png" alt="image-20220907105723149"></p>
</li>
<li><p>之后一步一步，跟着视频差不多，最后我选了两张表，结果如下</p>
</li>
<li><p><img src="/.com//Users\8y\AppData\Roaming\Typora\typora-user-images\image-20220907105846979.png" alt="image-20220907105846979"></p>
</li>
<li><p>```c#<br>using System;<br>using System.Collections.Generic;<br>using System.Linq;<br>using System.Text;<br>using System.Threading.Tasks;<br>using System.Windows.Forms;</p>
<p>namespace ClassAndInstance<br>{</p>
<pre><code>class Program
&#123;
    static void Main(string[] args)
    &#123;
        ScEntities proxy = new ScEntities();
        //Sc为数据库名，这里数据库名+Entities
        
        foreach (Sc_Student p in proxy.Sc_Student)
        //Sc_Student为Sc数据库里的一张表
        &#123;
            Console.WriteLine(p.Sname);
            //Sname为Sc_Student里的一个字段名
        &#125;
        //这里的foreach用于显示Sname字段的记录
        Console.WriteLine(&quot;=============&quot;);
        Console.WriteLine(proxy.Sc_Student.Count());
        //显示记录数
    &#125;
&#125;
</code></pre>
<p>}</p>
<pre class="line-numbers language-none"><code class="language-none">
- &#96;&#96;&#96;
  cw+tab+tab，可以直接打出Console.WriteLine<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li>
<li><p>运行结果如下：</p>
</li>
<li><p><img src="/.com//Users\8y\AppData\Roaming\Typora\typora-user-images\image-20220907110953735.png" alt="image-20220907110953735"></p>
</li>
<li><p>下面举例以方法为侧重的类Math</p>
</li>
<li><p>```c#<br>using System;<br>using System.Collections.Generic;<br>using System.Linq;<br>using System.Text;<br>using System.Threading.Tasks;<br>using System.Windows.Forms;</p>
<p>namespace ClassAndInstance<br>{</p>
<pre><code>class Program
&#123;
    static void Main(string[] args)
    &#123;
        double x = Math.Sqrt(4);
        double y = Math.Pow(2, 3);
        Console.WriteLine(&quot;x = &quot;+x+&quot;\ny = &quot;+y );
    &#125;
&#125;
</code></pre>
<p>}</p>
<pre class="line-numbers language-none"><code class="language-none">
- 运行结果如下：

- &#96;&#96;&#96;
  x &#x3D; 2
  y &#x3D; 8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>下面举例以事件为侧重的类Timer</p>
</li>
<li><p>使用WPF应用，为了跟着视频，选择.net framework框架的</p>
</li>
<li><p><img src="/.com//Users\8y\AppData\Roaming\Typora\typora-user-images\image-20220907112003427.png" alt="image-20220907112003427"></p>
</li>
<li><p>新建后之后，拖入一个textbox，命名为timeTextBox</p>
</li>
<li><p>之后进入MainWindow.xaml.cs，编写代码如下：</p>
</li>
<li><p>```c#<br>using System;<br>using System.Collections.Generic;<br>using System.Linq;<br>using System.Text;<br>using System.Threading.Tasks;<br>using System.Windows;<br>using System.Windows.Controls;<br>using System.Windows.Data;<br>using System.Windows.Documents;<br>using System.Windows.Input;<br>using System.Windows.Media;<br>using System.Windows.Media.Imaging;<br>using System.Windows.Navigation;<br>using System.Windows.Shapes;<br>using System.Windows.Threading; //多线程</p>
<p>namespace EventSample<br>{</p>
<pre><code>/// &lt;summary&gt;
/// MainWindow.xaml 的交互逻辑
/// &lt;/summary&gt;
public partial class MainWindow : Window
&#123;
    public MainWindow()
    &#123;
        InitializeComponent();
        DispatcherTimer timer = new DispatcherTimer();
        //设置计时器刻度之间的间隔为1s
        timer.Interval = TimeSpan.FromSeconds(1);
        //事件处理器
        timer.Tick += Timer_Tick;
        timer.Start();
    &#125;

    private void Timer_Tick(object sender, EventArgs e)
    &#123;
        this.timeTextBox.Text = DateTime.Now.ToString();
    &#125;
&#125;
</code></pre>
<p>}</p>
<pre class="line-numbers language-none"><code class="language-none">
  

- 运行结果如下：

- ![image-20220907113603979](C:\Users\8y\AppData\Roaming\Typora\typora-user-images\image-20220907113603979.png)

### 3.3 静态成员与实例成员

- 静态（Static）成员在语义上表示它是&quot;类的成员&quot;
  - 例如&#96;人类&#96;可以看作一个&#96;类&#96;，&#96;人类的数量&#96;可以看作这个类的&#96;静态成员&#96;
  - &#96;WriteLine&#96;是属于&#96;Console&#96;这个类的静态方法
- 实例（非静态）成员在语义上表示它是&quot;对象的成员&quot;
  - 例如&#96;某个人&#96;有&#96;身高，体重&#96;，某个人是对象，它有实例成员身高和体重
- 绑定（Binding）指的是编译器如何把成员与类或对象关联起来
  - 不可小觑的&#96;.&#96;操作符——成员访问

&lt;hr&gt;


## 4. C#语言基本元素概览，初识类型、变量与方法，算法简介

### 4.1 构成C#语言的基本元素

1. 关键字（Keyword）

2. 操作符（Operator）

3. 标识符（Identifier）

   - 中文也可以用做标识符（只不过不建议这么使用）
   - 驼峰命名法：变量名等
   - 帕斯卡命名卡：类名，名称空间等

4. 标点符号

5. 文本

   - char 卡尔
   - 只有引用类型才能null（空）

   &lt;font size&#x3D;5&gt;&#96;以上五种统称为标记（Token）&#96;&lt;&#x2F;font&gt;

6. 注释与空白

   - ctrl+k+d，代码格式化

### 4.2 初识类型、变量与方法

1. 初识类型（Type）

   - 亦称数据类型（Data Type）

   - &#96;&#96;&#96;c#
     var x &#x3D; 3;         Console.WriteLine(x.GetType().Name);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p> var 赋值的变量C#会自动推算出数据类型</p>
</li>
</ul>
<ol start="2">
<li><p>变量是存放数据的地方，简称”数据“</p>
<ul>
<li>变量的声明</li>
<li>变量的使用</li>
</ul>
</li>
<li><p>方法（旧城函数）是处理数据的逻辑，又称”算法“</p>
<ul>
<li>方法的声明</li>
<li>方法的调用</li>
</ul>
</li>
<li><p>程序=数据+算法</p>
<ul>
<li>有了变量和方法就可以写有意义的程序了</li>
<li>ctrl+k+c 快速注释</li>
<li>ctrl+k+u 快速解注释</li>
</ul>
</li>
<li><p>简单算法，计算1到100的和</p>
<ul>
<li><p>第一种使用循环，代码如下</p>
</li>
<li><p>```c#<br>using System;</p>
<p>namespace sample<br>{</p>
<pre><code>class Program
&#123;
    static void Main(string[] args)
    &#123;
        Calculator c = new Calculator();
        Console.WriteLine(c.SumFrom1ToX(100));
    &#125;
&#125;

class Calculator
&#123;
    public int SumFrom1ToX(int x)
    &#123;
        int res = 0;
        for (int i = 1; i &lt; x+1; i++)
        &#123;
            res += i;
        &#125;
        return res;
    &#125;
&#125;
</code></pre>
<p>}</p>
<pre class="line-numbers language-none"><code class="language-none">
- 第二种使用递归

- &#96;&#96;&#96;c#
  using System;
  
  namespace sample
  &#123;
      class Program
      &#123;
          static void Main(string[] args)
          &#123;
              Calculator c &#x3D; new Calculator();
              Console.WriteLine(c.SumFrom1ToX(100));
          &#125;
      &#125;
  
      class Calculator
      &#123;
          public int SumFrom1ToX(int x)
          &#123;
              if (x &#x3D;&#x3D; 1)
              &#123;
                  return 1;
              &#125;
              else
              &#123;
                  int result &#x3D; x + SumFrom1ToX(x - 1);
                  return result;
              &#125;
          &#125;
      &#125;
  &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
</li>
<li><p>汉诺塔问题</p>
<p>主要分为A,B,C杆，将A杆中的盘子全部移至C杆，分为三部：</p>
<p>(1)以C杆为中介，从A杆将1至n-1号盘移至B杆；</p>
<p>(2)将A杆中剩下的第n号盘移至C杆；</p>
<p>(3)以A杆为中介；从B杆将1至n-1号盘移至C杆。</p>
</li>
</ol>
<p>代码如下：</p>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using System;

namespace sample
&#123;
    class Program
    &#123;
        static void Main(string[] args)
        &#123;
            Hanoi(3, &#39;A&#39;, &#39;B&#39;, &#39;C&#39;);
        &#125;

        public static void Hanoi(int n,char a,char b,char c)
        &#123;
            if (n &#x3D;&#x3D; 1)
            &#123;
                Console.WriteLine($&quot;Move disk &#123;n&#125; from &#123;a&#125; to &#123;c&#125;&quot;);
            &#125;
            else
            &#123;
                &#x2F;&#x2F;第一步，以C杆为中介，从A杆将1至n-1号盘移至B杆
                Hanoi(n - 1, a, c, b);
                &#x2F;&#x2F;第二步，将A杆中剩下的第n号盘移至C杆
                Console.WriteLine($&quot;Move disk &#123;n&#125; from &#123;a&#125; to &#123;c&#125;&quot;);
                &#x2F;&#x2F;第三步，以A杆为中介；从B杆将1至n-1号盘移至C杆
                Hanoi(n - 1, b, a, c);
            &#125;
        &#125;
    &#125;

   
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<hr>




<h2 id="5-详解类型、变量和对象"><a href="#5-详解类型、变量和对象" class="headerlink" title="5. 详解类型、变量和对象"></a>5. 详解类型、变量和对象</h2><h3 id="5-1-什么是类型（Type）"><a href="#5-1-什么是类型（Type）" class="headerlink" title="5.1 什么是类型（Type）"></a>5.1 什么是类型（Type）</h3><ul>
<li>数据结构是类型的延申</li>
<li>又名数据类型（Data Type）<ul>
<li>性质相同的值的集合，配备了一系列专门针对这些值的操作</li>
<li>是数据在内存中存储时的“符号”</li>
<li>小内存容纳大尺寸数据会发生丢失精准度、发生错误</li>
<li>大内存容纳小尺寸数据会导致浪费</li>
<li>编程语言的数据类型与数据的数据类型不完全相同<ul>
<li>例如3/4在编程语言中结果为0，在数学中为0.75</li>
</ul>
</li>
</ul>
</li>
<li>强类型编程语言与弱类型编程语言<ul>
<li>数据受到数据类型的约束，这门编程语言就是强类型编程语言</li>
<li>C#是一种强类型编程语言</li>
<li><code>dynamic</code>，C#对弱类型/动态类型的模仿</li>
</ul>
</li>
</ul>
<h3 id="5-2-类型在C-语言中的作用"><a href="#5-2-类型在C-语言中的作用" class="headerlink" title="5.2 类型在C#语言中的作用"></a>5.2 类型在C#语言中的作用</h3><ul>
<li><p>一个C#类型中所包含的信息有：</p>
<ul>
<li><p>存储此类型变量所需的内存空间大小</p>
<ul>
<li>int占4个字节，long占8个字节</li>
</ul>
</li>
<li><p>此类型的值可表示的最大、最小值范围</p>
<ul>
<li>例如sbyte 为-128 to 127，占8-bit，最高位为符号位</li>
<li>byte为 0 to 255，占8-bit</li>
</ul>
</li>
<li><p>此类型所包含的成员（如方法、属性、事件等）</p>
</li>
<li><p>此类型由何基类派生而来</p>
<ul>
<li><p>```c#<br>using System;<br>using System.Reflection;<br>using System.Windows.Forms;</p>
<p>namespace sample<br>{</p>
<pre><code> class Program
&#123;
    static void Main(string[] args)
    &#123;
        Type myType = typeof(Form);
        Console.WriteLine(myType.Name);                 //查看类型的名字
        Console.WriteLine(myType.FullName);             //查看类型的全名
        Console.WriteLine(myType.BaseType.FullName);    //查看类型的基类

        PropertyInfo[] pInfos = myType.GetProperties();
        //能够动态的探知程序运行过程中有那些属性
        foreach(var p in pInfos)
        &#123;
            Console.WriteLine(p.Name);
        &#125;

        MethodInfo[] mInfos = myType.GetMethods();
        //能够动态的探知程序运行过程中有那些方法
        foreach (var m in mInfos)
        &#123;
            Console.WriteLine(m.Name);
        &#125;
    &#125;
&#125;
</code></pre>
<p>}</p>
<pre class="line-numbers language-none"><code class="language-none">
    

- 程序运行的时候，此类型的变量分配在内存的什么位置

  - Stack简介

    - 给方法调用
    - Stack比较小，比较快

  - Stack overflow

    - 算法没写好

    - 分配了过多的内存

    - &#96;&#96;&#96;c#
      using System;
      
      namespace StackOverflow
      &#123;
           class Program
          &#123;
              static void Main(string[] args)
              &#123;
                  BadGur bg &#x3D; new BadGur();
                  bg.BadMethod();
              &#125;
          &#125;
      
          class BadGur
          &#123;
              public void BadMethod()
              &#123;
                  int x &#x3D; 100;
                  this.BadMethod();   &#x2F;&#x2F;死循环递归
              &#125;
          &#125;
      &#125;
      <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><p>```c#<br>using System;</p>
<p>namespace StackOverflow<br>{</p>
<pre><code>class Program
&#123;
    //用到指针需要加上unsafe，同时需要在项目 -&gt; 最底部的项目名属性(P) -&gt;生成 -&gt; 允许不安全代码
    static unsafe void Main(string[] args)
    &#123;
        int* p = stackalloc int[9999999];
        //.NET应用程序的默认堆栈大小为1 MB ,为1024*1024，而9999999显然大于这个数字，造成栈溢出
    &#125;
&#125;
</code></pre>
<p>}</p>
<pre class="line-numbers language-none"><code class="language-none">
    

- Heap简介

  - 存储对象，实例放在堆里
  - Heap比Stack大

- 使用Performance Monitor查看进程的堆内存使用量

  - Process（进程），一个程序由硬盘加载到内存之后就形成一个进程

  - &#96;&#96;&#96;c#
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Text;
    using System.Threading.Tasks;
    using System.Windows;
    using System.Windows.Controls;
    using System.Windows.Data;
    using System.Windows.Documents;
    using System.Windows.Input;
    using System.Windows.Media;
    using System.Windows.Media.Imaging;
    using System.Windows.Navigation;
    using System.Windows.Shapes;
    
    namespace HeapSample
    &#123;
        &#x2F;&#x2F;&#x2F; &lt;summary&gt;
        &#x2F;&#x2F;&#x2F; MainWindow.xaml 的交互逻辑
        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;
        public partial class MainWindow : Window
        &#123;
            public MainWindow()
            &#123;
                InitializeComponent();
            &#125;
            List&lt;Window&gt; winList;
            &#x2F;&#x2F;window占用的内存多
            private void Button1_Click(object sender, RoutedEventArgs e)
            &#123;
                winList &#x3D; new List&lt;Window&gt;();
                &#x2F;&#x2F;生成有15000个Window实例的列表
                for (int i &#x3D; 0; i &lt; 15000; i++)
                &#123;
                    Window w &#x3D; new Window();
                    winList.Add(w);
                &#125;
            &#125;
    
            private void Button2_Click(object sender, RoutedEventArgs e)
            &#123;
                winList.Clear();
            &#125;
        &#125;
    &#125;
    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>生成解决方案，ctrl+shift+b</p>
</li>
<li><p>ctrl+r运行，输入perfmon打开性能监视器</p>
</li>
<li><p>点击<code>红色的X号</code>，再点击<code>绿色的+号</code></p>
</li>
<li><p><img src="/.com//Users\8y\AppData\Roaming\Typora\typora-user-images\image-20220908155807969.png" alt="image-20220908155807969"></p>
</li>
<li><p>选择process -&gt; private bytes</p>
</li>
<li><p><img src="/.com//Users\8y\AppData\Roaming\Typora\typora-user-images\image-20220908160109789.png" alt="image-20220908160109789"></p>
</li>
<li><p>独享的已分配的当前字节数就是堆内存</p>
</li>
<li><p>点击<code>添加</code>，然后<code>确定</code></p>
</li>
<li><p>然后回到性能监视器，如下图所示</p>
</li>
<li><p><img src="/.com//Users\8y\AppData\Roaming\Typora\typora-user-images\image-20220908160238140.png" alt="image-20220908160238140"></p>
</li>
<li><p>发现一直在100，原理是已经超过了能表示的最大范围</p>
</li>
<li><p>双击底部的<img src="/.com//Users\8y\AppData\Roaming\Typora\typora-user-images\image-20220908160328957.png" alt="image-20220908160328957"></p>
</li>
<li><p>将图标下垂直比例最大值改为1024</p>
</li>
<li><p>然后回到性能监视器，如下图所示</p>
</li>
<li><p><img src="/.com//Users\8y\AppData\Roaming\Typora\typora-user-images\image-20220908160447751.png" alt="image-20220908160447751"></p>
</li>
<li><p>点击<code>Consume Heap Memory</code>按钮，你会发现性能监视器的图示会立刻往上升</p>
</li>
<li><p>然后点击<code>Release Heap Memory</code>按钮，你会发现性能监视器的图示并不会马上降下来，因为我们的<code>垃圾收集器</code>认为我们现在的内存还很大，不用马上来收集，会找一个时间来收集，如果你等的事件够久，你会发现它还是会降下来</p>
</li>
<li><p>但是在内存收集之前，你连续的点击<code>Consume Heap Memory</code>按钮，内存用量还是会一直上升</p>
</li>
</ul>
</li>
<li><p>关于内存泄露</p>
<ul>
<li>在堆中分配了过多的对象，没有释放</li>
<li>在C#中没有手动释放内存，都是自动释放内存，所以比较安全，不容易造成内存泄漏</li>
</ul>
</li>
</ul>
</li>
<li><p>此类型所允许的操作（运算）</p>
<ul>
<li>```<br>double res1 = 3 / 4;        //0<br>double res2 = 3.0 / 4.0;    //0.75<pre class="line-numbers language-none"><code class="language-none">
      

### 5.3 C#语言的数据类型

#### 5.3.1 C#的五大数据类型

- 类（Classes）：如Windows,Form,Console,String

  - 按&#96;F12&#96;可以转到定义的地方

- 结构体（Structures）:如Int32，Int64，Single，Double

  - int就是一个结构体类型

- 枚举（Enumerations）：如HorizontalAlignment，Visibility

  - 枚举类型，里面的数据都是预定义好的

  - &#96;&#96;&#96;c#
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Text;
    using System.Threading.Tasks;
    using System.Windows.Forms;
    
    namespace ConsoleApp1
    &#123;
        class Program
        &#123;
            static void Main(string[] args)
            &#123;
                Form f &#x3D; new Form();
                f.WindowState &#x3D; FormWindowState.Maximized;
                &#x2F;&#x2F;FormWindowState就是一个枚举类型
                f.ShowDialog();
            &#125;
        &#125;
    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
</li>
<li><p>F12转到定义</p>
</li>
<li><p>```c#<br>using System.Runtime.InteropServices;</p>
<p>namespace System.Windows.Forms<br>{</p>
<pre><code>//
// 摘要:
//     指定窗体窗口的显示方式。
[ComVisible(true)]
public enum FormWindowState
&#123;
    //
    // 摘要:
    //     默认大小的窗口。
    Normal = 0,
    //
    // 摘要:
    //     最小化的窗口中。
    Minimized = 1,
    //
    // 摘要:
    //     最大化的窗口。
    Maximized = 2
&#125;
</code></pre>
<p>}</p>
<pre class="line-numbers language-none"><code class="language-none">
    

- 接口（Interfaces）

- 委托（Delegates）

#### 5.3.2 C#类型的派生谱系

- C#类型的派生谱系是一个树状的系统

- &#96;Object&#96; （根部，基类型）分为&#96;引用类型(Reference Type)&#96; 和 &#96;值类型(Value Type)&#96;，两大数据类型分组
- &#96;引用类型(Reference Type)&#96;分为三大分支
  - 类
  - 接口
  - 委托
- &#96;值类型(Value Type)&#96;分为两大分支
  - 结构体
  - 枚举
- ![image-20220908163836346](C:\Users\8y\AppData\Roaming\Typora\typora-user-images\image-20220908163836346.png)



### 5.4 变量、对象与内存

#### 5.4.1 什么是变量

- 表面上来看，变量的用途是存储数据

- 实际上，&lt;font color&#x3D;blue&gt;变量表示了存储位置，并且每个变量都有一个类型，以决定什么样的值能够存入变量&lt;&#x2F;font&gt;

  - 变量名表示（对应着）变量的值内存中的存储位置
  - 变量类型就是告诉系统从这个存储位置开始数多少个字节，这段字节来保存这个变量的值

- 变量一共有7种

  - 静态变量

  - 实例变量(成员变量，字段)

  - 数组元素

  - 值参数

  - 引用参数

  - 输出形参

  - 局部变量

  - &#96;&#96;&#96;c#
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Text;
    using System.Threading.Tasks;
    using System.Windows.Forms;
    
    namespace ConsoleApp1
    &#123;
        class Program
        &#123;
            static void Main(string[] args)
            &#123;
                int[] arr &#x3D; new int[100];   &#x2F;&#x2F;数组元素
                int x;                      &#x2F;&#x2F;局部变量
            &#125;
        &#125;
    
        class student 
        &#123;
            public static int amount;   &#x2F;&#x2F;静态变量
            public int age;             &#x2F;&#x2F;实例变量
            public double Add(ref double a,out double b,double c)
            &#x2F;&#x2F;a为引用参数，b为输出形参，c为值参数
            &#123;
                b &#x3D; 23;
                return a + b + c;
            &#125;
    
        &#125;
    
    &#125;
    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
</li>
<li><p>侠义的变量指局部变量，因为其它种类的变量都有自己的约定名称</p>
<ul>
<li>简单地讲，局部变量就是方法体（函数体）里声明的变量</li>
</ul>
</li>
<li><p>变量的声明</p>
<ul>
<li><p><font color="blue"> 有效的修饰符组合<del>opt</del> 类型 变量名 初始化器<del>opt</del> </font></p>
</li>
<li><p>```<br>public int a = 100;</p>
<pre class="line-numbers language-none"><code class="language-none">
  - opt表示可有可无的，有效的修饰符组合和初始化器是可选的，类型和变量名是必须的

  - 尽量不要写 &#96;int a&#x3D;100,b&#x3D;200;&#96;这种形式，让代码的可读性变差了

- &lt;font color&#x3D;red&gt;变量是以变量名所对应的内存地址为起点，以其数据类型所要求的存储空间为长度的一块内存区域&lt;&#x2F;font&gt;

#### 5.4.2 值类型的变量

- 值类型没有实例，所谓的“实例”与变量合而为一
- 值类型的变量在内存的存储
- 小端模式，是指数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中
- &#96;ushort us &#x3D; 1000&#96;,占16-bit，换算成二进制是
- &#96;00000011 11101000&#96;
- ![image-20220908193144801](C:\Users\8y\AppData\Roaming\Typora\typora-user-images\image-20220908193144801.png)
- &lt;font color&#x3D;8899##&gt;黄色区域为已经被占用的内存&lt;&#x2F;font&gt;
- &#96;short s&#x3D; -1000&#96;,按位取反+1
  - 00000011 11101000
  - 11111100 00010111 按位取反
  - &#96;11111100 00011000&#96; +1后的结果
- ![image-20220908193716094](C:\Users\8y\AppData\Roaming\Typora\typora-user-images\image-20220908193716094.png)

#### 5.4.3 引用类型的变量与实例

- 引用类型的变量与实例的关系：引用类型变量里存储的数据是对象的地址

- &#96;&#96;&#96;c#
  using System;
  
  namespace test
  &#123;
      class Program
      &#123;
          static void Main(string[] args)
          &#123;
              student stu;            &#x2F;&#x2F;引用类型，直接分配32bit，用于存放实例的地址，局部变量在栈上分配内存
              stu &#x3D; new student();    &#x2F;&#x2F;stu实例化后,在堆上分配32bit+16bit的内存
              student stu1 &#x3D; stu;     &#x2F;&#x2F;引用类型，直接分配32bit，存放stu实例化之后的地址，局部变量在栈上分配内存
          &#125;
      &#125;
  
      class student 
      &#123;
          uint ID;        &#x2F;&#x2F;32bit
          ushort Score;   &#x2F;&#x2F;16bit
      &#125;
  &#125;
  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
</li>
<li><p><img src="/.com//Users\8y\AppData\Roaming\Typora\typora-user-images\image-20220908195733520.png" alt="image-20220908195733520"></p>
</li>
<li><p>十进制 30000001  -&gt; 二进制 高位 0000 0001 1100 1001 1100 0011 1000 0001 低位</p>
</li>
</ul>
<h4 id="5-4-4局部变量是在stack上分配内存"><a href="#5-4-4局部变量是在stack上分配内存" class="headerlink" title="5.4.4局部变量是在stack上分配内存"></a>5.4.4局部变量是在stack上分配内存</h4><h4 id="5-4-5-变量的默认值"><a href="#5-4-5-变量的默认值" class="headerlink" title="5.4.5 变量的默认值"></a>5.4.5 变量的默认值</h4><ul>
<li>成员变量在声明后没有赋值，存在默认值0</li>
<li>本地(局部)变量在声明后没有赋值，不能编译，本地变量一定要有显式赋值</li>
</ul>
<h4 id="5-4-6常量"><a href="#5-4-6常量" class="headerlink" title="5.4.6常量"></a>5.4.6常量</h4><ul>
<li><code>const  int x = 100;</code>,无法二次赋值，必须带初始化器</li>
</ul>
<h4 id="5-4-7装箱与拆箱（Boxing-amp-Unboxing）"><a href="#5-4-7装箱与拆箱（Boxing-amp-Unboxing）" class="headerlink" title="5.4.7装箱与拆箱（Boxing &amp; Unboxing）"></a>5.4.7装箱与拆箱（Boxing &amp; Unboxing）</h4><ul>
<li><p>目前采用较少，有损耗</p>
</li>
<li><p>本质上是值类型与引用类型的转换</p>
</li>
<li><p>装箱就是从栈上往堆上搬东西，然后栈上再分配4个字节的地址，指向堆的地址</p>
</li>
<li><p>例如</p>
<pre class="line-numbers language-none"><code class="language-none">int x &#x3D; 100;	&#x2F;&#x2F;int即int32，占4个字节
object obj &#x3D;x;	&#x2F;&#x2F;object是所有类型的基类，是引用类型，占4个字节<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li>
<li><p><img src="/.com//Users\8y\AppData\Roaming\Typora\typora-user-images\image-20220908202330792.png" alt="image-20220908202330792"></p>
</li>
<li><p>拆箱就是从堆上往栈搬东西，从堆上oject实例的值，按照我们的要求拆成目标类型的值，存储在栈上</p>
</li>
<li><p>```<br>int x = 100;    //int即int32，占4个字节<br>object obj =x;    //object是所有类型的基类，是引用类型，占4个字节<br>int y = (int)obj;</p>
<pre class="line-numbers language-none"><code class="language-none">
  &lt;hr&gt;

  

## 6. 方法的定义、调用与调试

两本书：《CLR via C#》、《C# IN DEPTH》

### 6.1 方法的由来

#### 6.1.1 方法（method）的前身是C&#x2F;C++语言的函数（function）

- 方法是面向对象语言范畴的概念，在非面向对象语言种仍然称为函数
- 使用C&#x2F;C++语言做对比
  - 在C语言中printf()，print打印，f是format的意思，就是根据所要的格式进行打印
  - C++中&#96;std::cout&#96;就类似于C#中&#96;system.Console&#96;

#### 6.1.2 永远都是类（或结构体）的成员

- C#语言种函数不可能独立于类（或结构体）之外

  - &#96;&#96;&#96;c#
    using System;
    
    namespace ConsoleApp1
    &#123;
        double Add(double a,double b)
        &#123;
            return a + b;
        &#125;
        class Program
        &#123;
            static void Main(string[] args)
            &#123;
                Console.WriteLine(&quot;Hello World!&quot;);
            &#125;
        &#125;
    &#125;
    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><font color="red">严重错误：命名空间不能直接包含字段或方法之类的成员</font></li>
</ul>
</li>
<li><p>只有作为类（或结构体）的成员时才被称为方法</p>
</li>
<li><p>C++种是可以的，称为”全局函数”</p>
</li>
</ul>
<h4 id="6-1-3-是类（或结构体）最基本的成员之一"><a href="#6-1-3-是类（或结构体）最基本的成员之一" class="headerlink" title="6.1.3 是类（或结构体）最基本的成员之一"></a>6.1.3 是类（或结构体）最基本的成员之一</h4><ul>
<li>最基本的成员只有两个——字段与方法（成员变量与成员方法），本质还是数据+算法</li>
<li>方法表示类（或结构体）“能做什么事情”</li>
</ul>
<h4 id="6-1-4-为什么需要方法和函数"><a href="#6-1-4-为什么需要方法和函数" class="headerlink" title="6.1.4 为什么需要方法和函数"></a>6.1.4 为什么需要方法和函数</h4><ul>
<li><p>目的1：隐藏复杂的逻辑</p>
</li>
<li><p>目的2：把大算法分解为小算法</p>
</li>
<li><p>目的3：复用（reuse，重用）</p>
<ul>
<li>例如把计算圆面积的算法提出来，重复利用计算圆柱和圆锥的体积</li>
<li>没有复用容易造成程序的隐患，产生bug</li>
</ul>
</li>
<li><p>示例：计算圆面积、圆柱体积、圆锥体积</p>
<ul>
<li>```c#<br>using System;namespace CSharpMethodExample<br>{<pre><code>class Calculator
&#123;
    public double GetCircleArea(double r)   //计算圆的面积
    &#123;
        return Math.PI * r * r;
    &#125;

    public double GetCylinderVolume(double h,double r) //计算圆柱的体积
    &#123;
        return GetCircleArea(r) * h;
    &#125;

    public double GetConeVolume(double h,double r)  //计算圆锥的体积
    &#123;
        return GetCylinderVolume(h, r) / 3;
    &#125;
&#125;
class Program
&#123;
    static void Main(string[] args)
    &#123;
        Calculator c = new Calculator();
        Console.WriteLine(c.GetCylinderVolume(10,100));
    &#125;
&#125;
</code></pre>
}<pre class="line-numbers language-none"><code class="language-none">
    

### 6.2 方法的定义与调用

#### 6.2.1 声明方法的语法详细
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
public double GetCircleArea(double r) //函数头<br>{                                      //函数体<br> return Math.PI * r * r;<br>}<pre class="line-numbers language-none"><code class="language-none">
- 参见C#语言文档（声明、定义不分家）
- Parameter全程为“formal parameter”形式上的参数，简称“形参”
- 形参参与构成算法逻辑
- Parameter是一种变量

#### 6.2.2 方法的命名规范

- 大小写规范
- 需要以动词或者动词短语作为名字
- 采用帕斯卡命名法，所有单词的首字母都大写，例如&#96;GetCircleArea&#96;，与JAVA存在区别

#### 6.2.3 重温静态（static）方法和实例方法

- 静态（static）方法，&#96;public static double Add()&#96;
- 实例方法就是不加static的方法
- 重温静态（static）方法和实例方法，静态方法是和类绑定的，在类第一次加载时就被加载到内存里，直到程序结束才释放，静态类是工具类，不需要创建实例就能用到里面的方法；实例方法是和实例绑定的，在new实例的时候才创建，并且使用完就释放了。所以，为了方便，常用的方法写成静态方法，为了节省内存，大部分方法写成非静态的

#### 6.2.4 调用方法

- Argument中文C#文档的官方译法为“实际参数”，简称“实参”，可理解为调用方法时的真实条件
- 调用方法时的实参的列表与定义方法时的形参的列表一定要匹配

### 6.3 构造器（一种特殊的方法）

#### 6.3.1 构造器（constructor）是类型的成员之一

#### 6.3.2 侠义的构造器指的是“实例构造器”(instance constructor)

#### 6.3.3 如何调用构造器

- 例如&#96;student stu &#x3D; new student();&#96;,()就是构造器
- 当你没有给类写构造器时，存在一个默认的无参数的构造器
- 只存在一个带参数的构造器，就不能使用无参的构造器
- 如果你还想使用无参的构造器，你需要再写一个无参的构造器

#### 6.3.4 声明构造器

- ctor+tab+tab，自动准备好一个构造器

#### 6.3.5 构造器的内存原理

- 栈内存由高地址向低地址进行分配

- 接下来是调用默认的构造器的内存原理

- &#96;&#96;&#96;c#
  using System;
  
  namespace CSharpMethodExample
  &#123;
      class student
      &#123;
          public int ID;         &#x2F;&#x2F;占4个字节
          public string name;    &#x2F;&#x2F;string是引用类型，直接占4个字节
      &#125;
      
      class Program
      &#123;
          static void Main(string[] args)
          &#123;
              student stu &#x3D; new student();
              Console.WriteLine(stu.name&#x3D;&#x3D;null);
          &#125;
      &#125;
  &#125;
  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
</li>
<li><p><img src="/.com//Users\8y\AppData\Roaming\Typora\typora-user-images\image-20220909114008993.png" alt="image-20220909114008993"></p>
</li>
<li><p>接下来是调用带参数的构造器的内存原理</p>
</li>
<li><p>```c#<br>using System;</p>
<p>namespace CSharpMethodExample<br>{</p>
<pre><code>class student
&#123;
    public int ID;         //占4个字节
    public string name;    //string是引用类型，直接占4个字节
    public student(int initID,string initName)
    &#123;
        this.ID = initID;
        this.name = initName;
    &#125;
&#125;

class Program
&#123;
    static void Main(string[] args)
    &#123;
        student stu = new student(1,&quot;Mr.Okay&quot;);
        Console.WriteLine(stu.name==null);
    &#125;
&#125;
</code></pre>
<p>}</p>
<pre class="line-numbers language-none"><code class="language-none">
- ![image-20220909120619585](C:\Users\8y\AppData\Roaming\Typora\typora-user-images\image-20220909120619585.png)

### 6.4 方法的重载（Overload）

#### 6.4.1 调用重载方法的实例

- 例如cw有17个重载
- ![image-20220909165403871](C:\Users\8y\AppData\Roaming\Typora\typora-user-images\image-20220909165403871.png)

#### 6.4.2 声明带有重载的方法

- 方法签名（method signature）由方法的名称、类型形参的个数和它的每一个形参（按从左到右的顺序）的类型和种类（值、引用或输出）组成。&lt;font color&#x3D;red&gt;方法签名不包含返回类型。&lt;&#x2F;font&gt;

  - 签名在现实中表示唯一性

  - &#96;&#96;&#96;c#
    &#x2F;&#x2F;方法签名不包含返回类型,这样写就无法编译通过
    class Calculator
        &#123;
            public int Add(int a,int b)
            &#123;
                return a + b;
            &#125;
            public double Add(int a, int b)
            &#123;
                return a + b;
            &#125;
        &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>```c#<br>//类型形参<br>class Calculator<pre><code>&#123;
    public int Add(int a,int b)
    &#123;
        return a + b;
    &#125;
    public int Add&lt;T&gt;(int a, int b)
    &#123;
        T t;
        return a + b;
    &#125;
&#125;
</code></pre>
<pre class="line-numbers language-none"><code class="language-none">
    

- 实例构造函数签名由它的每一个形参（按从左到右的顺序）的类型和种类（值、引用或输出）组成

- 重载决策（到底调用哪一个来重载）：用于在给定了参数列表和一组候选函数成员的情况下，选择哪一个最佳函数成员来实施调用

### 6.5 如何对方法进行debug

- 设置断点（breakpoint）
  - ![image-20220909171226298](C:\Users\8y\AppData\Roaming\Typora\typora-user-images\image-20220909171226298.png)
- 观察方法调用时的call stack
  - 先按F5调试，然后再按CTRL+ALT+C 调用堆栈，其实和堆栈帧是一样的 
  - ![image-20220909172252145](C:\Users\8y\AppData\Roaming\Typora\typora-user-images\image-20220909172252145.png)
  - 可以看出函数调用的方式
- Step-in，Step-over，Step-out
  - Step-in F11 逐语句，每次进一步,最仔细的debug方法
  - Step-over F10 逐过程
  - Step-out Shift + F11 跳出
- 观察局部变量的值与变化
  - Locals 局部变量 ctrl+alt+v
  - ![image-20220909173403090](C:\Users\8y\AppData\Roaming\Typora\typora-user-images\image-20220909173403090.png)

### 6.6 方法的调用与栈*

- 方法调用时栈内存的分配

  - 对stack frame的分析
  - stack frame 指的是一个方法在被调用的时候在栈内存的布局
  - 栈内存由高字节向低字节发展

- 对以下代码进行分析

- &#96;&#96;&#96;c#
  using System;
  
  namespace CSharpMethodExample
  &#123;
      class Calculator
      &#123;
          public static double GetCircleArea(double r)   &#x2F;&#x2F;计算圆的面积
          &#123;
              return Math.PI * r * r;
          &#125;
  
          public static double GetCylinderVolume(double r, double h) &#x2F;&#x2F;计算圆柱的体积
          &#123;
              double a &#x3D; GetCircleArea(r);
              return a * h;
          &#125;
  
          public static double GetConeVolume(double r, double h)  &#x2F;&#x2F;计算圆锥的体积
          &#123;
              double cv &#x3D; GetCylinderVolume(r, h);
              return cv &#x2F; 3;
          &#125;
      &#125;
      class Program
      &#123;
          static void Main(string[] args)
          &#123;
              double result &#x3D; Calculator.GetConeVolume(100, 100);	&#x2F;&#x2F;断点
          &#125;
      &#125;
  &#125;
  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
</li>
<li><p>这是内存默认的情况</p>
</li>
<li><p><img src="/.com//Users\8y\AppData\Roaming\Typora\typora-user-images\image-20220909195448466.png" alt="image-20220909195448466"></p>
</li>
<li><p>我们对<code> double result = Calculator.GetConeVolume(100, 100);</code>进行断点</p>
</li>
<li><p>使用F5进行调试，进入如下界面</p>
</li>
<li><p><img src="/.com//Users\8y\AppData\Roaming\Typora\typora-user-images\image-20220909202244944.png" alt="image-20220909202244944"></p>
</li>
<li><p>Main方法在栈中占用的stack frame的大小暂时不用管，以下是分配给Main方法之后栈内存的分配情况</p>
</li>
<li><p><img src="/.com//Users\8y\AppData\Roaming\Typora\typora-user-images\image-20220909200306630.png" alt="image-20220909200306630"></p>
</li>
<li><p>```<br>static void Main(string[] args)</p>
<pre><code>    &#123;
        double result = Calculator.GetConeVolume(100, 100);
    &#125;
</code></pre>
<pre class="line-numbers language-none"><code class="language-none">
- &#96;Main&#96;方法是&#96;主调者&#96;caller，&#96;GetConeVolume&#96;方法是&#96;被调者&#96; callee

- Main方法在调用&#96;GetConeVolume&#96;方法的时候，需要传两个参数变量，在C#中这两个参数变量归Main方法管

- 100虽然是整型，但是&#96;GetConeVolume&#96;方法里的两个参数是&#96;double&#96;型，所以占&#96;8个字节&#96;的内存

- 在压栈的时候，C#是从左往右进行参数的压栈

- ![image-20220909202317905](C:\Users\8y\AppData\Roaming\Typora\typora-user-images\image-20220909202317905.png)

- 之后按下F11，我们就进入到了&#96;GetConeVolume&#96;方法里了

- ![image-20220909202343831](C:\Users\8y\AppData\Roaming\Typora\typora-user-images\image-20220909202343831.png)

- &#96;&#96;&#96;c#
  public static double GetConeVolume(double r, double h)  &#x2F;&#x2F;计算圆锥的体积
          &#123;
              double cv &#x3D; GetCylinderVolume(r, h);
              return cv &#x2F; 3;
         &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>进入<code>GetConeVolume</code>方法里后，我们知道局部变量是需要分配栈内存的，在这里r,h已经<code>Main</code>方法压到了栈里，所以我们只需要给cv分配栈内存，也是double类型的8个字节</p>
</li>
<li><p><img src="/.com//Users\8y\AppData\Roaming\Typora\typora-user-images\image-20220909202644466.png" alt="image-20220909202644466"></p>
</li>
<li><p>给cv分配好之后，<code>GetConeVolume</code>方法需要调用<code>GetCylinderVolume</code>方法，而<code>GetCylinderVolume</code>也需要2个double型的参数，还是和之前一样，谁调用谁负责压栈</p>
</li>
<li><p><img src="/.com//Users\8y\AppData\Roaming\Typora\typora-user-images\image-20220909203554249.png" alt="image-20220909203554249"></p>
</li>
<li><p>之后按下F11，我们就进入到了<code>GetCylinderVolume</code>方法里了</p>
</li>
<li><p><img src="/.com//Users\8y\AppData\Roaming\Typora\typora-user-images\image-20220909203826886.png" alt="image-20220909203826886"></p>
</li>
<li><p>```C#<br>public static double GetCylinderVolume(double r, double h) //计算圆柱的体积</p>
<pre><code>    &#123;
        double a = GetCircleArea(r);
        return a * h;
    &#125;
</code></pre>
<pre class="line-numbers language-none"><code class="language-none">
- 进入&#96;GetCylinderVolume&#96;方法里后，在这里r,h已经被&#96;&#96;GetConeVolume&#96;&#96;方法压到了栈里，所以我们只需要给参数变量a进行压栈，也是double类型的8个字节

- ![image-20220909204122550](C:\Users\8y\AppData\Roaming\Typora\typora-user-images\image-20220909204122550.png)

- 给a参数分配好之后，&#96;GetCylinderVolume&#96;方法需要调用&#96;GetCircleArea&#96;方法，而&#96;GetCircleArea&#96;需要1个double型的参数变量r，还是和之前一样，谁调用谁负责压栈

- ![image-20220909204613369](C:\Users\8y\AppData\Roaming\Typora\typora-user-images\image-20220909204613369.png)

- 按F11后，我们进入到最后一层调用

- ![image-20220909204719178](C:\Users\8y\AppData\Roaming\Typora\typora-user-images\image-20220909204719178.png)

- &#96;&#96;&#96;c#
  public static double GetCircleArea(double r)   &#x2F;&#x2F;计算圆的面积
          &#123;
              return Math.PI * r * r;
          &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>我们发现只有一个局部变量r，而r已经被<code>GetCylinderVolume</code>方法压栈了</p>
</li>
<li><p><font color="red">如果一个方法没有局部变量，它仍然占内存，我们上面的内存图只是以局部变量为重点制作的内存图，实际上还有其它地方占内存，比如说我们用完这个方法后，回到之前那个方法，我们需要在栈上保存之前方法的内存地址</font></p>
</li>
<li><p><img src="/.com//Users\8y\AppData\Roaming\Typora\typora-user-images\image-20220909205257393.png" alt="image-20220909205257393"></p>
</li>
<li><p>执行完之后，这个方法会产生一个返回值，返回值一般情况下是存放在CPU的寄存器里面，也有特殊的情况，寄存器存不下然后在栈上开辟内存空间，而这里的double型是肯定可以存下的。</p>
</li>
<li><p>之后按几下F11键，调试指针就回到了<code>GetCylinderVolume</code>方法里</p>
</li>
<li><p><img src="/.com//Users\8y\AppData\Roaming\Typora\typora-user-images\image-20220909205837338.png" alt="image-20220909205837338"></p>
</li>
<li><p><img src="/.com//Users\8y\AppData\Roaming\Typora\typora-user-images\image-20220909210038402.png" alt="image-20220909210038402"></p>
</li>
<li><p>而在栈中，框起来的一块进行了出栈操作，对<code>GetCircleArea</code>方法所占内存和它主调函数负责压栈的参数进行清空</p>
</li>
<li><p>你会发现调用堆栈里少了最上面的一层，这时候a的值为0是因为返回值还存放在CPU的寄存器里面，你再一下F11就会得到a的值</p>
</li>
<li><p><img src="/.com//Users\8y\AppData\Roaming\Typora\typora-user-images\image-20220909210452029.png" alt="image-20220909210452029"></p>
</li>
<li><p>之后继续按F11，调试指针就回到了<code>GetConeVolume</code>方法里</p>
</li>
<li><p><img src="/.com//Users\8y\AppData\Roaming\Typora\typora-user-images\image-20220909210622628.png" alt="image-20220909210622628"></p>
</li>
<li><p>你会发现调用堆栈里又少了上面的一层，这时候cv的值为0是因为返回值还存放在CPU的寄存器里面，你再一下F11就会得到cv的值</p>
</li>
<li><p><img src="/.com//Users\8y\AppData\Roaming\Typora\typora-user-images\image-20220909210738227.png" alt="image-20220909210738227"></p>
</li>
<li><p><img src="/.com//Users\8y\AppData\Roaming\Typora\typora-user-images\image-20220909210829883.png" alt="image-20220909210829883"></p>
</li>
<li><p>而在栈中，框起来的一块进行了出栈操作，对<code>GetCylinderVolume</code>方法所占内存和它主调函数负责压栈的参数进行清空</p>
</li>
<li><p>这时候继续按几次F11，调试指针就回到了<code>Main</code>方法</p>
</li>
<li><p><img src="/.com//Users\8y\AppData\Roaming\Typora\typora-user-images\image-20220909211551716.png" alt="image-20220909211551716"></p>
</li>
<li><p>同样的对框里的内容进行出栈操作</p>
</li>
<li><p><img src="/.com//Users\8y\AppData\Roaming\Typora\typora-user-images\image-20220909211647067.png" alt="image-20220909211647067"></p>
</li>
<li><p>之后在按几次F11，随着<code>Main</code>函数执行完，它在内存中所占的内存也被清空</p>
</li>
<li><p><img src="/.com//Users\8y\AppData\Roaming\Typora\typora-user-images\image-20220909211900564.png" alt="image-20220909211900564"></p>
</li>
<li><p>这时程序就彻底结束了</p>
</li>
<li><p>理解并熟记这块内容，你就已经是很专业的开发人员了</p>
</li>
</ul>
<hr>


<h2 id="7-操作符详解"><a href="#7-操作符详解" class="headerlink" title="7. 操作符详解"></a>7. 操作符详解</h2><h3 id="7-1-操作符概览"><a href="#7-1-操作符概览" class="headerlink" title="7.1 操作符概览"></a>7.1 操作符概览</h3><ul>
<li><img src="/.com//Users\8y\AppData\Roaming\Typora\typora-user-images\image-20220910092648080.png" alt="image-20220910092648080"></li>
<li>操作符（operator）也译为运算符</li>
<li>操作符是用来操作数据的，被操作符操作的数据称为操作数（Operand）</li>
</ul>
<h3 id="7-2-操作符的本质"><a href="#7-2-操作符的本质" class="headerlink" title="7.2 操作符的本质"></a>7.2 操作符的本质</h3><ul>
<li><p>操作符的本质是函数（算法）的简记法</p>
</li>
<li><p>操作符不能脱离与它相关联的数据类型</p>
<ul>
<li>例如 3/4=0，3.0/4.0=0.75</li>
</ul>
</li>
<li><p>举例</p>
</li>
<li><p>```c#<br>using System;<br>using System.Collections.Generic;</p>
<p>namespace Operator<br>{</p>
<pre><code>class Program
&#123;
    static void Main(string[] args)
    &#123;
        Person p1 = new Person();
        Person p2 = new Person();
        p1.name = &quot;Deer&quot;;
        p2.name = &quot;Deer&#39;s wife&quot;;
        List&lt;Person&gt; nation = p1 + p2;
        foreach(var p in nation)
        &#123;
            Console.WriteLine(p.name);
        &#125;
    &#125;
&#125;

class Person
&#123;
    public string name;

    public static List&lt;Person&gt; operator +(Person p1,Person p2)
    &#123;
        List&lt;Person&gt; people = new List&lt;Person&gt;();
        people.Add(p1);
        people.Add(p2);
        for (int i = 0; i &lt; 11; i++)
        &#123;
            Person child = new Person();
            child.name = p1.name + &quot; &amp; &quot; + p2.name + &quot;&#39;s child&quot;;
            people.Add(child);
        &#125;
        return people;
    &#125;
&#125;
</code></pre>
<p>}</p>
<pre class="line-numbers language-none"><code class="language-none">
- 运行结果如下：

- &#96;&#96;&#96;
  Deer
  Deer&#39;s wife
  Deer &amp; Deer&#39;s wife&#39;s child
  Deer &amp; Deer&#39;s wife&#39;s child
  Deer &amp; Deer&#39;s wife&#39;s child
  Deer &amp; Deer&#39;s wife&#39;s child
  Deer &amp; Deer&#39;s wife&#39;s child
  Deer &amp; Deer&#39;s wife&#39;s child
  Deer &amp; Deer&#39;s wife&#39;s child
  Deer &amp; Deer&#39;s wife&#39;s child
  Deer &amp; Deer&#39;s wife&#39;s child
  Deer &amp; Deer&#39;s wife&#39;s child
  Deer &amp; Deer&#39;s wife&#39;s child<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
<h3 id="7-3-操作符的优先级"><a href="#7-3-操作符的优先级" class="headerlink" title="7.3 操作符的优先级"></a>7.3 操作符的优先级</h3><ul>
<li>可以使用圆括号提高被括起来表达式的优先级</li>
<li>圆括号可以嵌套</li>
<li>不像数学里有方括号和花括号，在C#语言里<code>[]</code>与<code>&#123;&#125;</code>有专门的用途</li>
</ul>
<h3 id="7-4-同级操作符的运算顺序"><a href="#7-4-同级操作符的运算顺序" class="headerlink" title="7.4 同级操作符的运算顺序"></a>7.4 同级操作符的运算顺序</h3><ul>
<li><p>除了带有赋值功能的操作符，同优先级操作符都是由左向右进行运算</p>
</li>
<li><p>带有赋值功能的操作符的运算顺序都是由右向左</p>
<ul>
<li><p><img src="/.com//Users\8y\AppData\Roaming\Typora\typora-user-images\image-20220910095610510.png" alt="image-20220910095610510"></p>
</li>
<li><p>例如 x = 3 + 4 + 5</p>
</li>
<li><p>顺序1： 3+4</p>
</li>
<li><p>顺序2： 7+5</p>
</li>
<li><p>顺序3： x=12</p>
</li>
<li><p>```c#<br>int x = 100;<br>int y = 200;<br>int z = 300;<br>x += y += z;<br>Console.WriteLine(x); //600<br>Console.WriteLine(y); //500<br>Console.WriteLine(z); //300</p>
<pre class="line-numbers language-none"><code class="language-none">
- 与数学运算不同，计算机语言的同优先级运算没有&quot;结合律&quot;

  - 3+4+5只能理解为Add(Add(3+4),5)不能理解为Add(3,Add(4,5))

### 7.5 各种操作符的示例

- 委托可以把方法当作参数在其他类中使用

- &#96;&#96;&#96;c#
  using System;
  using System.Collections.Generic;
  
  namespace Operator
  &#123;
      class Program
      &#123;
          static void Main(string[] args)
          &#123;
              Calculator c &#x3D; new Calculator();
              Action myAction &#x3D; new Action(c.PrintHello); &#x2F;&#x2F;委托
              myAction();
          &#125;
      &#125;
  
      class Calculator
      &#123;
          public double Add(double a,double b)
          &#123;
              return a + b;
          &#125;
  
          public void PrintHello()
          &#123;
              Console.WriteLine(&quot;Hello&quot;);
          &#125;
      &#125;
  &#125;
  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
</li>
<li><p>元素访问操作符，<code>方括号[]</code>里不一定是整数</p>
</li>
<li><p>```c#<br>using System;<br>using System.Collections.Generic;</p>
<p>namespace Operator<br>{</p>
<pre><code>class Program
&#123;
    static void Main(string[] args)
    &#123;
        Dictionary&lt;string, Student&gt; stuDic = new Dictionary&lt;string, Student&gt;(); //字典
        for (int i = 1; i &lt; 101; i++)
        &#123;
            Student stu = new Student();
            stu.name = &quot;s_&quot; + i.ToString();
            stu.score = i;
            stuDic.Add(stu.name, stu);
        &#125;

        Student stu6 = stuDic[&quot;s_6&quot;];
        Console.WriteLine(stu6.score);    //结果为6
    &#125;
&#125;
class Student
&#123;
    public string name;
    public int score;
&#125;
</code></pre>
<p>}</p>
<pre class="line-numbers language-none"><code class="language-none">
  #### 7.5.1 基本操作符

- &#96;typeof&#96;操作符

- &#96;typeof&#96; 运算符用于获取某个类型的 [System.Type](https:&#x2F;&#x2F;docs.microsoft.com&#x2F;zh-cn&#x2F;dotnet&#x2F;api&#x2F;system.type) 实例

- &#96;&#96;&#96;c#
  using System;
  using System.Collections.Generic;
  
  namespace Operator
  &#123;
      class Program
      &#123;
          static void Main(string[] args)
          &#123;
              Type t &#x3D; typeof(int);
              Console.WriteLine(t.Namespace); &#x2F;&#x2F;输出类型int的名称空间
              Console.WriteLine(t.FullName);  &#x2F;&#x2F;输出类型int的全名
              Console.WriteLine(t.Name);      &#x2F;&#x2F;输出类型int的名称
              Console.WriteLine();
              foreach(var mi in t.GetMethods()) &#x2F;&#x2F;查看int的方法
              &#123;
                  Console.WriteLine(mi.Name);
              &#125;
              Console.WriteLine(t.GetMethods().Length);   &#x2F;&#x2F;输出int的方法的个数
          &#125;
      &#125;
  &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>运行结果如下：</p>
</li>
<li><p>```<br>System<br>System.Int32<br>Int32</p>
<p>CompareTo<br>CompareTo<br>Equals<br>Equals<br>GetHashCode<br>ToString<br>ToString<br>ToString<br>ToString<br>TryFormat<br>Parse<br>Parse<br>Parse<br>Parse<br>Parse<br>TryParse<br>TryParse<br>TryParse<br>TryParse<br>GetTypeCode<br>GetType<br>21</p>
<pre class="line-numbers language-none"><code class="language-none">
- &#96;default&#96;操作符

- 从 C# 7.1 开始，当编译器可以推断表达式类型时，可以使用 &#96;default&#96; 文本生成类型的默认值。

  &#96;&#96;&#96;c#
  using System;
  using System.Collections.Generic;
  
  namespace Operator
  &#123;
      class Program
      &#123;
          static void Main(string[] args)
          &#123;
              &#x2F;&#x2F;结构体类型
              int x &#x3D; default(int);
              Console.WriteLine(x);
  
              &#x2F;&#x2F;引用类型
              Student stu &#x3D; default(Student);
              Console.WriteLine(stu&#x3D;&#x3D;null);
  
              &#x2F;&#x2F;枚举类型
              Level level &#x3D; default(Level);
              Console.WriteLine(level);
              Level2 level2 &#x3D; default(Level2);
              Console.WriteLine(level2);
          &#125;
      &#125;
  
     
      enum Level
      &#123;
          Low,        &#x2F;&#x2F;0
          Mid,        &#x2F;&#x2F;1
          High        &#x2F;&#x2F;2
      &#125;
  
      &#x2F;&#x2F;设计枚举类型，最好要给一个0，否则容易出错
      enum Level2
      &#123;
          Low&#x3D;1,        
          Mid&#x3D;0,        
          High&#x3D;2        
      &#125;
      
      class Student
      &#123;
          
      &#125;
  &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>运行结果如下：</p>
</li>
<li><p>```<br>0<br>True<br>Low<br>Mid</p>
<pre class="line-numbers language-none"><code class="language-none">
- &#96;var&#96;关键字用于声明隐式的变量，编译器可以推断出隐式变量类型

- &#96;&#96;&#96;
  var x &#x3D; 10;
  &#x2F;&#x2F;x &#x3D; &quot;s&quot;;这一段在C#是不被允许的,在上一条语句中C#已经知道x是int32类型的
  Console.WriteLine(x.GetType().Name);	&#x2F;&#x2F;结果为int32<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p><code>new</code>操作符</p>
<ul>
<li><p>在内存中创建类型的实例，并调用它的实例构造器 <code>new Form();</code></p>
</li>
<li><p>得到实例的内存地址，把内存地址通过赋值操作符<code>=</code>交给负责实例的引用变量 <code>Form myForm = new Form();</code></p>
</li>
<li><p>调用实例的初始化器<code>Form myForm = new Form()&#123;Text = &quot;Hello&quot;&#125;;</code></p>
</li>
<li><p><code>new Form().ShowDialog();</code>可以正常执行，只不过运行完就会被垃圾收集器给收回</p>
</li>
<li><p><em>语法糖</em>（Syntactic sugar），也译为<em>语法糖衣</em></p>
<ul>
<li>指计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用。通常来说使用语法糖能够增加程序的可读性，从而减少程序代码出错的机会。</li>
</ul>
</li>
<li><p>string是<code>类</code>类型的，但是可以不用<code>new</code>操作符</p>
</li>
<li><p>可以使用<code>var</code>创建匿名类型</p>
</li>
<li><p>用匿名类型来创建对象，然后用隐式类型变量来引用实例</p>
<ul>
<li>```c#<br>var person = new { name = “Mr.Okay”, age = 10 };<pre><code>       Console.WriteLine(person.name);
       Console.WriteLine(person.age);
       Console.WriteLine(person.GetType().Name);
</code></pre>
<pre class="line-numbers language-none"><code class="language-none">
- 运行结果如下：

  - &#96;&#96;&#96;
    Mr.Okay
    10
    &lt;&gt;f__AnonymousType0&#96;2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
</li>
<li><p>&lt;&gt;f__AnonymousType0`2</p>
<ul>
<li>&lt;&gt;f__AnonymousType 这是一个约定的前缀</li>
<li>0 指的是我在程序创建的第一个匿名类</li>
<li>`2 指的是这个类型是个<strong>泛型类</strong>，需要2个参数来构成它</li>
</ul>
</li>
<li><p><code>new</code>操作符在使用的时候一定要小心</p>
<ul>
<li><p>一但你在一个类调用了<code>new</code>操作符，你在编写的类型与调用的类型，就形成了<code>紧耦合</code></p>
</li>
<li><p>例如</p>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">class Program
    &#123;
        static void Main(string[] args)
        &#123;
            Form myForm &#x3D; new Form();
        &#125;
    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>Program类就依赖在了Form类上，一但Form类出现问题，Program类也会出现问题</p>
</li>
<li><p>依赖注入模式</p>
</li>
</ul>
</li>
<li><p><code>new</code>还可以作为修饰符</p>
</li>
<li><p>```c#<br>using System;<br>using System.Collections.Generic;<br>using System.Linq;<br>using System.Text;<br>using System.Threading.Tasks;<br>using System.Windows.Forms;</p>
<p>namespace OperatorsExample<br>{</p>
<pre><code>class Program
&#123;
    static void Main(string[] args)
    &#123;
        Student stu = new Student();
        stu.Report();

        CsStudent cstu = new CsStudent();
        cstu.Report();
    &#125;
&#125;

class Student
&#123;
    public void Report()
    &#123;
        Console.WriteLine(&quot;I&#39;m a student.&quot;);
    &#125;
&#125;

class CsStudent:Student
&#123;
    new public void Report()    //这里的new是修饰符，表示对父类方法的隐藏（hide）
    &#123;
        Console.WriteLine(&quot;I&#39;m a CSstudent.&quot;);
    &#125;
&#125;
</code></pre>
<p>}</p>
<pre class="line-numbers language-none"><code class="language-none">
- 运行结果如下：

- &#96;&#96;&#96;
  I&#39;m a student.
  I&#39;m a CSstudent.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
</li>
<li><p><code>checked</code>操作符与<code>unchecked</code>操作符</p>
<ul>
<li><p>C#默认是<code>unchecked</code>操作符</p>
</li>
<li><p>```c#<br>using System;<br>using System.Collections.Generic;<br>using System.Linq;<br>using System.Text;<br>using System.Threading.Tasks;<br>using System.Windows.Forms;</p>
<p>namespace OperatorsExample<br>{</p>
<pre><code>class Program
&#123;
    static void Main(string[] args)
    &#123;
        uint x = uint.MaxValue; //无符号整形的最大值
        Console.WriteLine(x);
        string binStr = Convert.ToString(x, 2); //以二进制的形式表示
        Console.WriteLine(binStr);
        try
        &#123;
            uint y = checked(x + 1);  //超过了最大值
            Console.WriteLine(y);
        &#125;
        catch(OverflowException ex)
        &#123;
            Console.WriteLine(&quot;There&#39;s overflow!&quot;);
        &#125;
    &#125;
&#125;
</code></pre>
<p>}</p>
<pre class="line-numbers language-none"><code class="language-none">
- 运行结果如下：

- &#96;&#96;&#96;
  4294967295
  11111111111111111111111111111111
  There&#39;s overflow!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>与<code>new</code>类似，<code>checked</code>与<code>unchecked</code>还有上下文用法</p>
<ul>
<li>```c#<br>using System;<br>using System.Collections.Generic;<br>using System.Linq;<br>using System.Text;<br>using System.Threading.Tasks;<br>using System.Windows.Forms;namespace OperatorsExample<br>{<pre><code>class Program
&#123;
    static void Main(string[] args)
    &#123;
        uint x = uint.MaxValue; //无符号整形的最大值
        Console.WriteLine(x);
        string binStr = Convert.ToString(x, 2); //以二进制的形式表示
        Console.WriteLine(binStr);
        checked
        &#123;
            try
            &#123;
                uint y = x + 1;  //超过了最大值
                Console.WriteLine(y);
            &#125;
            catch (OverflowException ex)
            &#123;
                Console.WriteLine(&quot;There&#39;s overflow!&quot;);
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<pre class="line-numbers language-none"><code class="language-none">
- &#96;delegate&#96;操作符

  - &#96;delegate&#96;有一种更重要的用法，就是委托
  - 操作符已经是种过时的用法

- &#96;sizeof&#96;操作符

  - 只能获取C#&#96;基本数据类型&#96;的实例在内存种所占的字节数

  - 只能获取&#96;结构体&#96;数据类型的实例在内存种所占的字节数

    - 所以不能获取string这种虽然也是基本数据类型，但不是结构体数据类型

  - 可以获取自定义结构体实例在内存种所占的字节数，但是需要定义在unsafe的上下文中

    - &#96;&#96;&#96;c#
      using System;
      using System.Collections.Generic;
      using System.Linq;
      using System.Text;
      using System.Threading.Tasks;
      using System.Windows.Forms;
      
      namespace OperatorsExample
      &#123;
          class Program
          &#123;
              static void Main(string[] args)
              &#123;
                  unsafe
                  &#123;
                      int x &#x3D; sizeof(Student);
                      Console.WriteLine(x);	&#x2F;&#x2F;16
                  &#125;
              &#125;
          &#125;
      
          struct Student
          &#123;
              int ID;
              long Score;
          &#125;
      &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
</li>
</ul>
</li>
<li><p><code>-&gt;</code>操作符</p>
<ul>
<li><p>需要定义在unsafe的上下文中</p>
</li>
<li><p>用于指针，只能操作结构体类型</p>
</li>
<li><p>```c#<br>using System;<br>using System.Collections.Generic;<br>using System.Linq;<br>using System.Text;<br>using System.Threading.Tasks;<br>using System.Windows.Forms;</p>
<p>namespace OperatorsExample<br>{</p>
<pre><code>class Program
&#123;
    static void Main(string[] args)
    &#123;
        unsafe
        &#123;
            Student stu;
            stu.ID = 1;
            stu.Score = 99;
            Student* pstu=&amp;stu;
            pstu-&gt;Score = 100;
            Console.WriteLine(stu.Score);   //100
        &#125;
    &#125;
&#125;

struct Student
&#123;
    public int ID;
    public long Score;
&#125;
</code></pre>
<p>}</p>
<pre class="line-numbers language-none"><code class="language-none">
    

#### 7.5.2 一元操作符

- 优先级比基本操作符低，例如&#96;(*pStu).Score&#x3D;1000&#96;; 括号必须加

- &#96;-&#96;操作符与&#96;+&#96;操作符

  - 在计算机中-x与x不是完全对称的，例如int型的最大值是2147483647，最小值是-2147483648，如果我们写x&#x3D;-2147483648，-x实际上已经出现了&#96;栈溢出&#96;，需要用到&#96;checked&#96;操作符才会正常报错

    - 而如果不适用&#96;checked&#96;操作符，你输出-x发现仍会输出-2147483648
    - 这是因为-2147483648的二进制是&#96;10000000000000000000000000000000&#96;
    - 按位取反后是&#96;01111111111111111111111111111111&#96;
    - 在加1后是&#96;10000000000000000000000000000000&#96;，即-2147483648

  - &#96;&#96;&#96;c#
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Text;
    using System.Threading.Tasks;
    using System.Windows.Forms;
    
    namespace OperatorsExample
    &#123;
        class Program
        &#123;
            static void Main(string[] args)
            &#123;
                int x &#x3D; int.MaxValue;
                int y &#x3D; int.MinValue;
                Console.WriteLine(x);	
                Console.WriteLine(y);
            &#125;
        &#125;
    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
</li>
<li><p><code>~</code>操作符</p>
<ul>
<li><p>取反操作符，在计算中取相反数就是<code>按位取反再加1</code></p>
</li>
<li><p>```c#<br>using System;<br>using System.Collections.Generic;<br>using System.Linq;<br>using System.Text;<br>using System.Threading.Tasks;<br>using System.Windows.Forms;</p>
<p>namespace OperatorsExample<br>{</p>
<pre><code>class Program
&#123;
    static void Main(string[] args)
    &#123;
        int x = 12345678;
        int y = ~x;
        Console.WriteLine(x);
        Console.WriteLine(y);
        string xStr = Convert.ToString(x, 2).PadLeft(32, &#39;0&#39;);  //PadLeft()方法用于表示总共的长度为32，左侧多余用0前置填充
        string yStr = Convert.ToString(y, 2).PadLeft(32, &#39;0&#39;);
        Console.WriteLine(xStr);
        Console.WriteLine(yStr);
    &#125;
&#125;
</code></pre>
<p>}</p>
<pre class="line-numbers language-none"><code class="language-none">
- 运行结果如下：

- &#96;&#96;&#96;
  12345678
  -12345679
  00000000101111000110000101001110
  11111111010000111001111010110001<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
</li>
<li><p>强制类型转化操作符<code>(T)x</code></p>
<ul>
<li><p>隐式（implicit）类型转换</p>
<ul>
<li><p>不丢失精度的转换</p>
<ul>
<li>```<br>int a = 10;<br>long b = a;<pre class="line-numbers language-none"><code class="language-none">
- 子类向父类的转换

  - &#96;&#96;&#96;c#
    using System;
    
    namespace ConversionExample
    &#123;
        class Program
        &#123;
            static void Main(string[] args)
            &#123;
                Teacher t &#x3D; new Teacher();
                Human h &#x3D; t;    &#x2F;&#x2F;h只能可见Eat()和Think()这两个方法
                Animal a &#x3D; h;   &#x2F;&#x2F;a只能看见Eat()这一个方法            
            &#125;
        &#125;
    
        class Animal
        &#123;
            public void Eat()
            &#123;
                Console.WriteLine(&quot;Eating...&quot;);
            &#125;
        &#125;
    
        class Human : Animal
        &#123;
            public void Think()
            &#123;
                Console.WriteLine(&quot;Who I am?&quot;);
            &#125;
        &#125;
    
        class Teacher:Human
        &#123;
            public void Teach()
            &#123;
                Console.WriteLine(&quot;I teach&quot;);
            &#125;
        &#125;
    &#125;
    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
</li>
<li><p>装箱</p>
</li>
</ul>
</li>
<li><p>显式（explicit）类型转换（强制类型转换）</p>
<ul>
<li>显式类型转换可以理解为目标类型实例的构造器，只不过是写在被转换类型的类里</li>
<li>有可能丢失精度（甚至发生错误）的转换，即cast<ul>
<li>强制类型转化操作符<code>(T)x</code></li>
</ul>
</li>
<li>拆箱</li>
<li>使用Convert类</li>
<li>ToString方法与各数据类型的Parse/TryParse方法</li>
</ul>
</li>
<li><p>自定义类型转换操作符</p>
<ul>
<li><p>C#中两个没有父子关系的类型怎么互相转换呢？</p>
</li>
<li><p>implicit和explicit是一对转换操作符</p>
</li>
<li><p>示例</p>
<ul>
<li><p>实现显示转换的方法，是在石头类中写一个explicit类型的Monkey方法，传入参数石头</p>
</li>
<li><p>```c#<br>using System;</p>
<p>namespace ConversionExample<br>{<br>  class Program</p>
<pre><code>&#123;
    static void Main(string[] args)
    &#123;
        Stone stone = new Stone();
        stone.Age = 5000;
        Monkey wukongSun = (Monkey)stone;
        Console.WriteLine(wukongSun.Age);
    &#125;
&#125;


class Stone
&#123;
    public int Age;
    public static explicit operator Monkey(Stone stone)        //explicit 显示类型转换 operator 操作符
    &#123;
        Monkey m = new Monkey();
        m.Age = stone.Age / 500;
        return m;
    &#125;

&#125;

class Monkey
&#123;
    public int Age;
&#125;
</code></pre>
<p>}</p>
<pre class="line-numbers language-none"><code class="language-none">
- 实现隐式转换的方法，是在石头类中写一个Implicit类型的Monkey方法，传入参数石头

- &#96;&#96;&#96;c#
  using System;
  
  namespace ConversionExample
  &#123;
      class Program
      &#123;
          static void Main(string[] args)
          &#123;
              Stone stone &#x3D; new Stone();
              stone.Age &#x3D; 5000;
              Monkey wukongSun &#x3D; stone;
              Console.WriteLine(wukongSun.Age);
          &#125;
      &#125;
  
  
      class Stone
      &#123;
          public int Age;
          public static implicit operator Monkey(Stone stone)		&#x2F;&#x2F;implicit 隐式类型转换
          &#123;
              Monkey m &#x3D; new Monkey();
              m.Age &#x3D; stone.Age &#x2F; 500;
              return m;
          &#125;
      
      &#125;
      
      class Monkey
      &#123;
          public int Age;
      &#125;
  &#125;
  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
</li>
<li><p>可以在任意一个类里定义显式或者隐式的类型转换</p>
</li>
<li><p>运算符声明必须符合以下规则：同时包含 <code>public</code> 和 <code>static</code> 修饰符。</p>
</li>
</ul>
</li>
<li><p>C#所有存在的类都有四种方法</p>
<ul>
<li><img src="/.com//Users\8y\AppData\Roaming\Typora\typora-user-images\image-20220911095744482.png" alt="image-20220911095744482"></li>
<li>具体可以通过<code>object o; o.</code>进行查看</li>
<li>ToString/GetType/GetHashCode/Equals</li>
</ul>
</li>
</ul>
</li>
<li><p><code>%</code>和<code>/</code>操作符</p>
<ul>
<li><code>NaN</code> not number</li>
<li>浮点类型除法可以除0，整数除0结果为<code>Infinity</code>，即正无穷大，负数除0结果为<code>-Infinity</code><ul>
<li><code>double.PositiveInfinity</code> 正无穷大</li>
<li><code>double.NegativeInfinity </code> 负无穷大</li>
<li><code>double.PositiveInfinity</code> / <code>double.NegativeInfinity</code> = <code>NaN</code></li>
</ul>
</li>
</ul>
</li>
<li><p>类型提升在<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>都会发生</p>
</li>
<li><p><code>&gt;&gt;</code>和<code>&lt;&lt;</code>位移操作符</p>
<ul>
<li><p>位移操作符指的是数据在内存中的<code>二进制</code>结构向左或者向右进行一定位数的位移</p>
</li>
<li><p>```c#<br>using System;</p>
<p>namespace ConversionExample<br>{</p>
<pre><code>class Program
&#123;
    static void Main(string[] args)
    &#123;
        int x = 7;
        int y = x &lt;&lt; 1;
        string strX = Convert.ToString(x, 2).PadLeft(32, &#39;0&#39;);
        string strY = Convert.ToString(y, 2).PadLeft(32, &#39;0&#39;);
        Console.WriteLine(strX);
        Console.WriteLine(strY);
        Console.WriteLine(x);
        Console.WriteLine(y);
    &#125;
&#125;
</code></pre>
<p>}</p>
<pre class="line-numbers language-none"><code class="language-none">
- 运行结果如下：

- &#96;&#96;&#96;
  00000000000000000000000000000111
  00000000000000000000000000001110
  7
  14<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>当在没有溢出的情况下，左移就是乘2，右移就是除2</p>
</li>
<li><p>左移无论你是正数还是负数，补进来的数都是0</p>
</li>
<li><p>右移如果你操作的是正数，最高位补进来的数是0，如果你操作的是负数，最高位补进来的数是1</p>
</li>
</ul>
</li>
<li><p><code>unicode</code>向下兼容<code>ascii</code>、</p>
</li>
<li><p><code>is</code>和<code>as</code>操作符</p>
<ul>
<li><p>类型检验操作符</p>
</li>
<li><p><code>is</code>操作符检验的结果是布尔类型</p>
</li>
<li><p>```c#<br>using System;</p>
<p>namespace ConversionExample<br>{</p>
<pre><code>class Program
&#123;
    static void Main(string[] args)
    &#123;
        Teacher t = new Teacher();
        var res1 = t is Teacher;
        Teacher t1 = null;
        var res2 = t1 is Teacher;
        var res3 = t is Human;
        var res4 = t is Animal;
        var res5 = t is object;
        Console.WriteLine(res1);
        //True
        Console.WriteLine(res2);
        //False
        Console.WriteLine(res3);
        //True，因为teacher是Human的派生类
        Console.WriteLine(res4);
        //True，因为teacher是Human的派生类，而Human是Animal的派生类
        Console.WriteLine(res5);
        //True，因为object是所有类的基类
    &#125;
&#125;

class Animal
&#123;
    public void Eat()
    &#123;
        Console.WriteLine(&quot;Eating...&quot;);
    &#125;
&#125;

class Human : Animal
&#123;
    public void Think()
    &#123;
        Console.WriteLine(&quot;Who I am?&quot;);
    &#125;
&#125;

class Teacher : Human
&#123;
    public void Teach()
    &#123;
        Console.WriteLine(&quot;I teach&quot;);
    &#125;
&#125;
</code></pre>
<p>}</p>
<pre class="line-numbers language-none"><code class="language-none">
- &#96;as&#96;操作符

- &#96;&#96;&#96;
  object o &#x3D; new Teacher();
           Teacher t &#x3D; o as Teacher;
           if (t !&#x3D; null)
           &#123;
               t.Teach();
           &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
</li>
<li><p>逻辑<code>&amp;</code>与操作符、<code>|</code>或操作符、<code>^</code>异或操作符</p>
<ul>
<li>操作二进制数据、图片等</li>
</ul>
</li>
<li><p>条件<code>&amp;&amp;</code>与操作符、<code>||</code>或操作符</p>
<ul>
<li><p>短路效应</p>
<ul>
<li><p>```c#<br>using System;</p>
<p>namespace ConversionExample<br>{</p>
<pre><code>class Program
&#123;
    static void Main(string[] args)
    &#123;
        int x = 3;
        int y = 4;
        int a = 3;
        if (x &gt; y &amp;&amp; a++ &gt; 3)
        &#123;
            Console.WriteLine(&quot;Hello&quot;);
        &#125;
        Console.WriteLine(a);
    &#125;
&#125;
</code></pre>
<p>}</p>
<pre class="line-numbers language-none"><code class="language-none">
- 结果为3

- **条件与，由于x&gt;y为False，所以右边的a++&gt;3压根不执行**

- &#96;&#96;&#96;c#
  using System;
  
  namespace ConversionExample
  &#123;
      class Program
      &#123;
          static void Main(string[] args)
          &#123;
              int x &#x3D; 5;
              int y &#x3D; 4;
              int a &#x3D; 3;
              if (x &gt; 3 || a++ &gt; 3)
              &#123;
                  Console.WriteLine(&quot;Hello&quot;);
              &#125;
              Console.WriteLine(a);
          &#125;
      &#125;
  
  &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>结果为</p>
<pre class="line-numbers language-none"><code class="language-none">Hello
3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li>
<li><p><strong>条件或，由于x&gt;y为True，所以右边的a++&gt;3压根不执行</strong></p>
</li>
<li><p>我们需要避免短路效应</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>可空类型</p>
<ul>
<li>```<br>Nullable<int> x = null;<pre><code>     x = 100;
     Console.WriteLine(x);
     Console.WriteLine(x.HasValue);
</code></pre>
<pre class="line-numbers language-none"><code class="language-none">
- &#96;&#96;&#96;
  100
  True<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></int></li>
</ul>
</li>
</ul>
<h2 id="8-表达式，语句详解"><a href="#8-表达式，语句详解" class="headerlink" title="8. 表达式，语句详解"></a>8. 表达式，语句详解</h2><h3 id="8-1-表达式的定义"><a href="#8-1-表达式的定义" class="headerlink" title="8.1 表达式的定义"></a>8.1 表达式的定义</h3><h4 id="8-1-1-什么是表达式-Expressions"><a href="#8-1-1-什么是表达式-Expressions" class="headerlink" title="8.1.1 什么是表达式(Expressions)"></a>8.1.1 什么是表达式(Expressions)</h4><ul>
<li>《Programming Languages:Principles and Paradigms》这本书是这样定义的表达式<ul>
<li>表达式是任何一门编程语言的<strong>基本组件之一</strong>，基本组件还有命令(commands)和声明(declarations)，表达式是任何一门编程语言的<strong>核心组件</strong></li>
<li>表达式一种语法实体，表达式就是用来求值，<strong>成功得到一个产出值，失败将得到一个终值</strong></li>
<li>各种编程语言对表达式的实现不尽相同，但答题</li>
</ul>
</li>
</ul>
<h4 id="8-1-2-C-语言对表达式的定义"><a href="#8-1-2-C-语言对表达式的定义" class="headerlink" title="8.1.2 C#语言对表达式的定义"></a>8.1.2 C#语言对表达式的定义</h4><ul>
<li>一个表达式是由<strong>一个或多个操作数</strong>和<strong>零个或多个操作符</strong></li>
<li>算法逻辑的最基本（最小）单元，表达一定的算法意图</li>
<li>因为操作符有优先级，所以表达式也就有了优先级</li>
</ul>
<h3 id="8-2-各类表达式概览"><a href="#8-2-各类表达式概览" class="headerlink" title="8.2 各类表达式概览"></a>8.2 各类表达式概览</h3><h4 id="8-2-1-C-语言中表达式的分类"><a href="#8-2-1-C-语言中表达式的分类" class="headerlink" title="8.2.1 C#语言中表达式的分类"></a>8.2.1 C#语言中表达式的分类</h4><ul>
<li> A value.一个值，任何能得到值的运算</li>
<li> A variable. 一个变量</li>
<li> ……</li>
<li> A method group.例如：Console.WriteLine，这是一组方法，重载决策决定具体调用哪一个</li>
<li> <code>Console.WriteLine(&quot;Hello&quot;);</code>是两个表达式，Console.WriteLine 通过成员访问使用了一组方法，然后通过方法调用选择了一组最适合重载决策来执行</li>
<li> 符合表达式需要注意操作符的优先级和同优先级操作符的运算方向</li>
</ul>
<h3 id="8-3-语句（Statement）的定义"><a href="#8-3-语句（Statement）的定义" class="headerlink" title="8.3 语句（Statement）的定义"></a>8.3 语句（Statement）的定义</h3><h4 id="8-3-1-Wikipedia对语句的定义"><a href="#8-3-1-Wikipedia对语句的定义" class="headerlink" title="8.3.1 Wikipedia对语句的定义"></a>8.3.1 Wikipedia对语句的定义</h4><ul>
<li><p>在计算机编程学科范畴里，语句是命令式编程语言（大多是我们的高级语言）独立的（standalong）最小的独立元素，语句是表达一些将被执行的动作（action）,一个由命令式编程语言所写成的程序实际上就是由一系列语句构成的</p>
</li>
<li><p>语句是高级语言的语法——编译语言和机器语言只有指令（高级语言中的表达式对应低级语言中的指令），<strong>语句等价于一个或一组由明显逻辑关联的指令</strong>。例如：求圆柱体积</p>
</li>
<li><p>不严格的讲：</p>
<ul>
<li>高级语言由一系列语句构成</li>
<li>低级语言由一系列指令构成</li>
</ul>
</li>
<li><p>C#查看汇编语言，源代码如下</p>
</li>
<li><p>```c#<br>using System;<br>using System.Collections.Generic;<br>using System.Linq;<br>using System.Text;<br>using System.Threading.Tasks;</p>
<p>namespace CsharpApp<br>{</p>
<pre><code>class Program
&#123;
    static void Main(string[] args)
    &#123;
        double result = GetCylinderVolume(10, 100);
        Console.WriteLine(result);
    &#125;

    static double GetCylinderVolume(double r, double h)
    &#123;
        double area = 3.1416 * r * h;
        double volume = area * h;
        return volume;
    &#125;
&#125;
</code></pre>
<p>}</p>
<pre class="line-numbers language-none"><code class="language-none">
- 右键解决方案在文件资源管理器中打开文件，然后将bin&#x2F;debug目录下的exe文件复制到桌面

- 打开Developer Command Prompt for VS 2019输入ildasn

  - ![image-20220913200549175](C:\Users\8y\AppData\Roaming\Typora\typora-user-images\image-20220913200549175.png)
  - il是中间语言，dasm是反编译
  - ![image-20220913200602519](C:\Users\8y\AppData\Roaming\Typora\typora-user-images\image-20220913200602519.png)

- 打开桌面的exe文件

- ![image-20220913200858748](C:\Users\8y\AppData\Roaming\Typora\typora-user-images\image-20220913200858748.png)

- ![image-20220913200954524](C:\Users\8y\AppData\Roaming\Typora\typora-user-images\image-20220913200954524.png)



#### 8.3.2 C#对语句的定义

- C#语言的语句除了能够让程序员“顺序地”（sequentially）表达算法思想，还能通过条件判断、跳转和循环等方法控制程序逻辑的走向
- 简言之就是：陈述算法思想，控制逻辑走向，完成**有意义的**动作（action）
- C#语言的语句由分号（；）结尾，但由分号结尾的不一定都是语句
  - 例如在一个类里定义一个变量
  - &#96;public string name;&#96;
- 语句一定是出现在方法体里



### 8.4 语句详解

![image-20220913203325417](C:\Users\8y\AppData\Roaming\Typora\typora-user-images\image-20220913203325417.png)

- 横线以上是基础，以下相对来说高级一点

- C#语句一共有三大类

  - 标签语句（labeled-statement）

  - 声明语句（declaration-statement）

  - 嵌入式语句（embedded-statement）

    - 例如

      &#96;&#96;&#96;c#
      if(5 &gt; 3)
      &#123;
      	Console.WriteLine(&quot;Hello&quot;);
      &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>Console.WriteLine(“Hello”);语句嵌套在IF语句里</li>
</ul>
</li>
<li><p>不是所有表达式都可以作为语句使用</p>
</li>
<li><p>例如<code>x+y</code>，<code>x==1</code>等这样只计算一个值（此值将被放弃）的表达式不能作为语句使用</p>
</li>
<li><p>单一原则：一个方法尽量只做一件事情</p>
<ul>
<li><p>例如</p>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">static double GetCylinderVolume(double r, double h)
        &#123;
            double area &#x3D; 3.1416 * r * h;
            double volume &#x3D; area * h;
            Console.WriteLine(volume);
            return volume;
        &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>这个方法计算了体积，又输出了体积</p>
</li>
</ul>
</li>
<li><p>块语句</p>
<ul>
<li><p>在方法体里写一对{}就是空的块语句</p>
</li>
<li><p>{}里无论多少代码都是<strong>一条语句</strong></p>
</li>
<li><p>```c#<br>using System;<br>using System.Collections.Generic;<br>using System.Linq;<br>using System.Text;<br>using System.Threading.Tasks;</p>
<p>namespace StatementsExample<br>{</p>
<pre><code>class Program
&#123;
    static void Main(string[] args)
    &#123;
        //块语句,可以写C#中的任何语句
        &#123;
            hello: Console.WriteLine(&quot;Hello,World!&quot;);   //标签语句
            
        &#125;
    &#125;
&#125;
</code></pre>
<p>}</p>
<pre class="line-numbers language-none"><code class="language-none">
  - 小技巧：Ctrl+&#125;可以让光标快速移动到一段程序的头尾

  - 在块语句之前声明的变量，在块语句中可见，但是在块语句之内声明的变量，出了块语句不可见

- if语句

  - 整个if语句是一条语句

  - 如果不加&#123;&#125;(块语句)

    - if（布尔类型表达式）后面只能跟一句嵌入式语句，不能跟声明语句或者是标签语句

    - 例如，以下两个写法均是不合法的
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>  if (true) int x = 1;<br>  if (true) hello: Console.WriteLine(“Hello,World!”);</p>
  <pre class="line-numbers language-none"><code class="language-none">
  - 逻辑优化就做代码的重构

- switch语句

  - ![image-20220914115142772](C:\Users\8y\AppData\Roaming\Typora\typora-user-images\image-20220914115142772.png)

  - &#96;&#96;&#96;c#
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Text;
    using System.Threading.Tasks;
    
    namespace StatementsExample
    &#123;
        class Program
        &#123;
            static void Main(string[] args)
            &#123;
                &#x2F;&#x2F;需求：80~100 -&gt; A;60~79 -&gt; B;40~59 -&gt;C;0~39 -&gt;D
                int score &#x3D; 98;
                switch (score&#x2F;10)
                &#123;
                    case 10:
                        if (score &#x3D;&#x3D; 100)
                        &#123;
                            goto case 8;
                        &#125;
                        else
                        &#123;
                            goto default;
                        &#125;
                    case 9:
                    case 8:
                        Console.WriteLine(&quot;A&quot;);
                        break;
                    case 7:
                    case 6:
                        Console.WriteLine(&quot;B&quot;);
                        break;
                    case 5:
                    case 4:
                        Console.WriteLine(&quot;C&quot;);
                        break;
                    case 3:
                    case 2:
                    case 1:
                    case 0:
                        Console.WriteLine(&quot;D&quot;);
                        break;
                    default:
                        break;
                &#125;
    
            &#125;
        &#125;
    &#125;
    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>和枚取配合很好用</p>
</li>
</ul>
</li>
<li><p>try语句</p>
<ul>
<li><p>让方法具有容错能力</p>
</li>
<li><p>举个例子</p>
<ul>
<li><p>```c#<br>using System;<br>using System.Collections.Generic;<br>using System.Linq;<br>using System.Text;<br>using System.Threading.Tasks;</p>
<p>namespace StatementsExample<br>{</p>
<pre><code>class Program
&#123;
    static void Main(string[] args)
    &#123;
        Calculator c = new Calculator();
        int r = c.Add(&quot;100&quot;, &quot;200&quot;);
        Console.WriteLine(r);
    &#125;
&#125;

class Calculator
&#123;
    public int Add(string arg1,string arg2)
    &#123;
        int a = int.Parse(arg1);
        int b = int.Parse(arg2);
        int result = a + b;
        return result;
    &#125;
&#125;
</code></pre>
<p>}</p>
<pre class="line-numbers language-none"><code class="language-none">
- 这段代码有很多地方容易出现bug

- 例如将&#96;int r &#x3D; c.Add(&quot;100&quot;, &quot;200&quot;);&#96;更改为&#96;int r &#x3D; c.Add(&quot;abc&quot;, &quot;200&quot;);&#96;就会抛出异常

- 最精细的异常处理就是在每个可能出现问题的地方+checked

- 比较简易的异常处理就是直接加上try语句

- &#96;&#96;&#96;c#
  using System;
  using System.Collections.Generic;
  using System.Linq;
  using System.Text;
  using System.Threading.Tasks;
  
  namespace StatementsExample
  &#123;
      class Program
      &#123;
          static void Main(string[] args)
          &#123;
              Calculator c &#x3D; new Calculator();
              int r &#x3D; c.Add(&quot;null&quot;, &quot;200&quot;);
              Console.WriteLine(r);
          &#125;
      &#125;
  
      class Calculator
      &#123;
          public int Add(string arg1,string arg2)
          &#123;
              int a&#x3D;0;
              int b&#x3D;0;
              try
              &#123;
                  a &#x3D; int.Parse(arg1);
                  b &#x3D; int.Parse(arg2);
              &#125;
              catch
              &#123;
                  Console.WriteLine(&quot;Your argument(s) have error!&quot;);
              &#125;
              int result &#x3D; a + b;
              return result;
          &#125;
      &#125;
  &#125;
  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>运行结果如下：</p>
</li>
<li><p>```<br>Your argument(s) have error!<br>0</p>
<pre class="line-numbers language-none"><code class="language-none">
- 如何使用try语句精确的处理各类异常

- 我们知道int32类型有3种异常

  - ArgumentNullException  null
  - FormatException     格式错误
  - OverflowException  溢出

- &#96;&#96;&#96;c#
  using System;
  using System.Collections.Generic;
  using System.Linq;
  using System.Text;
  using System.Threading.Tasks;
  
  namespace StatementsExample
  &#123;
      class Program
      &#123;
          static void Main(string[] args)
          &#123;
              Calculator c &#x3D; new Calculator();
              int r &#x3D; c.Add(&quot;null&quot;, &quot;200&quot;);
              Console.WriteLine(r);
          &#125;
      &#125;
  
      class Calculator
      &#123;
          public int Add(string arg1,string arg2)
          &#123;
              int a&#x3D;0;
              int b&#x3D;0;
              try
              &#123;
                  a &#x3D; int.Parse(arg1);
                  b &#x3D; int.Parse(arg2);
              &#125;
              catch(ArgumentNullException)
              &#123;
                  Console.WriteLine(&quot;Your argument(s) have error!&quot;);
              &#125;
              catch (FormatException)
              &#123;
                  Console.WriteLine(&quot;Your argument(s) are not number !&quot;);
              &#125;
              catch (OverflowException)
              &#123;
                  Console.WriteLine(&quot;Out of range!&quot;);
              &#125;
              int result &#x3D; a + b;
              return result;
          &#125;
      &#125;
  &#125;
  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>运行结果如下：</p>
</li>
<li><p>```<br>Your argument(s) have error!<br>0</p>
<pre class="line-numbers language-none"><code class="language-none">
- 代码也可以改为

- &#96;&#96;&#96;c#
  using System;
  using System.Collections.Generic;
  using System.Linq;
  using System.Text;
  using System.Threading.Tasks;
  
  namespace StatementsExample
  &#123;
      class Program
      &#123;
          static void Main(string[] args)
          &#123;
              Calculator c &#x3D; new Calculator();
              int r &#x3D; c.Add(&quot;9999999999999999&quot;, &quot;200&quot;);
              Console.WriteLine(r);
          &#125;
      &#125;
  
      class Calculator
      &#123;
          public int Add(string arg1,string arg2)
          &#123;
              int a&#x3D;0;
              int b&#x3D;0;
              try
              &#123;
                  a &#x3D; int.Parse(arg1);
                  b &#x3D; int.Parse(arg2);
              &#125;
              catch(ArgumentNullException ane)
              &#123;
                  Console.WriteLine(ane.Message);
              &#125;
              catch (FormatException fe)
              &#123;
                  Console.WriteLine(fe.Message);
              &#125;
              catch (OverflowException ofe)
              &#123;
                  Console.WriteLine(ofe.Message);
              &#125;
              int result &#x3D; a + b;
              return result;
          &#125;
      &#125;
  &#125;
  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>运行结果如下：</p>
</li>
<li><p>```<br>值对于 Int32 太大或太小。<br>0</p>
<pre class="line-numbers language-none"><code class="language-none">
- 我们在finally语句中一般写**释放系统资源的语句**，例如数据库连接，无论在执行代码过程中是否发生异常，数据库连接都能正常关闭，这样我们的软件系统就不会出现问题了

- &#96;&#96;&#96;c#
  using System;
  using System.Collections.Generic;
  using System.Linq;
  using System.Text;
  using System.Threading.Tasks;
  
  namespace StatementsExample
  &#123;
      class Program
      &#123;
          static void Main(string[] args)
          &#123;
              Calculator c &#x3D; new Calculator();
              int r &#x3D; c.Add(&quot;9999999999999999&quot;, &quot;200&quot;);
              Console.WriteLine(r);
          &#125;
      &#125;
  
      class Calculator
      &#123;
          public int Add(string arg1,string arg2)
          &#123;
              int a&#x3D;0;
              int b&#x3D;0;
              bool hasError &#x3D; false;
              try
              &#123;
                  a &#x3D; int.Parse(arg1);
                  b &#x3D; int.Parse(arg2);
              &#125;
              catch(ArgumentNullException ane)
              &#123;
                  Console.WriteLine(ane.Message);
                  hasError &#x3D; true;
              &#125;
              catch (FormatException fe)
              &#123;
                  Console.WriteLine(fe.Message);
                  hasError &#x3D; true;
              &#125;
              catch (OverflowException ofe)
              &#123;
                  Console.WriteLine(ofe.Message);
                  hasError &#x3D; true;
              &#125;
              finally
              &#123;
                  if (hasError)
                  &#123;
                      Console.WriteLine(&quot;Execution has Error!&quot;);
                  &#125;
                  else
                  &#123;
                      Console.WriteLine(&quot;Done!&quot;);
                  &#125;
              &#125;
              int result &#x3D; a + b;
              return result;
          &#125;
      &#125;
  &#125;
  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>运行结果如下：</p>
</li>
<li><p>```<br>值对于 Int32 太大或太小。<br>Execution has Error!<br>0</p>
<pre class="line-numbers language-none"><code class="language-none">
- throw语句

  - 不再直接处理，谁调用谁处理

  - &#96;&#96;&#96;c#
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Text;
    using System.Threading.Tasks;
    
    namespace StatementsExample
    &#123;
        class Program
        &#123;
            static void Main(string[] args)
            &#123;
                Calculator c &#x3D; new Calculator();
                int r&#x3D;0;
                try
                &#123;
                    r &#x3D; c.Add(&quot;9999999999999999&quot;, &quot;200&quot;);
                &#125;
                catch (OverflowException oe)
                &#123;
    
                    Console.WriteLine(oe.Message);
                &#125;
                Console.WriteLine(r);
            &#125;
        &#125;
    
        class Calculator
        &#123;
            public int Add(string arg1,string arg2)
            &#123;
                int a&#x3D;0;
                int b&#x3D;0;
                try
                &#123;
                    a &#x3D; int.Parse(arg1);
                    b &#x3D; int.Parse(arg2);
                &#125;
                catch(ArgumentNullException ane)
                &#123;
                    Console.WriteLine(ane.Message);
                &#125;
                catch (FormatException fe)
                &#123;
                    Console.WriteLine(fe.Message);
                &#125;
                catch (OverflowException ofe)
                &#123;
                    &#x2F;&#x2F;Console.WriteLine(ofe.Message);
                    throw ofe;  &#x2F;&#x2F;也可以直接写throw;
                &#125;
                int result &#x3D; a + b;
                return result;
            &#125;
        &#125;
    &#125;
    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><p>运行结果如下：</p>
</li>
<li><p>```<br>值对于 Int32 太大或太小。<br>0</p>
<pre class="line-numbers language-none"><code class="language-none">
        

- 迭代语句和跳转语句

  - 迭代语句就是我们常说的循环语句

  - while语句执行0次或多次，do语句则执行1次或多次

  - 使用while语句写一个简单的小游戏：

    - 要求是让两个小朋友输入2个数，如果这两个数的和是100，记1分，继续输入，如果两个数的和不是100，则停止，计算总分并输出

    - &#96;&#96;&#96;c#
      using System;
      using System.Collections.Generic;
      using System.Linq;
      using System.Text;
      using System.Threading.Tasks;
      
      namespace StatementsExample
      &#123;
          class Program
          &#123;
              static void Main(string[] args)
              &#123;
                  int score &#x3D; 0;
                  bool canContinue &#x3D; true;
                  while (canContinue)
                  &#123;
                      Console.WriteLine(&quot;Please input first number:&quot;);
                      string str1 &#x3D; Console.ReadLine();
                      int x &#x3D; int.Parse(str1);
      
                      Console.WriteLine(&quot;Please input second number:&quot;);
                      string str2 &#x3D; Console.ReadLine();
                      int y &#x3D; int.Parse(str2);
      
                      int sum &#x3D; x + y;
                      if (sum &#x3D;&#x3D; 100)
                      &#123;
                          score++;
                          Console.WriteLine($&quot;Correct!&#123;x&#125;+&#123;y&#125;&#x3D;&#123;sum&#125;&quot;);
                      &#125;
                      else
                      &#123;
                          Console.WriteLine($&quot;Error!&#123;x&#125;+&#123;y&#125;&#x3D;&#123;sum&#125;&quot;);
                          canContinue &#x3D; false;
                      &#125;
                  &#125;
                  Console.WriteLine($&quot;Your score is &#123;score&#125;&quot;);
                  Console.WriteLine(&quot;GAME OVER!&quot;);
              &#125;
          &#125;
      
      &#125;
      <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
</li>
<li><p>改写成do语句更适合这个游戏的逻辑，同时还可优化少一个布尔值</p>
</li>
<li><p>```c#<br>using System;<br>using System.Collections.Generic;<br>using System.Linq;<br>using System.Text;<br>using System.Threading.Tasks;</p>
<p>namespace StatementsExample<br>{</p>
<pre><code>class Program
&#123;
    static void Main(string[] args)
    &#123;
        int score = 0;
        int sum=100;
        do
        &#123;
            Console.WriteLine(&quot;Please input first number:&quot;);
            string str1 = Console.ReadLine();
            int x = int.Parse(str1);

            Console.WriteLine(&quot;Please input second number:&quot;);
            string str2 = Console.ReadLine();
            int y = int.Parse(str2);

            sum = x + y;
            if (sum == 100)
            &#123;
                score++;
                Console.WriteLine($&quot;Correct!&#123;x&#125;+&#123;y&#125;=&#123;sum&#125;&quot;);
            &#125;
            else
            &#123;
                Console.WriteLine($&quot;Error!&#123;x&#125;+&#123;y&#125;=&#123;sum&#125;&quot;);
            &#125;
        &#125; while (sum == 100);
        Console.WriteLine($&quot;Your score is &#123;score&#125;&quot;);
        Console.WriteLine(&quot;GAME OVER!&quot;);
    &#125;
&#125;
</code></pre>
<p>}</p>
<pre class="line-numbers language-none"><code class="language-none">
- 使用try语句对程序可能存在的隐患进行处理，同时使用跳转语句continue

- &#96;&#96;&#96;c#
  using System;
  using System.Collections.Generic;
  using System.Linq;
  using System.Text;
  using System.Threading.Tasks;
  
  namespace StatementsExample
  &#123;
      class Program
      &#123;
          static void Main(string[] args)
          &#123;
              int score &#x3D; 0;
              int sum&#x3D;100;
              do
              &#123;
                  Console.WriteLine(&quot;Please input first number:&quot;);
                  string str1 &#x3D; Console.ReadLine();
                  int x &#x3D; 0;
                  int y &#x3D; 0;
                  try
                  &#123;
                      x &#x3D; int.Parse(str1);    &#x2F;&#x2F;可能存在隐患的语句
                  &#125;
                  catch 
                  &#123;
                      Console.WriteLine(&quot;The first number has problem!Restart:&quot;);
                      continue;
                  &#125;
  
                  Console.WriteLine(&quot;Please input second number:&quot;);
                  string str2 &#x3D; Console.ReadLine();
                  try
                  &#123;
                      y &#x3D; int.Parse(str2);   &#x2F;&#x2F;可能存在隐患的语句
                  &#125;
                  catch
                  &#123;
                      Console.WriteLine(&quot;The second number has problem!Restart:&quot;);
                      continue;
                  &#125;
                  
                  sum &#x3D; x + y;
                  if (sum &#x3D;&#x3D; 100)
                  &#123;
                      score++;
                      Console.WriteLine($&quot;Correct!&#123;x&#125;+&#123;y&#125;&#x3D;&#123;sum&#125;&quot;);
                  &#125;
                  else
                  &#123;
                      Console.WriteLine($&quot;Error!&#123;x&#125;+&#123;y&#125;&#x3D;&#123;sum&#125;&quot;);
                  &#125;
              &#125; while (sum &#x3D;&#x3D; 100);
              Console.WriteLine($&quot;Your score is &#123;score&#125;&quot;);
              Console.WriteLine(&quot;GAME OVER!&quot;);
          &#125;
      &#125;
  
  &#125;
  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>增加需求，如果其中有一个小朋友玩腻了输入end，则结束循环</p>
</li>
<li><p>```c#<br>using System;<br>using System.Collections.Generic;<br>using System.Linq;<br>using System.Text;<br>using System.Threading.Tasks;</p>
<p>namespace StatementsExample<br>{</p>
<pre><code>class Program
&#123;
    static void Main(string[] args)
    &#123;
        int score = 0;
        int sum=100;
        do
        &#123;
            Console.WriteLine(&quot;Please input first number:&quot;);
            string str1 = Console.ReadLine();
            if (str1.ToLower() == &quot;end&quot;)
            &#123;
                break;
            &#125;
            int x = 0;
            int y = 0;
            try
            &#123;
                x = int.Parse(str1);    //可能存在隐患的语句
            &#125;
            catch 
            &#123;
                Console.WriteLine(&quot;The first number has problem!Restart:&quot;);
                continue;
            &#125;

            Console.WriteLine(&quot;Please input second number:&quot;);
            string str2 = Console.ReadLine();
            if (str2.ToLower() == &quot;end&quot;)
            &#123;
                break;
            &#125;
            try
            &#123;
                y = int.Parse(str2);   //可能存在隐患的语句
            &#125;
            catch
            &#123;
                Console.WriteLine(&quot;The second number has problem!Restart:&quot;);
                continue;
            &#125;
            
            sum = x + y;
            if (sum == 100)
            &#123;
                score++;
                Console.WriteLine($&quot;Correct!&#123;x&#125;+&#123;y&#125;=&#123;sum&#125;&quot;);
            &#125;
            else
            &#123;
                Console.WriteLine($&quot;Error!&#123;x&#125;+&#123;y&#125;=&#123;sum&#125;&quot;);
            &#125;
        &#125; while (sum == 100);
        Console.WriteLine($&quot;Your score is &#123;score&#125;&quot;);
        Console.WriteLine(&quot;GAME OVER!&quot;);
    &#125;
&#125;
</code></pre>
<p>}</p>
<pre class="line-numbers language-none"><code class="language-none">
- 什么样的集合能够被迭代

  - &#96;&#96;&#96;c#
    using System;
    using System.Collections.Generic;
    
    namespace StatementsExample
    &#123;
        class Program
        &#123;
            static void Main(string[] args)
            &#123;
                int[] intArray &#x3D; new int[] &#123; 1, 2, 3 &#125;;
                Console.WriteLine(intArray.GetType());
                Console.WriteLine(intArray is Array);
            &#125;
        &#125;
    
    &#125;
    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>```<br>System.Int32[]<br>True</p>
<pre class="line-numbers language-none"><code class="language-none">
  

- 当你发现一个数据类型是[]结尾，那么这个数据类型就是数组类型

- C#中所有数组的基类是Array

- 如果你发现一个单词的首字母是I开头的类，那么这就是一个接口，I是Interface的缩写

- GetEnumerator，Enumerator 刘老师讲的是迭代器

- &#96;&#96;&#96;c#
  using System;
  using System.Collections.Generic;
  using System.Collections;	&#x2F;&#x2F;需要引用的名称空间
  
  
  namespace StatementsExample
  &#123;
      class Program
      &#123;
          static void Main(string[] args)
          &#123;
              &#x2F;&#x2F;int[]是Array的子类，所以int[]也天然继承了IEnumerator接口的GetEnumerator方法
              int[] intArray &#x3D; new int[] &#123; 1, 2, 3 &#125;;
              IEnumerator enumerator &#x3D; intArray.GetEnumerator();  &#x2F;&#x2F;指月
              &#x2F;&#x2F;IEnumerator是可以被遍历的集合
              &#x2F;&#x2F;GetEnumerator获得这个集合的迭代器
              while (enumerator.MoveNext())   &#x2F;&#x2F;返回一个布尔类型，如果迭代器可以向后移动返回True
              &#123;
                  Console.WriteLine(enumerator.Current);  &#x2F;&#x2F;返回当前正在访问的元素
              &#125;
              enumerator.Reset(); &#x2F;&#x2F;把迭代器拨回集合的最开始
              while (enumerator.MoveNext())
              &#123;
                  Console.WriteLine(enumerator.Current);
              &#125;
              &#x2F;&#x2F;泛型
              List&lt;int&gt; intList &#x3D; new List&lt;int&gt; &#123; 4, 5, 6 &#125;;
              IEnumerator enumerator2 &#x3D; intList.GetEnumerator();  &#x2F;&#x2F;指月
              while (enumerator2.MoveNext())
              &#123;
                  Console.WriteLine(enumerator2.Current);
              &#125;
          &#125;
      &#125;
  
  &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>运行结果如下：</p>
</li>
<li><p>```<br>1<br>2<br>3<br>1<br>2<br>3<br>4<br>5<br>6</p>
<pre class="line-numbers language-none"><code class="language-none">
    

- foreach语句

  - &#96;&#96;&#96;c#
    using System;
    using System.Collections.Generic;
    using System.Collections;
    
    
    namespace StatementsExample
    &#123;
        class Program
        &#123;
            static void Main(string[] args)
            &#123;
                
                int[] intArray &#x3D; new int[] &#123; 1, 2, 3 &#125;;
                foreach(var iA in intArray)
                &#123;
                    Console.WriteLine(iA);
                &#125;
            &#125;
        &#125;
    
    &#125;
    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>相比上面的迭代语句，方便很多</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>


<h2 id="9-字段、属性、索引器、常量"><a href="#9-字段、属性、索引器、常量" class="headerlink" title="9. 字段、属性、索引器、常量"></a>9. 字段、属性、索引器、常量</h2><h3 id="9-1-字段"><a href="#9-1-字段" class="headerlink" title="9.1 字段"></a>9.1 字段</h3><h4 id="9-1-1-什么是字段"><a href="#9-1-1-什么是字段" class="headerlink" title="9.1.1 什么是字段"></a>9.1.1 什么是字段</h4><ul>
<li><p>字段（field）是一种表示与对象或类型（<strong>类与结构体</strong>）关联的变量</p>
<ul>
<li>field在英文中的田地的意思 字段是数据存放的空间</li>
</ul>
</li>
<li><p>字段是类型的成员，旧称”成员变量“</p>
</li>
<li><p>与对象关联的字段亦称”实例字段“</p>
</li>
<li><p>与类型关联的字段称为”静态字段“，由static修饰</p>
</li>
<li><p>```c#<br>using System;<br>using System.Collections.Generic;<br>using System.Linq;<br>using System.Text;<br>using System.Threading.Tasks;</p>
<p>namespace DataMemberExample<br>{</p>
<pre><code>class Program
&#123;
    static void Main(string[] args)
    &#123;
        List&lt;Student&gt; stuList = new List&lt;Student&gt;();
        for (int i = 0; i &lt; 100; i++)
        &#123;
            Student stu = new Student();
            stu.Age = 24;
            stu.Score = i;
            stuList.Add(stu);
        &#125;

        int totalAge = 0;
        int totalScore = 0;
        foreach (var stu in stuList)
        &#123;
            totalAge += stu.Age;
            totalScore += stu.Score;
        &#125;
        Student.AverageAge = totalAge / Student.Amount;
        Student.AverageScore = totalScore / Student.Amount;

        Student.ReportAmount();
        Student.ReportAverageAge();
        Student.ReportAverageScore();
    &#125;
&#125;

class Student
&#123;
    //实例字段，与对象关联
    public int Age;
    public int Score;

    //静态字段，与类型关联
    public static int AverageAge;
    public static int AverageScore;
    public static int Amount;

    public Student()
    &#123;
        Student.Amount++;
    &#125;

    public static void ReportAmount()
    &#123;
        Console.WriteLine(Student.Amount);
    &#125;

    public static void ReportAverageAge()
    &#123;
        Console.WriteLine(Student.AverageAge);
    &#125;

    public static void ReportAverageScore()
    &#123;
        Console.WriteLine(Student.AverageScore);
    &#125;
&#125;
</code></pre>
<p>}</p>
<pre class="line-numbers language-none"><code class="language-none">
- 运行结果如下：

- &#96;&#96;&#96;
  100
  24
  49<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
<h4 id="9-1-2-字段的声明"><a href="#9-1-2-字段的声明" class="headerlink" title="9.1.2 字段的声明"></a>9.1.2 字段的声明</h4><ul>
<li>参见C#语言定义文档</li>
<li>尽管字段声明带有分号，但它不是语句</li>
<li>字段的名字一定是名词</li>
</ul>
<h4 id="9-1-3-字段的初始化"><a href="#9-1-3-字段的初始化" class="headerlink" title="9.1.3 字段的初始化"></a>9.1.3 字段的初始化</h4><ul>
<li><p>无显示初始化时，字段获得其类型的默认值，所以字段”永远不会未被初始化“</p>
</li>
<li><p>实例字段初始化的时机——对象创建时</p>
</li>
<li><p>静态字段初始化的时机——类型被加载（load）时</p>
<ul>
<li>静态构造器被执行的时候</li>
</ul>
</li>
<li><p>在声明字段的时候赋初始值和在写构造器时赋值是一样的</p>
</li>
<li><p>静态构造器</p>
<ul>
<li>```c#<br>public static int Amount=100;<br>static student    //注意不加public<br>{<pre><code>Amount=100;
</code></pre>
}<pre class="line-numbers language-none"><code class="language-none">
  - 以上的写法也是等价的

  

#### 9.1.4 只读字段

- 实例只读字段

  - &#96;public readonly int ID&#96; **只读实例字段**，只能初始化一次

  - &#96;&#96;&#96;c#
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Text;
    using System.Threading.Tasks;
    
    namespace DataMemberExample
    &#123;
        class Program
        &#123;
            static void Main(string[] args)
            &#123;
                Student stu &#x3D; new Student(1);
                stu.ID &#x3D; 2;	&#x2F;&#x2F;无法编译通过
            &#125;
        &#125;
    
        class Student
        &#123;
            public readonly int ID;	&#x2F;&#x2F;实例只读字段
            public Student(int id)
            &#123;
                this.ID &#x3D; id;
            &#125;
    
        &#125;
    &#125;
    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
</li>
<li><p>静态只读字段</p>
<ul>
<li><p>类的静态只读字段</p>
</li>
<li><p>只能够被初始化，不能再被赋值</p>
</li>
<li><p>```c#<br>using System;<br>using System.Collections.Generic;<br>using System.Linq;<br>using System.Text;<br>using System.Threading.Tasks;</p>
<p>namespace DataMemberExample<br>{</p>
<pre><code>class Program
&#123;
    static void Main(string[] args)
    &#123;
        Console.WriteLine(Brush.DefaultColor.Red);
        Console.WriteLine(Brush.DefaultColor.Green);
        Console.WriteLine(Brush.DefaultColor.Blue);
    &#125;
&#125;

struct Color 
&#123;
    public int Red;
    public int Green;
    public int Blue;
&#125;

class Brush
&#123;
    public static readonly Color DefaultColor = new Color() &#123; Red = 0, Green = 0, Blue = 0 &#125;;
&#125;
</code></pre>
<p>}</p>
<pre class="line-numbers language-none"><code class="language-none">
  - 静态构造函数只需要把public改成static即可

### 9.2 属性

#### 9.2.1 什么是属性

- 属性（property）是一种用于&lt;font color&#x3D;blue&gt;访问对象或类型的特征&lt;&#x2F;font&gt;的成员，&lt;font color&#x3D;blue&gt;特征反应了状态&lt;&#x2F;font&gt;

- 属性是字段的自然扩展

  - 从命名上看，field（字段）更偏向于实例对象在内存中的布局，property（属性）更偏于反映现实世界对象的特征
  - 对外：暴露数据，数据可以是存储在字段里的，也可以是动态计算出来的
  - 对内：保护字段不被非法值”污染“

- 属性由Get&#x2F;Set方法对进化而来

- 又一个”语法糖“——属性背后的秘密

- 示例如下：

- &#96;&#96;&#96;c#
  using System;
  using System.Collections.Generic;
  using System.Linq;
  using System.Text;
  using System.Threading.Tasks;
  
  namespace DataMemberExample
  &#123;
      class Program
      &#123;
          static void Main(string[] args)
          &#123;
              Student stu1 &#x3D; new Student();
              stu1.Age &#x3D; 20;
  
              Student stu2 &#x3D; new Student();
              stu2.Age &#x3D; 20;
  
              Student stu3 &#x3D; new Student();
              stu3.Age &#x3D; 200;	&#x2F;&#x2F;非法值
  
              int avgAge &#x3D; (stu1.Age + stu2.Age + stu3.Age);
              Console.WriteLine(avgAge);
          &#125;
      &#125;
  
      class Student
      &#123;
          public int Age;	&#x2F;&#x2F;使用字段，首字母大写
      &#125;
  &#125;
  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
</li>
<li><p>我们知道200岁对于人类来说是1个非法值，如果直接用字段，这个字段就被污染了</p>
</li>
<li><p>可以改成如下写法进行保护字段，C++/JAVA目前仍然采用的方法</p>
</li>
<li><p>```c#<br>using System;</p>
<p>namespace DataMemberExample<br>{</p>
<pre><code>class Program
&#123;
    static void Main(string[] args)
    &#123;
        Student stu1 = new Student();
        stu1.setAge(20);

        Student stu2 = new Student();
        stu2.setAge(20);

        Student stu3 = new Student();
        stu3.setAge(20);

        int avgAge = (stu1.getAge() + stu2.getAge() + stu3.getAge())/3;
        Console.WriteLine(avgAge);
    &#125;
&#125;

class Student
&#123;
    private int age; 

    public void setAge(int value)
    &#123;
        if(value &gt;=0 &amp;&amp; value &lt;= 120)
        &#123;
            this.age = value;
        &#125;
        else
        &#123;
            Console.WriteLine(&quot;age value has error!&quot;);
        &#125;
    &#125;

    public int getAge()
    &#123;
        return age;
    &#125;
&#125;
</code></pre>
<p>}</p>
<pre class="line-numbers language-none"><code class="language-none">
- 说明C++&#x2F;JAVA是没有属性这个概念的

- &#96;&#96;&#96;c#
  using System;
  
  namespace DataMemberExample
  &#123;
      class Program
      &#123;
          static void Main(string[] args)
          &#123;
              Student stu1 &#x3D; new Student();
              stu1.Age&#x3D;20;
  
              Student stu2 &#x3D; new Student();
              stu2.Age&#x3D;20;
  
              Student stu3 &#x3D; new Student();
              stu3.Age&#x3D;20;
  
              int avgAge &#x3D; (stu1.Age + stu2.Age + stu3.Age)&#x2F;3;
              Console.WriteLine(avgAge);
          &#125;
      &#125;
  
      class Student
      &#123;
          private int age; &#x2F;&#x2F;字段必须是私有的或者受保护的
  
          public int Age  &#x2F;&#x2F;属性,需要和字段名称不同
          &#123;
              get
              &#123;
                  return this.age;
              &#125;
  
              set
              &#123;
                  if(value&gt;&#x3D;0 &amp;&amp; value &lt;&#x3D; 120)    &#x2F;&#x2F;value是上下文关键字，微软默认规定的变量
                  &#123;
                      this.age &#x3D; value;
                  &#125;
                  else
                  &#123;
                      throw new Exception(&quot;age value has error!&quot;);
                  &#125;
              &#125;
          &#125;
      &#125;
  &#125;
  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
<h4 id="9-2-2-属性的声明"><a href="#9-2-2-属性的声明" class="headerlink" title="9.2.2 属性的声明"></a>9.2.2 属性的声明</h4><ul>
<li><p>完整声明——后台（back）成员变量与访问器（<font color="89BC">注意使用code snippet和refactor工具</font>）</p>
<ul>
<li>Developer Command Prompt for VS 2019</li>
<li><img src="/.com//Users\8y\AppData\Roaming\Typora\typora-user-images\image-20220916150312014.png" alt="image-20220916150312014"></li>
<li>可以看到编译器自动给我们写了get和set的方法，所以属性也是一种语法糖</li>
<li>propfull + tab + tab 快速生成属性</li>
<li>属性是static的，字段也必须是static的</li>
<li>还有一种快速声明字段的方法<ul>
<li>例如<code>private int age;</code>将光标定位到<strong>age</strong>字段上</li>
<li>按住CTRL键，然后按R+E</li>
<li><img src="/.com//Users\8y\AppData\Roaming\Typora\typora-user-images\image-20220916151705312.png" alt="image-20220916151705312"></li>
</ul>
</li>
</ul>
</li>
<li><p>简略声明——只有访问器（查看IL代码）</p>
<ul>
<li><p>和只有一个公有字段是完全一样的，不安全</p>
</li>
<li><p>带有这种属性的类，一般只用来传递数据</p>
</li>
<li><p>```c#<br>public int Age{get;set;}</p>
<pre class="line-numbers language-none"><code class="language-none">
- 动态计算值的属性

- 注意实例属性和静态属性

- 属性的名字一定是名词

- 只读属性——只有getter没有setter

  - 尽管语法上正确，几乎没有人使用”只读属性“，因为属性的主要目的是通过向外暴露数据而表示对象&#x2F;类型的状态

#### 9.2.3 属性与字段的关系

- 一般情况下，它们都用于表示实体（对象或类型）的状态

- 属性大多数情况是字段的包装器（wrapper）

- 建议：永远使用属性（而不是字段）来暴露数据，即字段永远都是private或protected的

- &#96;&#96;&#96;c#
  using System;
  
  namespace PropertyExample
  &#123;
      class Program
      &#123;
          static void Main(string[] args)
          &#123;
              Student studentOne &#x3D; new Student();
              studentOne.Age &#x3D; 8;
              studentOne.Name &#x3D; &quot;8yyy&quot;;
              Console.WriteLine($&quot;&#123;studentOne.Name&#125;&#39;s age is &#123;studentOne.Age&#125;.&quot;);
  
              Student studentTwo &#x3D; new Student();
              studentTwo.Age &#x3D; 66;
              studentTwo.Name &#x3D; &quot;tryyy&quot;;
              Console.WriteLine($&quot;&#123;studentTwo.Name&#125;&#39;s age is &#123;studentTwo.Age&#125;.&quot;);
          &#125;
      &#125;
  
      class Student
      &#123;
          private int _age;
          private string _name;
          public int Age
          &#123;
              get
              &#123;
                  return _age;
              &#125;
              set
              &#123;
                  if (value &gt;&#x3D; 0 &amp;&amp; value &lt;&#x3D; 30)
                  &#123;
                      _age &#x3D; value;
                  &#125;
                  else
                  &#123;
                      throw new Exception(&quot;Student&#39;s Age is Error!&quot;);
                  &#125;
              &#125;
          &#125;
  
          public string Name
          &#123;
              get &#123; return _name; &#125;
              set
              &#123;
                  if (value &#x3D;&#x3D; &quot;8yyy&quot;)
                  &#123;
                      _name &#x3D; value;
                      Console.WriteLine(&quot;Hello,8yyy!&quot;);
                  &#125;
                  else
                  &#123;
                      _name &#x3D; value;
                      Console.WriteLine($&quot;Hi,&#123;value&#125;&quot;);
                  &#125;
  
              &#125;
          &#125;
  
      &#125;
  &#125;
  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
</li>
<li><p>运行结果如下：</p>
</li>
<li><p>```<br>Hello,8yyy!<br>8yyy’s age is 8.</p>
<p>未经处理的异常:  System.Exception: Student’s Age is Error!<br>…<br>…</p>
<pre class="line-numbers language-none"><code class="language-none">
  



### 9.3 索引器

- 什么是索引器

  - 索引器（indexer）是这样一种成员：它使对象能够用与数组相同的方法（即使用下标）进行索引
  - indexer + tab + tab

- 索引器的声明

  - 参见C#语言定义文档
  - 注意：没有静态索引器

- 示例

- &#96;&#96;&#96;c#
  using System;
  using System.Collections.Generic;
  using System.Linq;
  using System.Text;
  using System.Threading.Tasks;
  
  namespace DataMemberExample
  &#123;
      class Program
      &#123;
          static void Main(string[] args)
          &#123;
              Student stu &#x3D; new Student();
              stu[&quot;Math&quot;] &#x3D; 90;
              var mathScore &#x3D; stu[&quot;Math&quot;];
              Console.WriteLine(mathScore);
          &#125;
      &#125;
  
      class Student
      &#123;
          private Dictionary&lt;string, int&gt; scoreDictionary &#x3D; new Dictionary&lt;string, int&gt;();
          public int? this[string subject]    &#x2F;&#x2F;索引器，indexer
          &#123;
              get 
              &#123;
                  if (this.scoreDictionary.ContainsKey(subject))
                  &#123;
                      return this.scoreDictionary[subject];
                  &#125;
                  else
                  &#123;
                      return null;
                  &#125;
              &#125;
              set 
              &#123;
                  if (value.HasValue &#x3D;&#x3D; false)
                  &#123;
                      throw new Exception(&quot;Score cannot be null.&quot;);
                  &#125;
                  if (this.scoreDictionary.ContainsKey(subject))
                  &#123;
                      this.scoreDictionary[subject] &#x3D; value.Value;
                  &#125;
                  else
                  &#123;
                      this.scoreDictionary.Add(subject, value.Value);
                  &#125;
              &#125;
          &#125;
      &#125;
  &#125;
  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
<h3 id="9-4-常量"><a href="#9-4-常量" class="headerlink" title="9.4 常量"></a>9.4 常量</h3><h4 id="9-4-1-什么是常量"><a href="#9-4-1-什么是常量" class="headerlink" title="9.4.1 什么是常量"></a>9.4.1 什么是常量</h4><ul>
<li>常量（constant）是表示常量值（即，可以在编译时计算的值）的类成员<ul>
<li>必须使用类型+.的形式访问常量</li>
<li><code>Math.PI</code> 就是一个常量</li>
<li><img src="/.com//Users\8y\AppData\Roaming\Typora\typora-user-images\image-20220916171749814.png" alt="image-20220916171749814"></li>
</ul>
</li>
<li>常量隶属于类型而不是对象，即没有”实例常量“<ul>
<li>“实例常量”的角色由只读实例字段来担当</li>
</ul>
</li>
<li>注意区分成员常量与局部常量<ul>
<li><code>Math.PI</code>就是一个成员常量</li>
</ul>
</li>
</ul>
<h4 id="9-4-2-常量的声明"><a href="#9-4-2-常量的声明" class="headerlink" title="9.4.2 常量的声明"></a>9.4.2 常量的声明</h4><h4 id="9-4-3-各种“只读”的引用场景"><a href="#9-4-3-各种“只读”的引用场景" class="headerlink" title="9.4.3 各种“只读”的引用场景"></a>9.4.3 各种“只读”的引用场景</h4><ul>
<li>为了提高程序可读性和执行效率——常量</li>
<li>为了防止对象的值被改变——只读字段</li>
<li>向外暴露不允许修改的数据——只读属性（静态或非静态），功能与常量有一些重叠</li>
<li>当希望成为常量的值其类型不能被常量声明接受时（类/自定义结构体）——静态只读字段</li>
</ul>
<hr>




<h2 id="10-传值-输出-引用-数组-具名-可选参数，扩展方法-this参数"><a href="#10-传值-输出-引用-数组-具名-可选参数，扩展方法-this参数" class="headerlink" title="10. 传值/输出/引用/数组/具名/可选参数，扩展方法(this参数)"></a>10. 传值/输出/引用/数组/具名/可选参数，扩展方法(this参数)</h2><h3 id="10-1-传值参数"><a href="#10-1-传值参数" class="headerlink" title="10.1 传值参数"></a>10.1 传值参数</h3><ul>
<li><p>声明时<font color="red">不带修饰符</font>的形参是值形参。一个<font color="red">值形参对应于一个局部变量</font>，只是它的<font color="red">初始值来自该方法调用所提供的相应实参</font></p>
<ul>
<li>public void add(int a)，a就是值形参，因为它不带修饰符</li>
</ul>
</li>
<li><p><font color="red">允许方法将新值赋给值参数。这样的赋值只影响由该值形参表示的局部存储位置（方法内有效），而不会影响在方法调用时由调用方给出的实参</font></p>
</li>
<li><p><img src="/.com//Users\8y\AppData\Roaming\Typora\typora-user-images\image-20220916172808169.png" alt="image-20220916172808169"></p>
</li>
<li><p>```c#<br>using System;<br>using System.Collections.Generic;</p>
<p>namespace ConstantExample<br>{</p>
<pre><code>class Program
&#123;
    static void Main(string[] args)
    &#123;
        Student stu = new Student();
        int y = 100;
        stu.AddOne(y);
        Console.WriteLine(y);   //y的值不会发生变化
    &#125;
&#125;

class Student
&#123;
    public void AddOne(int x)
    &#123;
        x += 1;
        Console.WriteLine(x);
    &#125;
&#125;
</code></pre>
<p>}</p>
<pre class="line-numbers language-none"><code class="language-none">
- 运行结果如下：
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>101<br>100</p>
<pre class="line-numbers language-none"><code class="language-none">


- ![image-20220916173949040](C:\Users\8y\AppData\Roaming\Typora\typora-user-images\image-20220916173949040.png)

- &#96;&#96;&#96;c#
  using System;
  using System.Collections.Generic;
  
  namespace ParametersExample
  &#123;
      class Program
      &#123;
          static void Main(string[] args)
          &#123;
              Student stu &#x3D; new Student() &#123; Name &#x3D; &quot;Tim&quot; &#125;;
              SomeMethod(stu);
              Console.WriteLine($&quot;&#123;stu.GetHashCode()&#125;,&#123;stu.Name&#125;&quot;);
          &#125;
  
          static void SomeMethod(Student stu)
          &#123;
              stu &#x3D; new Student() &#123; Name &#x3D; &quot;Tim&quot; &#125;;
              &#x2F;&#x2F;像这种通过传值参数将一个引用类型变量传过来
              &#x2F;&#x2F;将这个变量先前的引用对象丢弃掉，而在方法内部创建
              &#x2F;&#x2F;一个新的对象，在实际操作中没有啥意义
    
              Console.WriteLine($&quot;&#123;stu.GetHashCode()&#125;,&#123;stu.Name&#125;&quot;);
          &#125;
      &#125;
  
      class Student
      &#123;
          public string Name &#123; get; set; &#125;
      &#125;
  &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>运行结果如下：</p>
</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">46104728,Tim
12289376,Tim<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<ul>
<li><p><strong>像这种通过传值参数将一个引用类型变量传过来将这个变量先前的引用对象丢弃掉，而在方法内部创建一个新的对象，在实际操作中没有啥意义</strong></p>
</li>
<li><p>```c#<br>using System;<br>using System.Collections.Generic;</p>
<p>namespace ParametersExample<br>{</p>
<pre><code>class Program
&#123;
    static void Main(string[] args)
    &#123;
        Student stu = new Student() &#123; Name = &quot;Tim&quot; &#125;;
        SomeMethod(stu);
        Console.WriteLine($&quot;&#123;stu.GetHashCode()&#125;,&#123;stu.Name&#125;&quot;);
    &#125;

    static void SomeMethod(Student stu)
    &#123;
        stu.Name = &quot;Tom&quot;;    //副作用，side-effect
        Console.WriteLine($&quot;&#123;stu.GetHashCode()&#125;,&#123;stu.Name&#125;&quot;);
    &#125;
&#125;

class Student
&#123;
    public string Name &#123; get; set; &#125;
&#125;
</code></pre>
<p>}</p>
<pre class="line-numbers language-none"><code class="language-none">
- 运行结果如下

- &#96;&#96;&#96;
  46104728,Tom
  46104728,Tom<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>向以上这种副作用，我们平时编程的时候需要避免</p>
</li>
</ul>
<h3 id="10-2-引用参数"><a href="#10-2-引用参数" class="headerlink" title="10.2 引用参数"></a>10.2 引用参数</h3><ul>
<li><p>引用形参是<font color="red">用ref修饰符声明的形参</font>。与值形参不同，<font color="red">引用形参并不创建新的存储位置。</font>相反，<font color="red">引用形参表示的存储位置恰是在方法调用中作为实参给出的那个变量所表示的存储位置。</font></p>
</li>
<li><p>当形参为引用形参时，方法调用中的实参必须由关键字ref并后接一个与形参类型相同的 variable-reference 组成。<font color="red">变量在可以作为引用形参传递之前，必须先明确赋值。</font></p>
</li>
<li><p><img src="/.com//Users\8y\AppData\Roaming\Typora\typora-user-images\image-20220916192704039.png" alt="image-20220916192704039"></p>
</li>
<li><p>```c#<br>using System;<br>using System.Collections.Generic;</p>
<p>namespace ParametersExample<br>{</p>
<pre><code>class Program
&#123;
    static void Main(string[] args)
    &#123;
        int y = 1; //必须先明确赋值
        IWantSideEffect(ref y);
        Console.WriteLine(y); //101
    &#125;

    static void IWantSideEffect(ref int x)
    &#123;
        x += 100;
    &#125;
&#125;
</code></pre>
<p>}</p>
<pre class="line-numbers language-none"><code class="language-none">
- ![image-20220916193024608](C:\Users\8y\AppData\Roaming\Typora\typora-user-images\image-20220916193024608.png)

- &#96;&#96;&#96;c#
  using System;
  using System.Collections.Generic;
  
  namespace ParametersExample
  &#123;
      class Program
      &#123;
          static void Main(string[] args)
          &#123;
              Student outterStu &#x3D; new Student() &#123; Name &#x3D; &quot;Tim&quot; &#125;;
              Console.WriteLine($&quot;&#123;outterStu.GetHashCode()&#125;,&#123;outterStu.Name&#125;&quot;);
              Console.WriteLine(&quot;---------------------------------------&quot;);
              IWantSideEffect(ref outterStu);
              Console.WriteLine($&quot;&#123;outterStu.GetHashCode()&#125;,&#123;outterStu.Name&#125;&quot;);
          &#125;
  
          static void IWantSideEffect(ref Student stu)
          &#123;
              stu &#x3D; new Student() &#123; Name &#x3D; &quot;Tom&quot; &#125;;
              Console.WriteLine($&quot;&#123;stu.GetHashCode()&#125;,&#123;stu.Name&#125;&quot;);
          &#125;
      &#125;
  
      class Student
      &#123;
          public string Name &#123; get; set; &#125;
      &#125;
  &#125;
  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>运行结果如下：</p>
</li>
<li><p>```</p>
<h2 id="46104728-Tim"><a href="#46104728-Tim" class="headerlink" title="46104728,Tim"></a>46104728,Tim</h2><p>12289376,Tom<br>12289376,Tom</p>
<pre class="line-numbers language-none"><code class="language-none">
- ![image-20220916193657600](C:\Users\8y\AppData\Roaming\Typora\typora-user-images\image-20220916193657600.png)

- &#96;&#96;&#96;c#
  using System;
  using System.Collections.Generic;
  
  namespace ParametersExample
  &#123;
      class Program
      &#123;
          static void Main(string[] args)
          &#123;
              Student outterStu &#x3D; new Student() &#123; Name &#x3D; &quot;Tim&quot; &#125;;
              Console.WriteLine($&quot;&#123;outterStu.GetHashCode()&#125;,&#123;outterStu.Name&#125;&quot;);
              Console.WriteLine(&quot;---------------------------------------&quot;);
              IWantSideEffect(ref outterStu);
              Console.WriteLine($&quot;&#123;outterStu.GetHashCode()&#125;,&#123;outterStu.Name&#125;&quot;);
          &#125;
  
          static void IWantSideEffect(ref Student stu)
          &#123;
              stu.Name &#x3D; &quot;Tom&quot;;	&#x2F;&#x2F;对象不变
              Console.WriteLine($&quot;&#123;stu.GetHashCode()&#125;,&#123;stu.Name&#125;&quot;);
          &#125;
      &#125;
  
      class Student
      &#123;
          public string Name &#123; get; set; &#125;
      &#125;
  &#125;
  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>运行结果如下：</p>
</li>
<li><p>```</p>
<h2 id="46104728-Tim-1"><a href="#46104728-Tim-1" class="headerlink" title="46104728,Tim"></a>46104728,Tim</h2><p>46104728,Tom<br>46104728,Tom</p>
<pre class="line-numbers language-none"><code class="language-none">
- **引用参数和值参数的对比**

  - 上述例子在去掉ref之后所得的结果与引用参数结果相同
  - 从效果上来看一模一样
  - 但是在内存基理不一样
    - 值参数创建副本。两个参数所指向的内存地址不同，他们同时指向同一个对象所在堆的内存地址
    - 引用参数不创建副本。两个参数所指向的内存地址就是同一个内存地址，而这个地址指向对象所在堆的内存地址

### 10.3 输出形参

- &lt;font color&#x3D;red&gt;用out修饰符声明的形参&lt;&#x2F;font&gt;是输出形参。类似于引用实参，&lt;font color&#x3D;red&gt;输出形参不创建新的存储位置。&lt;&#x2F;font&gt;相反，输出形参表示的存储位置恰是在该方法调用中作为实参给出的那个变量所表示的存储位置。

- &lt;font color&#x3D;red&gt;变量在可以作为输出形参传递之前不一定需要明确赋值&lt;&#x2F;font&gt;

- &lt;font color&#x3D;red&gt;在方法返回之前，该方法的每个输出形参都必须明确赋值&lt;&#x2F;font&gt;

- 引用参数为了改变变量的值，所以需要先进行赋值，而输出参数是为了通过这个参数向外输出，原来的值必然被丢弃，所以不要求先赋值

- ![image-20220916195204303](C:\Users\8y\AppData\Roaming\Typora\typora-user-images\image-20220916195204303.png)

- tyrparse是一个带有输出的方法

  - bool double.TryParse(string s,out double result)
  - 作用就是将字符串s转化为double型的result

- &#96;&#96;&#96;c#
  using System;
  using System.Collections.Generic;
  
  namespace ParametersExample
  &#123;
      class Program
      &#123;
          static void Main(string[] args)
          &#123;
              Console.WriteLine(&quot;Please input first number:&quot;);
              string arg1 &#x3D; Console.ReadLine();
              double x &#x3D; 0;
              bool b1 &#x3D; double.TryParse(arg1, out x);
              if (b1 &#x3D;&#x3D; false)
              &#123;
                  Console.WriteLine(&quot;input error!&quot;);
                  return;
              &#125;
  
              Console.WriteLine(&quot;Please input second number:&quot;);
              string arg2 &#x3D; Console.ReadLine();
              double y &#x3D; 0;
              bool b2 &#x3D; double.TryParse(arg2, out y);
              if (b2 &#x3D;&#x3D; false)
              &#123;
                  Console.WriteLine(&quot;input error!&quot;);
                  return;
              &#125;
  
              double z &#x3D; x + y;
              Console.WriteLine(z);
          &#125;   
      &#125;
  &#125;
  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>自己写一个带有输出参数的方法</p>
</li>
<li><p>```c#<br>using System;<br>using System.Collections.Generic;</p>
<p>namespace ParametersExample<br>{</p>
<pre><code>class Program
&#123;
    static void Main(string[] args)
    &#123;
        double x = 0;
        bool b = DoubleParse.TryParse(&quot;789&quot;, out x);
        if (b)
        &#123;
            Console.WriteLine(x+1);    //790
        &#125;
    &#125;

    
&#125;

class DoubleParse
&#123;
    public static bool TryParse(string input,out double result)
    &#123;
        try
        &#123;
            result = double.Parse(input);
            return true;
        &#125;
        catch 
        &#123;
            result = 0;
            return false;
        &#125;
    &#125;
&#125;
</code></pre>
<p>}</p>
<pre class="line-numbers language-none"><code class="language-none">
- ![image-20220916200654390](C:\Users\8y\AppData\Roaming\Typora\typora-user-images\image-20220916200654390.png)

- &#96;&#96;&#96;c#
  using System;
  using System.Collections.Generic;
  
  namespace ParametersExample
  &#123;
      class Program
      &#123;
          static void Main(string[] args)
          &#123;
              Student stu &#x3D; null;
              bool b &#x3D; StudentFactory.Create(34, &quot;Tim&quot;,  out stu);
              if (b &#x3D;&#x3D; true)
              &#123;
                  Console.WriteLine($&quot;student &#123;stu.Name&#125;&#39;s age is &#123;stu.Age&#125;&quot;);
              &#125;
          &#125;
      &#125;
  
      class Student
      &#123;
          public int Age &#123; get; set; &#125;
          public string Name &#123; get; set; &#125;
      &#125;
  
      class StudentFactory
      &#123;
          public static bool Create(int stuAge,string stuName,out Student stu)
          &#123;
              stu &#x3D; null;
              if (string.IsNullOrEmpty(stuName))
              &#123;
                  return false;
              &#125;
              if(stuAge&lt;20 || stuAge &gt; 80)
              &#123;
                  return false;
              &#125;
              stu &#x3D; new Student() &#123; Name &#x3D; stuName, Age &#x3D; stuAge &#125;;
              return true;
          &#125;
      &#125;
  &#125;
  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
<h3 id="10-4-数组参数"><a href="#10-4-数组参数" class="headerlink" title="10.4 数组参数"></a>10.4 数组参数</h3><ul>
<li><p>必须是形参列表中的<strong>最后一个</strong>，由params修饰，只能有一个</p>
<ul>
<li>因为如果不是最后一个，编译器就无法判断哪个参数是数组参数后面的参数</li>
</ul>
</li>
<li><p>举例：String.Format方法和String.Split方法</p>
</li>
<li><p>先来看一个例子</p>
</li>
<li><p>```c#<br>using System;<br>using System.Collections.Generic;</p>
<p>namespace ParametersExample<br>{</p>
<pre><code>class Program
&#123;
    static void Main(string[] args)
    &#123;
        int[] myIntArray = new int[] &#123; 1, 3, 4 &#125;;
        int result = CalculateSum(myIntArray);
        Console.WriteLine(result);
    &#125;

    static int CalculateSum(int[] intArray)
    &#123;
        int sum = 0;
        foreach (var item in intArray)
        &#123;
            sum += item;
        &#125;
        return sum;
    &#125;
&#125;
</code></pre>
<p>}</p>
<pre class="line-numbers language-none"><code class="language-none">
- 你会发现在调用CalculateSum方法时，必须提前声明一个数组myIntArray，这样就会显得非常啰嗦，接下来采用params修饰符

- &#96;&#96;&#96;c#
  using System;
  using System.Collections.Generic;
  
  namespace ParametersExample
  &#123;
      class Program
      &#123;
          static void Main(string[] args)
          &#123;
              int result &#x3D; CalculateSum(1,3,4);
              &#x2F;&#x2F;不需要提前定义一个int数组
              Console.WriteLine(result);
          &#125;
  
          static int CalculateSum(params int[] intArray)
          &#123;
              int sum &#x3D; 0;
              foreach (var item in intArray)
              &#123;
                  sum +&#x3D; item;
              &#125;
              return sum;
          &#125;
      &#125;
  
      
  &#125;
  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>实际上我们一直有用到params修饰符</p>
</li>
<li><p>例如</p>
<pre class="line-numbers language-none"><code class="language-none">int x &#x3D; 1;
         int y &#x3D; 2;
         int z &#x3D; x + y;
         Console.WriteLine(&quot;&#123;0&#125;+&#123;1&#125;&#x3D;&#123;2&#125;&quot;,x,y,z);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p><img src="/.com//Users\8y\AppData\Roaming\Typora\typora-user-images\image-20220917162756896.png" alt="image-20220917162756896"></p>
</li>
<li><p>其中一个重载如图所示，这就是为什么我们可以自由输入任意个数的参数，实际上它会先声明一个object类型的数组，然后把x,y,z放入这个数组，然后再传进我们的WriteLine方法</p>
</li>
<li><p>再来看一个例子</p>
</li>
<li><p>string类型具有实例方法Split()，它会基于数组中的字符将字符串拆分为多个子字符串</p>
</li>
<li><p>```c#<br>using System;<br>using System.Collections.Generic;</p>
<p>namespace ParametersExample<br>{</p>
<pre><code>class Program
&#123;
    static void Main(string[] args)
    &#123;
        string str = &quot;Tim;Tom,Amy.Lisa&quot;;
        string[] result = str.Split(&#39;;&#39;, &#39;,&#39;, &#39;.&#39;);
        foreach (var item in result)
        &#123;
            Console.WriteLine(item);
        &#125;
    &#125;
&#125;
</code></pre>
<p>}</p>
<pre class="line-numbers language-none"><code class="language-none">
- 运行结果如下：

- &#96;&#96;&#96;
  Tim
  Tom
  Amy
  Lisa<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
<h3 id="10-5-具名参数"><a href="#10-5-具名参数" class="headerlink" title="10.5 具名参数"></a>10.5 具名参数</h3><ul>
<li><p>参数的位置不受约束</p>
<ul>
<li><p>首先举个例子，不具名调用</p>
</li>
<li><p>```c#<br>using System;<br>using System.Collections.Generic;</p>
<p>namespace ParametersExample<br>{</p>
<pre><code>class Program
&#123;
    static void Main(string[] args)
    &#123;
        PrintInfo(&quot;Tim&quot;, 34);
    &#125;

    static void PrintInfo(string name,int age)
    &#123;
        Console.WriteLine($&quot;Hello &#123;name&#125;,you are &#123;age&#125; years old!&quot;);
    &#125;
&#125;
</code></pre>
<p>}</p>
<pre class="line-numbers language-none"><code class="language-none">
- 当你在调用PrintInfo()方法时，传递过去的实参必须与形参相对应

- 接下来是具名调用

- &#96;&#96;&#96;c#
  using System;
  using System.Collections.Generic;
  
  namespace ParametersExample
  &#123;
      class Program
      &#123;
          static void Main(string[] args)
          &#123;
              PrintInfo(age:34,name:&quot;Tim&quot;);
          &#125;
  
          static void PrintInfo(string name,int age)
          &#123;
              Console.WriteLine($&quot;Hello &#123;name&#125;,you are &#123;age&#125; years old!&quot;);
          &#125;
      &#125;
  &#125;
  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>具名调用能使代码<strong>可读性更高</strong>，且不受位置约束</p>
</li>
<li><p>严格来讲具名调用不是参数的某个种类，而是一种使用方法</p>
</li>
</ul>
</li>
</ul>
<h3 id="10-6-可选参数"><a href="#10-6-可选参数" class="headerlink" title="10.6 可选参数"></a>10.6 可选参数</h3><ul>
<li><p>参数因为具有默认值而变得“可选”</p>
<ul>
<li><p><img src="/.com//Users\8y\AppData\Roaming\Typora\typora-user-images\image-20220917164636475.png" alt="image-20220917164636475"></p>
</li>
<li><p>```c#<br>using System;<br>using System.Collections.Generic;</p>
<p>namespace ParametersExample<br>{</p>
<pre><code>class Program
&#123;
    static void Main(string[] args)
    &#123;
        PrintInfo();
    &#125;

    static void PrintInfo(string name=&quot;Tim&quot;,int age=34)
    &#123;
        Console.WriteLine($&quot;Hello &#123;name&#125;,you are &#123;age&#125; years old!&quot;);
    &#125;
&#125;
</code></pre>
<p>}</p>
<pre class="line-numbers language-none"><code class="language-none">
- 不推荐使用可选参数



### 10.7 扩展方法（this参数）

- 方法必须是公有的、静态的，即被public static所修饰

- 必须是形参列表中的第一个，由this修饰

- 必须由一个静态类（一般类名为SomeTypeExtension）来统一收纳SomeType类型的扩展方法

- 实例写一个double型的扩展方法，代码如下：

- &#96;&#96;&#96;c#
  using System;
  using System.Collections.Generic;
  
  namespace ParametersExample
  &#123;
      class Program
      &#123;
          static void Main(string[] args)
          &#123;
              double x &#x3D; 3.14159;
              double y &#x3D; x.Round(4);  &#x2F;&#x2F;扩展方法的应用
              Console.WriteLine(y);
          &#125; 
      &#125;
      &#x2F;&#x2F;扩展方法必须定义在一个静态类
      static class DoubleExtention
      &#123;
          &#x2F;&#x2F;方法必须是公有的、静态的
          public static double Round(this double input, int digits)
          &#123;
              double result &#x3D; Math.Round(input, digits);
              return result;
          &#125;
      &#125;
  &#125;
  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
</li>
<li><p>举例：LINQ方法</p>
</li>
<li><p>代码如下：</p>
</li>
<li><p>```c#<br>using System;<br>using System.Collections.Generic;</p>
<p>namespace ParametersExample<br>{</p>
<pre><code>class Program
&#123;
    static void Main(string[] args)
    &#123;
        List&lt;int&gt; myList = new List&lt;int&gt;() &#123; 11, 12, 13, 14, 15 &#125;;
        bool result = AllGreaterThanTen(myList);
        Console.WriteLine(result);
    &#125;

    static bool AllGreaterThanTen(List&lt;int&gt; intList)
    &#123;
        foreach (var item in intList)
        &#123;
            if (item &lt;= 10)
            &#123;
                return false;
            &#125;
        &#125;
        return true;
    &#125;       
   
&#125;
</code></pre>
<p>}</p>
<pre class="line-numbers language-none"><code class="language-none">
- 接下来使用linq方法

- &#96;&#96;&#96;c#
  using System;
  using System.Collections.Generic;
  using System.Linq;	&#x2F;&#x2F;调用类库linq
  
  namespace ParametersExample
  &#123;
      class Program
      &#123;
          static void Main(string[] args)
          &#123;
              List&lt;int&gt; myList &#x3D; new List&lt;int&gt;() &#123; 11, 12, 13, 14, 15 &#125;;
              bool result &#x3D; myList.All(i &#x3D;&gt; i &gt; 10);
              Console.WriteLine(result);
          &#125;
  
      &#125;
  
  &#125;
  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>All是一个扩展方法</p>
<ul>
<li><img src="/.com//Users\8y\AppData\Roaming\Typora\typora-user-images\image-20220917170800750.png" alt="image-20220917170800750"></li>
</ul>
</li>
</ul>
<p>总结：</p>
<p><img src="/.com//Users\8y\AppData\Roaming\Typora\typora-user-images\image-20220917170846626.png" alt="image-20220917170846626"></p>
<hr>




















<h2 id="11-委托详解"><a href="#11-委托详解" class="headerlink" title="11. 委托详解"></a>11. 委托详解</h2><h3 id="11-1-什么是委托"><a href="#11-1-什么是委托" class="headerlink" title="11.1 什么是委托"></a>11.1 什么是委托</h3><ul>
<li><p>委托（delegate）是函数指针的“升级版”</p>
<ul>
<li><p>delegate    授(权)；把(工作、权力等)委托(给下级)；选派(某人做某事)；</p>
</li>
<li><p>实例：C/C++中的函数指针</p>
<ul>
<li><p>以C语言为例</p>
</li>
<li><p>```c<br>#include&lt;stdio.h&gt;</p>
<p>int Add(int a, int b) {</p>
<pre><code>int result = a + b;
return result;
</code></pre>
<p>}</p>
<p>int Sub(int a, int b) {</p>
<pre><code>int result = a - b;
return result;
</code></pre>
<p>}</p>
<p>int main() {</p>
<pre><code>int  x = 100;
int y = 200;
int z = 0;
z = Add(x, y);
printf(&quot;%d+%d=%d\n&quot;, x, y, z);

z = Sub(x, y);
printf(&quot;%d-%d=%d\n&quot;, x, y, z);

system(&quot;pause&quot;);
</code></pre>
<p>}</p>
<pre class="line-numbers language-none"><code class="language-none">
- 以上的代码通过函数的名字调用函数，称为直接调用

- 下面采用函数指针的方法

- &#96;&#96;&#96;c
  #include&lt;stdio.h&gt;
  
  typedef int (*Calc)(int a, int b);	&#x2F;&#x2F;函数指针
  
  int Add(int a, int b) &#123;
  	int result &#x3D; a + b;
  	return result;
  &#125;
  
  int Sub(int a, int b) &#123;
  	int result &#x3D; a - b;
  	return result;
  &#125;
  
  int main() &#123;
  	int  x &#x3D; 100;
  	int y &#x3D; 200;
  	int z &#x3D; 0;
  
  	Calc funcPoint1 &#x3D; &amp;Add;	&#x2F;&#x2F;把函数Add的地址赋值给函数指针类型Calc的变量funcPoint1
  	Calc funcPoint2 &#x3D; &amp;Sub; &#x2F;&#x2F;把函数Sub的地址赋值给函数指针类型Calc的变量funcPoint2
  
  	z &#x3D; funcPoint1(x, y);
  	printf(&quot;%d+%d&#x3D;%d\n&quot;, x, y, z);
  
  	z &#x3D; funcPoint2(x, y);
  	printf(&quot;%d-%d&#x3D;%d\n&quot;, x,y, z);
  
  	system(&quot;pause&quot;);
  &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>运行结果是一样的</p>
</li>
<li><p>```<br>100+200=300<br>100-200=-100</p>
<pre class="line-numbers language-none"><code class="language-none">
      

- 一切皆地址

  - 变量（数据）是以某个地址为起点的一段内存中所存储的值
  - 函数（算法）是以某个地址为起点的一段内存中所存储的一组机器语言指令

- 直接调用与间接调用

  - 直接调用：通过**函数名**来调用函数，CPU通过函数名直接获得函数所在地址并开始执行 ——&gt; 返回
  - 间接调用：通过**函数指针**来调用函数，CPU通过读取函数指针存储的值获得函数所在地址并开始执行 ——&gt; 返回

- Java中没有与委托相对应的功能实体

- 委托的简单使用

  - Action委托

  - Action委托**无返回值**的泛型委托

- Func委托

  - Func委托是泛型委托，必须具备返回值

  - 下面来举个例子

  - &#96;&#96;&#96;c#
    using System;
    using System.Collections.Generic;
    
    namespace DelegateExample
    &#123;
        class Program
        &#123;
            static void Main(string[] args)
            &#123;
                Calculator calculator &#x3D; new Calculator();
    
                &#x2F;&#x2F;Action委托 是无参委托
                Action action &#x3D; new Action(calculator.Report);&#x2F;&#x2F;注意Report不能加()，因为加()就是要使用这个方法
                calculator.Report();    &#x2F;&#x2F;直接调用
    
                &#x2F;&#x2F;间接调用,以下两种写法是一样的 
                action.Invoke();
                action();
    
                &#x2F;&#x2F;Func委托 泛型委托
                Func&lt;int, int, int&gt; func1 &#x3D; new Func&lt;int, int, int&gt;(calculator.Add);
                Func&lt;int, int, int&gt; func2 &#x3D; new Func&lt;int, int, int&gt;(calculator.Sub);
                &#x2F;&#x2F;2个参数+返回值result，所以是三个int
    
                int x &#x3D; 100;
                int y &#x3D; 200;
                int z &#x3D; 0;
    
                z &#x3D; func1.Invoke(x, y);
                Console.WriteLine(z);
                z &#x3D; func2.Invoke(x, y);
                Console.WriteLine(z);
    
                z &#x3D; func1(x, y);
                Console.WriteLine(z);
                z &#x3D; func2(x, y);
                Console.WriteLine(z);
            &#125;
        &#125;
    
        class Calculator 
        &#123;
            public void Report()
            &#123;
                Console.WriteLine(&quot;I have 3 methods.&quot;);
            &#125;
    
            public int Add(int a, int b)
            &#123;
                int result &#x3D; a + b;
                return result;
            &#125;
    
            public int Sub(int a, int b)
            &#123;
                int result &#x3D; a - b;
                return result;
            &#125;
      &#125;
    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
</li>
</ul>
<p>}</p>
  <pre class="line-numbers language-none"><code class="language-none">- 运行结果如下：

- &#96;&#96;&#96;
  I have 3 methods.
  I have 3 methods.
  I have 3 methods.
  300
  -100
  300
  -100<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
<h3 id="11-2-委托的声明（自定义委托）"><a href="#11-2-委托的声明（自定义委托）" class="headerlink" title="11.2 委托的声明（自定义委托）"></a>11.2 委托的声明（自定义委托）</h3><ul>
<li><p>委托是一种类（class），类是数据类型所以委托也是一种数据类型</p>
<ul>
<li><p>证明：</p>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">Type t &#x3D; typeof(Action);
Console.WriteLine(t.IsClass);
&#x2F;&#x2F;运行结果为True<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li>
</ul>
</li>
<li><p>举例如下：</p>
</li>
<li><p>```c#<br>using System;<br>using System.Collections.Generic;</p>
<p>namespace DelegateExample<br>{</p>
<pre><code>public delegate double Calc(double x, double y);//委托的声明
class Program
&#123;
    static void Main(string[] args)
    &#123;
        Calculator calculator = new Calculator();
        Calc calc1 = new Calc(calculator.Add);
        Calc calc2 = new Calc(calculator.Sub);
        Calc calc3 = new Calc(calculator.Mul);
        Calc calc4 = new Calc(calculator.Div);

        double a = 100;
        double b = 200;
        double c = 0;

        c = calc1(a, b);
        Console.WriteLine(c);

        c = calc2(a, b);
        Console.WriteLine(c);

        c = calc3(a, b);
        Console.WriteLine(c);

        c = calc4(a, b);
        Console.WriteLine(c);
    &#125;
&#125;

class Calculator 
&#123;
    public double Add(double a, double b)
    &#123;
        double result = a + b;
        return result;
    &#125;

    public double Sub(double a, double b)
    &#123;
        double result = a - b;
        return result;
    &#125;

    public double Mul(double a, double b)
    &#123;
        double result = a * b;
        return result;
    &#125;
    public double Div(double a, double b)
    &#123;
        double result = a / b;
        return result;
    &#125;
&#125;
</code></pre>
<p>}</p>
<pre class="line-numbers language-none"><code class="language-none">
  

- 它的声明方式与一般类不同，主要是为了照顾可读性和C&#x2F;C++传统

  - &#96;&#96;&#96;c#
    public delegate double Calc(double x, double y);&#x2F;&#x2F;委托的声明<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

</li>
<li><p>注意声明委托的位置</p>
<ul>
<li><p>避免写错地方结果声明称嵌套类型</p>
</li>
<li><p>例如写成如下格式就是声明嵌套类型</p>
</li>
<li><p>```c#<br>class Program<br>   {</p>
<pre><code>   public delegate double Calc(double x, double y);//委托的声明
</code></pre>
<p>   }</p>
<pre class="line-numbers language-none"><code class="language-none">
    

- 委托与所封装的方法必须“类型兼容”

  - &#96;&#96;&#96;c#
    public delegate double Calc(double x, double y);&#x2F;&#x2F;委托的声明
    		public double Add(double a, double b)&#123;
                double result &#x3D; a + b;
                return result;
            &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>返回值的数据类型一致</p>
</li>
<li><p>参数列表在个数和数据类型上一致</p>
</li>
</ul>
</li>
</ul>
<h3 id="11-3-委托的一般使用"><a href="#11-3-委托的一般使用" class="headerlink" title="11.3 委托的一般使用"></a>11.3 委托的一般使用</h3><ul>
<li><p>实例：把方法作为参数传给另一个方法</p>
<ul>
<li><p>正确使用1：<font color="red">模板方法</font>，“借用”指定的外部方法来产生结果</p>
<ul>
<li><p>相当于“填空题”</p>
</li>
<li><p>常位于代码中部</p>
</li>
<li><p>委托有返回值</p>
</li>
<li><p>示例：</p>
</li>
<li><p>```c#<br>using System;<br>using System.Collections.Generic;</p>
<p>namespace DelegateExample<br>{</p>
<pre><code>class Program
&#123;
    static void Main(string[] args)
    &#123;
        ProductFactory productFactory = new ProductFactory();
        WrapFactory wrapFactory = new WrapFactory();

        Func&lt;Product&gt; fun1 = new Func&lt;Product&gt;(productFactory.MakePizza);
        Func&lt;Product&gt; fun2 = new Func&lt;Product&gt;(productFactory.MakeToyCar);

        Box box1 = wrapFactory.WrapProcut(fun1);
        Box box2 = wrapFactory.WrapProcut(fun2);

        Console.WriteLine(box1.Product.Name);
        Console.WriteLine(box2.Product.Name);
    &#125;
&#125;

class Product   //产品类
&#123;
    public string  Name &#123; get; set; &#125;   //属性的简略声明，一般只用来传递数据
&#125;

class Box       //盒子类
&#123;
    public Product Product &#123; get; set; &#125;
&#125;

class WrapFactory   //包装厂的类
&#123;
    //模板方法
    public Box WrapProcut(Func&lt;Product&gt; getProduct)
    &#123;
        Box box = new Box();    //准备box
        Product product = getProduct.Invoke();    //获取产品
        box.Product = product;    //将产品装进box
        return box;
    &#125;
&#125;

class ProductFactory    //产品生产厂的类
&#123;
    public Product MakePizza()  //制作披萨的方法
    &#123;
        Product product = new Product();
        product.Name = &quot;Pizza&quot;;
        return product;
    &#125;

    public Product MakeToyCar() //制作玩具车的方法
    &#123;
        Product product = new Product();
        product.Name = &quot;ToyCar&quot;;
        return product;
    &#125;
&#125;
</code></pre>
<p>}</p>
<pre class="line-numbers language-none"><code class="language-none">
  - 优势：只需要扩展ProductFactory类（产品工厂），最大限度的实现了代码的重复使用

- 正确使用2：&lt;font color&#x3D;red&gt;回调（callback）方法&lt;&#x2F;font&gt;，调用指定的外部方法

  - 回调方法也被称为好莱坞方法

  - 相当于“流水线”

  - 常位于代码末尾

  - 委托无返回值

  - 示例如下：

  - &#96;&#96;&#96;c#
    using System;
    using System.Collections.Generic;
    
    namespace DelegateExample
    &#123;
        
        class Program
        &#123;
            static void Main(string[] args)
            &#123;
                ProductFactory productFactory &#x3D; new ProductFactory();
                WrapFactory wrapFactory &#x3D; new WrapFactory();
    
                Func&lt;Product&gt; fun1 &#x3D; new Func&lt;Product&gt;(productFactory.MakePizza);
                Func&lt;Product&gt; fun2 &#x3D; new Func&lt;Product&gt;(productFactory.MakeToyCar);
    
                Logger logger &#x3D; new Logger();
                Action&lt;Product&gt; log &#x3D; new Action&lt;Product&gt;(logger.Log);
    
    
                Box box1 &#x3D; wrapFactory.WrapProcut(fun1,log);
                Box box2 &#x3D; wrapFactory.WrapProcut(fun2,log);
    
                Console.WriteLine(box1.Product.Name);
                Console.WriteLine(box2.Product.Name);
            &#125;
        &#125;
    
        &#x2F;&#x2F;记录程序的运行状态
        class Logger
        &#123;
            public void Log(Product product)
            &#123;
                Console.WriteLine($&quot;Product &#39;&#123;product.Name&#125;&#39; created at &#123;DateTime.UtcNow&#125;. Price is &#123;product.Price&#125;.&quot;);
                &#x2F;&#x2F;使用UtcNow是因为不带时区
            &#125;
        &#125;
    
        class Product   &#x2F;&#x2F;产品类
        &#123;
            public string  Name &#123; get; set; &#125;   &#x2F;&#x2F;属性的简略声明，一般只用来传递数据
            public double Price &#123; get; set; &#125;   &#x2F;&#x2F;新增产品的价格
        &#125;
    
        class Box       &#x2F;&#x2F;盒子类
        &#123;
            public Product Product &#123; get; set; &#125;
        &#125;
    
        class WrapFactory   &#x2F;&#x2F;包装厂的类
        &#123;
            &#x2F;&#x2F;logCallback回调方法，getProduct模板方法
            public Box WrapProcut(Func&lt;Product&gt; getProduct,Action&lt;Product&gt; logCallback)
            &#123;
                Box box &#x3D; new Box();
                Product product &#x3D; getProduct.Invoke();
                if (product.Price&gt;&#x3D;50)
                &#123;
                    logCallback(product);
                &#125;
                box.Product &#x3D; product;
                return box;
            &#125;
        &#125;
    
        class ProductFactory    &#x2F;&#x2F;产品生产厂的类
        &#123;
            public Product MakePizza()  &#x2F;&#x2F;制作披萨的方法
            &#123;
                Product product &#x3D; new Product();
                product.Name &#x3D; &quot;Pizza&quot;;
                product.Price &#x3D; 12;
                return product;
            &#125;
    
            public Product MakeToyCar() &#x2F;&#x2F;制作玩具车的方法
            &#123;
                Product product &#x3D; new Product();
                product.Name &#x3D; &quot;ToyCar&quot;;
                product.Price &#x3D; 120;
                return product;
            &#125;
        &#125;
    &#125;
    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>运行结果如下：</p>
</li>
<li><p>```<br>Product ‘ToyCar’ created at 2022/9/18 7:50:50. Price is 120.<br>Pizza<br>ToyCar</p>
<pre class="line-numbers language-none"><code class="language-none">
- 注意：难精通+易使用+功能强大东西，一旦被滥用则后果非常严重

  - 缺点1：这是一种方法级别的紧耦合，现实工作中要慎之又慎
  - 缺点2：使可读性下降、debug的难度增加
  - 缺点3：把委托回调、异步调用和多线程纠缠在一起，会使代码变得难以阅读和维护
  - 缺点4：委托使用不当有可能造成内存泄漏和程序性能下降













### 11.4 委托的高级使用

- 多播（multicast）委托

  - 指一个委托内部封装着不止一个方法

  - 单播委托（之前写的委托）的例子如下：

  - &#96;&#96;&#96;c#
    using System;
    using System.Collections.Generic;
    using System.Threading;
    
    namespace MulticastDelegateExample
    &#123;
        class Program
        &#123;
            static void Main(string[] args)
            &#123;
                Student stu1 &#x3D; new Student() &#123; ID &#x3D; 1, PenColor &#x3D; ConsoleColor.Red &#125;;
                Student stu2 &#x3D; new Student() &#123; ID &#x3D; 2, PenColor &#x3D; ConsoleColor.Green &#125;;
                Student stu3 &#x3D; new Student() &#123; ID &#x3D; 3, PenColor &#x3D; ConsoleColor.Blue &#125;;
    
                Action action1 &#x3D; new Action(stu1.DoHomework);
                Action action2 &#x3D; new Action(stu2.DoHomework);
                Action action3 &#x3D; new Action(stu3.DoHomework);
    
                action1.Invoke();
                action2.Invoke();
                action3.Invoke();
            &#125;
        &#125;
    
        class Student
        &#123;
            public int ID &#123; get; set; &#125;
            public ConsoleColor PenColor &#123; get; set; &#125;
    
            public void DoHomework()
            &#123;
                for (int i &#x3D; 0; i &lt; 5; i++)
                &#123;
                    Console.ForegroundColor &#x3D; this.PenColor;
                    &#x2F;&#x2F;ForegroundColor 获取或设置控制太的前景色
                    Console.WriteLine($&quot;Student &#123;this.ID&#125; doing homework &#123;i&#125; hour(s).&quot;);
                    Thread.Sleep(1000);
                    &#x2F;&#x2F;使该线程睡眠1秒
                &#125;
            &#125;
        &#125;
    &#125;
    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
</li>
<li><p>运行结果如下：</p>
</li>
<li><p>```<br>Student 1 doing homework 0 hour(s).<br>Student 1 doing homework 1 hour(s).<br>Student 1 doing homework 2 hour(s).<br>Student 1 doing homework 3 hour(s).<br>Student 1 doing homework 4 hour(s).<br>Student 2 doing homework 0 hour(s).<br>Student 2 doing homework 1 hour(s).<br>Student 2 doing homework 2 hour(s).<br>Student 2 doing homework 3 hour(s).<br>Student 2 doing homework 4 hour(s).<br>Student 3 doing homework 0 hour(s).<br>Student 3 doing homework 1 hour(s).<br>Student 3 doing homework 2 hour(s).<br>Student 3 doing homework 3 hour(s).<br>Student 3 doing homework 4 hour(s).</p>
<pre class="line-numbers language-none"><code class="language-none">
- 接下来使用多播委托：

- &#96;&#96;&#96;c#
  using System;
  using System.Collections.Generic;
  using System.Threading;
  
  namespace MulticastDelegateExample
  &#123;
      class Program
      &#123;
          static void Main(string[] args)
          &#123;
              Student stu1 &#x3D; new Student() &#123; ID &#x3D; 1, PenColor &#x3D; ConsoleColor.Red &#125;;
              Student stu2 &#x3D; new Student() &#123; ID &#x3D; 2, PenColor &#x3D; ConsoleColor.Green &#125;;
              Student stu3 &#x3D; new Student() &#123; ID &#x3D; 3, PenColor &#x3D; ConsoleColor.Blue &#125;;
  
              Action action1 &#x3D; new Action(stu1.DoHomework);
              Action action2 &#x3D; new Action(stu2.DoHomework);
              Action action3 &#x3D; new Action(stu3.DoHomework);
  
  			&#x2F;&#x2F;多播委托
              action1 +&#x3D; action2;&#x2F;&#x2F;相当于action2合并到了action1中
              action1 +&#x3D; action3;
              &#x2F;&#x2F;现在action1里封装了3个方法
  
              action1.Invoke();
          &#125;
      &#125;
  
      class Student
      &#123;
          public int ID &#123; get; set; &#125;
          public ConsoleColor PenColor &#123; get; set; &#125;
  
          public void DoHomework()
          &#123;
              for (int i &#x3D; 0; i &lt; 5; i++)
              &#123;
                  Console.ForegroundColor &#x3D; this.PenColor;
                  &#x2F;&#x2F;ForegroundColor 获取或设置控制太的前景色
                  Console.WriteLine($&quot;Student &#123;this.ID&#125; doing homework &#123;i&#125; hour(s).&quot;);
                  Thread.Sleep(1000);
                  &#x2F;&#x2F;使该线程睡眠1秒
              &#125;
          &#125;
      &#125;
  &#125;
  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
</li>
<li><p>隐式异步调用</p>
<ul>
<li><p>同步与异步的简介</p>
<ul>
<li>中英文的语言差异</li>
<li>同步：你做完了我（在你的基础上）接着做</li>
<li>异步：咱们两个同时做（相当于汉语中的“同步进行”）</li>
</ul>
</li>
<li><p>同步调用与异步调用的对比</p>
<ul>
<li>每一个运行的程序都是一个进程（process）</li>
<li>每个进程可以有一个或者多个线程（thread）<ul>
<li>每个程序在内存中运行一定会有第一个运行的线程，这个线程就是<strong>主线程</strong>；主线程之外的线程称为<strong>分支线程</strong></li>
</ul>
</li>
<li>同步调用是在同一线程内</li>
<li>异步调用的底层机制是<font color="red">多线程</font></li>
<li>串行 == 同步 == 单线程，并行 == 异步 == 多线程</li>
<li><img src="/.com//Users\8y\AppData\Roaming\Typora\typora-user-images\image-20220918162324195.png" alt="image-20220918162324195"></li>
</ul>
</li>
<li><p>隐式多线程 v.s 显式多线程</p>
<ul>
<li><p>直接同步调用：使用方法名</p>
<ul>
<li><p>```c#<br>using System;<br>using System.Collections.Generic;<br>using System.Threading;</p>
<p>namespace MulticastDelegateExample<br>{</p>
<pre><code>class Program
&#123;
    static void Main(string[] args)
    &#123;
        Student stu1 = new Student() &#123; ID = 1, PenColor = ConsoleColor.Red &#125;;
        Student stu2 = new Student() &#123; ID = 2, PenColor = ConsoleColor.Green &#125;;
        Student stu3 = new Student() &#123; ID = 3, PenColor = ConsoleColor.Blue &#125;;
        
        //直接同步调用
        stu1.DoHomework();
        stu2.DoHomework();
        stu3.DoHomework();

        for (int i = 0; i &lt; 10; i++)
        &#123;
            Console.ForegroundColor = ConsoleColor.Cyan;
            Console.WriteLine($&quot;Main thread &#123;i&#125;&quot;);
            Thread.Sleep(1000);
        &#125;
    &#125;
&#125;

class Student
&#123;
    public int ID &#123; get; set; &#125;
    public ConsoleColor PenColor &#123; get; set; &#125;

    public void DoHomework()
    &#123;
        for (int i = 0; i &lt; 5; i++)
        &#123;
            Console.ForegroundColor = this.PenColor;
            //ForegroundColor 获取或设置控制太的前景色
            Console.WriteLine($&quot;Student &#123;this.ID&#125; doing homework &#123;i&#125; hour(s).&quot;);
            Thread.Sleep(1000);
            //使该线程睡眠1秒
        &#125;
    &#125;
&#125;
</code></pre>
<p>}</p>
<pre class="line-numbers language-none"><code class="language-none">
    

- 间接同步调用：使用单播&#x2F;多播委托的invoke方法

  - &#96;&#96;&#96;c#
    using System;
    using System.Collections.Generic;
    using System.Threading;
    
    namespace MulticastDelegateExample
    &#123;
        class Program
        &#123;
            static void Main(string[] args)
            &#123;
                Student stu1 &#x3D; new Student() &#123; ID &#x3D; 1, PenColor &#x3D; ConsoleColor.Red &#125;;
                Student stu2 &#x3D; new Student() &#123; ID &#x3D; 2, PenColor &#x3D; ConsoleColor.Green &#125;;
                Student stu3 &#x3D; new Student() &#123; ID &#x3D; 3, PenColor &#x3D; ConsoleColor.Blue &#125;;
    
                Action action1 &#x3D; new Action(stu1.DoHomework);
                Action action2 &#x3D; new Action(stu2.DoHomework);
                Action action3 &#x3D; new Action(stu3.DoHomework);
    
                &#x2F;&#x2F;间接同步调用
                action1.Invoke();
                action2.Invoke();
                action3.Invoke();
                
                for (int i &#x3D; 0; i &lt; 10; i++)
                &#123;
                    Console.ForegroundColor &#x3D; ConsoleColor.Cyan;
                    Console.WriteLine($&quot;Main thread &#123;i&#125;&quot;);
                    Thread.Sleep(1000);
                &#125;
            &#125;
        &#125;
    
        class Student
        &#123;
            public int ID &#123; get; set; &#125;
            public ConsoleColor PenColor &#123; get; set; &#125;
    
            public void DoHomework()
            &#123;
                for (int i &#x3D; 0; i &lt; 5; i++)
                &#123;
                    Console.ForegroundColor &#x3D; this.PenColor;
                    &#x2F;&#x2F;ForegroundColor 获取或设置控制太的前景色
                    Console.WriteLine($&quot;Student &#123;this.ID&#125; doing homework &#123;i&#125; hour(s).&quot;);
                    Thread.Sleep(1000);
                    &#x2F;&#x2F;使该线程睡眠1秒
                &#125;
            &#125;
        &#125;
    &#125;
    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>运行结果如下：</p>
</li>
<li><p>```<br>Student 1 doing homework 0 hour(s).<br>Student 1 doing homework 1 hour(s).<br>Student 1 doing homework 2 hour(s).<br>Student 1 doing homework 3 hour(s).<br>Student 1 doing homework 4 hour(s).<br>Student 2 doing homework 0 hour(s).<br>Student 2 doing homework 1 hour(s).<br>Student 2 doing homework 2 hour(s).<br>Student 2 doing homework 3 hour(s).<br>Student 2 doing homework 4 hour(s).<br>Student 3 doing homework 0 hour(s).<br>Student 3 doing homework 1 hour(s).<br>Student 3 doing homework 2 hour(s).<br>Student 3 doing homework 3 hour(s).<br>Student 3 doing homework 4 hour(s).<br>Main thread 0<br>Main thread 1<br>Main thread 2<br>Main thread 3<br>Main thread 4<br>Main thread 5<br>Main thread 6<br>Main thread 7<br>Main thread 8<br>Main thread 9</p>
<pre class="line-numbers language-none"><code class="language-none">
  - 多播同步调用和上面多播委托的示例类似

    

- 隐式异步调用：使用委托的Begininvoke

  - &#96;&#96;&#96;c#
    using System;
    using System.Collections.Generic;
    using System.Threading;
    
    namespace MulticastDelegateExample
    &#123;
        class Program
        &#123;
            static void Main(string[] args)
            &#123;
                Student stu1 &#x3D; new Student() &#123; ID &#x3D; 1, PenColor &#x3D; ConsoleColor.Red &#125;;
                Student stu2 &#x3D; new Student() &#123; ID &#x3D; 2, PenColor &#x3D; ConsoleColor.Green &#125;;
                Student stu3 &#x3D; new Student() &#123; ID &#x3D; 3, PenColor &#x3D; ConsoleColor.Blue &#125;;
    
                Action action1 &#x3D; new Action(stu1.DoHomework);
                Action action2 &#x3D; new Action(stu2.DoHomework);
                Action action3 &#x3D; new Action(stu3.DoHomework);
    
                &#x2F;&#x2F;隐式异步调用
                action1.BeginInvoke(null, null);
                action2.BeginInvoke(null, null);
                action3.BeginInvoke(null, null);
    
                for (int i &#x3D; 0; i &lt; 10; i++)
                &#123;
                    Console.ForegroundColor &#x3D; ConsoleColor.Cyan;
                    Console.WriteLine($&quot;Main thread &#123;i&#125;&quot;);
                    Thread.Sleep(1000);
                &#125;
            &#125;
        &#125;
    
        class Student
        &#123;
            public int ID &#123; get; set; &#125;
            public ConsoleColor PenColor &#123; get; set; &#125;
    
            public void DoHomework()
            &#123;
                for (int i &#x3D; 0; i &lt; 5; i++)
                &#123;
                    Console.ForegroundColor &#x3D; this.PenColor;
                    &#x2F;&#x2F;ForegroundColor 获取或设置控制太的前景色
                    Console.WriteLine($&quot;Student &#123;this.ID&#125; doing homework &#123;i&#125; hour(s).&quot;);
                    Thread.Sleep(1000);
                    &#x2F;&#x2F;使该线程睡眠1秒
                &#125;
            &#125;
        &#125;
    &#125;
    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>运行结果如下：</p>
</li>
<li><p>```<br>Main thread 0<br>Student 2 doing homework 0 hour(s).<br>Student 3 doing homework 0 hour(s).<br>Student 1 doing homework 0 hour(s).<br>Main thread 1<br>Student 2 doing homework 1 hour(s).<br>Student 3 doing homework 1 hour(s).<br>Student 1 doing homework 1 hour(s).<br>Student 1 doing homework 2 hour(s).<br>Student 2 doing homework 2 hour(s).<br>Student 3 doing homework 2 hour(s).<br>Main thread 2<br>Student 2 doing homework 3 hour(s).<br>Student 3 doing homework 3 hour(s).<br>Student 1 doing homework 3 hour(s).<br>Main thread 3<br>Main thread 4<br>Student 3 doing homework 4 hour(s).<br>Student 1 doing homework 4 hour(s).<br>Student 2 doing homework 4 hour(s).<br>Main thread 5<br>Main thread 6<br>Main thread 7<br>Main thread 8<br>Main thread 9</p>
<pre class="line-numbers language-none"><code class="language-none">
  - 分之线程和主线程同时执行，发生了资源上的争抢

  - 发生冲突导致颜色不一样

    

- 显式异步调用：使用Thread或Task

  - Thread是一种比较古老的方式

  - &#96;&#96;&#96;c#
    using System;
    using System.Collections.Generic;
    using System.Threading;
    
    namespace MulticastDelegateExample
    &#123;
        class Program
        &#123;
            static void Main(string[] args)
            &#123;
                Student stu1 &#x3D; new Student() &#123; ID &#x3D; 1, PenColor &#x3D; ConsoleColor.Red &#125;;
                Student stu2 &#x3D; new Student() &#123; ID &#x3D; 2, PenColor &#x3D; ConsoleColor.Green &#125;;
                Student stu3 &#x3D; new Student() &#123; ID &#x3D; 3, PenColor &#x3D; ConsoleColor.Blue &#125;;
    
                &#x2F;&#x2F;创建线程
                Thread thread1 &#x3D; new Thread(new ThreadStart(stu1.DoHomework));
                Thread thread2 &#x3D; new Thread(new ThreadStart(stu2.DoHomework));
                Thread thread3 &#x3D; new Thread(new ThreadStart(stu3.DoHomework));
    
                thread1.Start();
                thread2.Start();
                thread3.Start();
    
                for (int i &#x3D; 0; i &lt; 10; i++)
                &#123;
                    Console.ForegroundColor &#x3D; ConsoleColor.Cyan;
                    Console.WriteLine($&quot;Main thread &#123;i&#125;&quot;);
                    Thread.Sleep(1000);
                &#125;
            &#125;
        &#125;
    
        class Student
        &#123;
            public int ID &#123; get; set; &#125;
            public ConsoleColor PenColor &#123; get; set; &#125;
    
            public void DoHomework()
            &#123;
                for (int i &#x3D; 0; i &lt; 5; i++)
                &#123;
                    Console.ForegroundColor &#x3D; this.PenColor;
                    &#x2F;&#x2F;ForegroundColor 获取或设置控制太的前景色
                    Console.WriteLine($&quot;Student &#123;this.ID&#125; doing homework &#123;i&#125; hour(s).&quot;);
                    Thread.Sleep(1000);
                    &#x2F;&#x2F;使该线程睡眠1秒
                &#125;
            &#125;
        &#125;
    &#125;
    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>运行结果如下：</p>
</li>
<li><p>```<br>Student 2 doing homework 0 hour(s).<br>Main thread 0<br>Student 1 doing homework 0 hour(s).<br>Student 3 doing homework 0 hour(s).<br>Student 3 doing homework 1 hour(s).<br>Student 2 doing homework 1 hour(s).<br>Main thread 1<br>Student 1 doing homework 1 hour(s).<br>Student 1 doing homework 2 hour(s).<br>Student 2 doing homework 2 hour(s).<br>Main thread 2<br>Student 3 doing homework 2 hour(s).<br>Student 2 doing homework 3 hour(s).<br>Student 3 doing homework 3 hour(s).<br>Student 1 doing homework 3 hour(s).<br>Main thread 3<br>Student 3 doing homework 4 hour(s).<br>Student 2 doing homework 4 hour(s).<br>Main thread 4<br>Student 1 doing homework 4 hour(s).<br>Main thread 5<br>Main thread 6<br>Main thread 7<br>Main thread 8<br>Main thread 9</p>
<pre class="line-numbers language-none"><code class="language-none">
- 分之线程和主线程同时执行，发生了资源上的争抢

- 接下来使用Task，相对于Thread来说会高级一些

- &#96;&#96;&#96;c#
  using System;
  using System.Collections.Generic;
  using System.Threading;
  using System.Threading.Tasks;
  
  namespace MulticastDelegateExample
  &#123;
      class Program
      &#123;
          static void Main(string[] args)
          &#123;
              Student stu1 &#x3D; new Student() &#123; ID &#x3D; 1, PenColor &#x3D; ConsoleColor.Red &#125;;
              Student stu2 &#x3D; new Student() &#123; ID &#x3D; 2, PenColor &#x3D; ConsoleColor.Green &#125;;
              Student stu3 &#x3D; new Student() &#123; ID &#x3D; 3, PenColor &#x3D; ConsoleColor.Blue &#125;;
  
              Task task1 &#x3D; new Task(new Action(stu1.DoHomework));
              Task task2 &#x3D; new Task(new Action(stu2.DoHomework));
              Task task3 &#x3D; new Task(new Action(stu3.DoHomework));
  
              task1.Start();
              task2.Start();
              task3.Start();
  
              for (int i &#x3D; 0; i &lt; 10; i++)
              &#123;
                  Console.ForegroundColor &#x3D; ConsoleColor.Cyan;
                  Console.WriteLine($&quot;Main thread &#123;i&#125;&quot;);
                  Thread.Sleep(1000);
              &#125;
          &#125;
      &#125;
  
      class Student
      &#123;
          public int ID &#123; get; set; &#125;
          public ConsoleColor PenColor &#123; get; set; &#125;
  
          public void DoHomework()
          &#123;
              for (int i &#x3D; 0; i &lt; 5; i++)
              &#123;
                  Console.ForegroundColor &#x3D; this.PenColor;
                  &#x2F;&#x2F;ForegroundColor 获取或设置控制太的前景色
                  Console.WriteLine($&quot;Student &#123;this.ID&#125; doing homework &#123;i&#125; hour(s).&quot;);
                  Thread.Sleep(1000);
                  &#x2F;&#x2F;使该线程睡眠1秒
              &#125;
          &#125;
      &#125;
  &#125;
  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>应适时地使用接口（interface）取代一些对委托的使用</p>
<ul>
<li><p>Java完全地使用接口取代了委托的功能，即Java没有与C#中委托相对应的功能实体</p>
</li>
<li><p>```c#<br>using System;<br>using System.Collections.Generic;</p>
<p>namespace DelegateExample<br>{</p>
<pre><code>class Program
&#123;
    static void Main(string[] args)
    &#123;
        IProcutFactory pizzaFactory = new PizzaFactory();
        IProcutFactory toycarFactory = new ToyCarFactory();
        WrapFactory wrapFactory = new WrapFactory();

        Box box1 = wrapFactory.WrapProcut(pizzaFactory);
        Box box2 = wrapFactory.WrapProcut(toycarFactory);

        Console.WriteLine(box1.Product.Name);
        Console.WriteLine(box2.Product.Name);
    &#125;
&#125;

interface IProcutFactory
&#123;
    Product Make();
&#125;

class PizzaFactory : IProcutFactory
&#123;
    public Product Make()
    &#123;
        Product product = new Product();
        product.Name = &quot;Pizza&quot;;
        return product;
    &#125;
&#125;

class ToyCarFactory : IProcutFactory
&#123;
    public Product Make()
    &#123;
        Product product = new Product();
        product.Name = &quot;ToyCar&quot;;
        return product;
    &#125;
&#125;


class Product   //产品类
&#123;
    public string  Name &#123; get; set; &#125;   //属性的简略声明，一般只用来传递数据
    public double Price &#123; get; set; &#125;   //新增产品的价格
&#125;

class Box       //盒子类
&#123;
    public Product Product &#123; get; set; &#125;
&#125;

class WrapFactory   //包装厂的类
&#123;
    //模板方法
    public Box WrapProcut(IProcutFactory procutFactory)
    &#123;
        Box box = new Box();
        Product product = procutFactory.Make();
        box.Product = product;
        return box;
    &#125;
&#125;

/*
class ProductFactory    //产品生产厂的类
&#123;
    public Product MakePizza()  //制作披萨的方法
    &#123;
        Product product = new Product();
        product.Name = &quot;Pizza&quot;;
        product.Price = 12;
        return product;
    &#125;

    public Product MakeToyCar() //制作玩具车的方法
    &#123;
        Product product = new Product();
        product.Name = &quot;ToyCar&quot;;
        product.Price = 120;
        return product;
    &#125;
&#125;
*/
</code></pre>
<p>}</p>
<pre class="line-numbers language-none"><code class="language-none">
    

















## 12 .事件详解

### 12.1 初步了解事件

- &lt;font color&#x3D;FF5555&gt;定义&lt;&#x2F;font&gt;：单词Event,译为“事件”

  - 《牛津词典》中的解释是“a thing that **happens**,especially something important”

    - 也就是说如果一个作为主语，它能够用**发生**作为谓语，那么它就能作为一个事件
    - 例如拿苹果为主语，那么谓语就不能用**发生**，因为我们谁也不会说苹果发生了（其实也可以，例如说苹果熟透了）
    - 公司上市，产品发布都是一个事件，事件就是能够发生的什么事情。

  - 通常的解释就是“&lt;font color &#x3D;red&gt;能够发生的什么事情&lt;&#x2F;font&gt;”

    

- &lt;font color&#x3D;FF5555&gt;角色&lt;&#x2F;font&gt;：使对象或类具备&lt;font color &#x3D;red&gt;通知能力&lt;&#x2F;font&gt;的成员

  - （中译）事件（event）是一种使对象或类能够提供通知的成员

  - （原文）An event is a member that enables an object or class to provide notifications.

  - “对象O拥有一个事件E”想表达的思想是：当事件E发生的时候，O有能力通知别的对象

    

- 事件的功能 &#x3D; 通知 + 可选的事件参数（即详细信息）

  

- &lt;font color&#x3D;FF5555&gt;使用&lt;&#x2F;font&gt;：用于对象或类间的动作协调与信息传递（消息同送）

  

- &lt;font color&#x3D;FF5555&gt;原理&lt;&#x2F;font&gt;：事件模型（event model）中的两个”5“

  - ”&lt;font color&#x3D;red&gt;发生 --&gt; 响应&lt;&#x2F;font&gt;“中的5个部分——闹钟响了你起床、孩子饿了你做饭......这里隐含着”订阅“关系
    - 闹钟、响了、你、起床、订阅（可以想想为为什么别人家的闹钟响了你就不起床呢？）
    - 孩子、饿了、你、做饭、订阅（可以想想为为什么别人家的孩子饿了你就不用做饭呢？）
  - ”&lt;font color&#x3D;red&gt;发生 --&gt; 响应&lt;&#x2F;font&gt;“中的5个动作
    - （1）我有一件事
    - （2）一个人或一群人关心我的这个事件
    - （3）我的这个事件发生了
    - （4）关心这个事件的人会被依次通知到
    - （5）被通知的人根据拿到的事件信息（又称”事件数据“、”事件参数“、”通知“）对事件进行响应（又称”处理事件“）。



- 事件的订阅者
  - 事件消息的接收者
  - 事件的响应者
  - 事件的处理者
  - 被事件所通知的对象
  - 以上为一回事，统一用**事件的订阅者**

- 事件参数
  - 事件信息
  - 事件消息
  - 事件数据
  - 以上为一回事，统一用微软的标准**事件参数**



- &lt;font color&#x3D;FF5555&gt;提示&lt;&#x2F;font&gt;
  - 事件多用于桌面、手机等开发的客户端编程，因为这些程序经常是用户通过事件来”驱动的“
  - 各种编程语言对这个机制的实现方式不尽相同
  - Java语言里没有事件这种成员，也没有委托这种数据类型。Java的”事件“是使用接口来是实现的
  - MVC、MVP、MVVM等模式，是事件模式更高级、更有效的”玩法“
  - 日常开发的时候，使用已有事件的机会比较多，自己声明事件的机会比较少，所以先学使用





### 12.2 事件的应用

- 实例演示
  - 派生（继承）与扩展（extends）



- 事件模型的五个组成部分
  1.  事件的拥有者（event source，对象）
      - 事件不会主动发生
      - 当用户点击一个按钮，是用户的鼠标向计算机硬件发送了一个电讯号，硬件之所以能工作，全靠操作系统来协调管理。当Windows侦听到由鼠标发过来的电讯号，它就会查看一下鼠标指针在屏幕上的当前位置，实际上在Windows操作系统启动的时候，它就一直在追踪鼠标指针在屏幕上的位置，这个是所有图形用户操作系统最基本的功能之一。当Windows发现这个鼠标指针的位置由一个按钮，而且包含这个按钮的窗口处于激活状态的时候，它就会通知这个按钮，你被这个用户按下了，这时候按钮的内部逻辑就被执行了。
      - 用户按按钮，是用户的操作通过windows操作系统调用了按钮的内部逻辑，最终还是按钮的内部逻辑触发了click事件
  2.  事件成员（event，成员）
  3.  事件的响应者（event subscriber，对象）
  4.  事件处理器（event handler ，成员）——本质上是一个回调方法
  5.  事件订阅——把事件处理器与事件关联在一起，本质上是一种以委托类型为基础的”约定“
  6.  ![image-20220918200959915](C:\Users\8y\AppData\Roaming\Typora\typora-user-images\image-20220918200959915.png)
  7.  ![image-20220918201025294](C:\Users\8y\AppData\Roaming\Typora\typora-user-images\image-20220918201025294.png)



- 注意

  - 事件处理器是成员方法
  - 挂接事件处理器的时候，可以使用委托实例，也可以直接使用方法名，这是个”语法糖“
  - 事件处理器对事件的订阅不是随意的，匹配与否由声明时间是所使用的委托类型来检测
  - 事件可以同步调用也可以异步调用

- 实例如下：

  - 事件成员一般是一个黄色的小闪电

  - 一个事件有两个事件处理的场景

  - &#96;&#96;&#96;c#
    using System;
    using System.Timers;
    
    namespace EventExample
    &#123;
        class Program
        &#123;
            static void Main(string[] args)
            &#123;
                Timer timer &#x3D; new Timer();  &#x2F;&#x2F;timer是事件的拥有者
                timer.Interval &#x3D; 1000;  &#x2F;&#x2F;事件间隔为1秒
                Boy boy &#x3D; new Boy();
                Girl girl &#x3D; new Girl();
                timer.Elapsed +&#x3D; boy.Action;    &#x2F;&#x2F;Elapsed事件成员 +&#x3D;事件的订阅 Action事件处理器
                timer.Elapsed +&#x3D; girl.Action;
                timer.Start();
                Console.ReadLine();
            &#125;
        &#125;
    
        class Boy   &#x2F;&#x2F;事件的响应者1
        &#123;
            &#x2F;&#x2F;internal 访问仅限当前的程序集
            internal void Action(object sender, ElapsedEventArgs e) &#x2F;&#x2F;事件处理器Action方法
            &#123;
                Console.WriteLine(&quot;Jump!&quot;);
            &#125;
        &#125;
    
        class Girl  &#x2F;&#x2F;事件的响应者2
        &#123;
            internal void Action(object sender, ElapsedEventArgs e)
            &#123;
                Console.WriteLine(&quot;Sing!&quot;);
            &#125;
        &#125;
    &#125;
    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
</li>
<li><p>运行结果是boy,girl依次打印</p>
</li>
<li><p>```<br>Jump!<br>Sing!<br>Jump!<br>Sing!<br>Jump!<br>Sing!<br>…<br>…</p>
<pre class="line-numbers language-none"><code class="language-none">
  

- 五大部分分别如下：

  - 1.事件的拥有者 timer(Timer类型的变量)
  - 2.事件成员 Elapsed事件
  - 3.事件的响应者 boy、girl(Boy&#x2F;Girl类的变量)
  - 4.事件的订阅 +&#x3D;操作符
  - 5.事件的处理器 Action方法(Boy&#x2F;Girl类的方法)

- ![image-20220918200959915](C:\Users\8y\AppData\Roaming\Typora\typora-user-images\image-20220918200959915.png)

- 上图MVC&#x2F;MVP等的模型，接下来举例上图所示的例子：

- &#96;&#96;&#96;c#
      using System;
      using System.Windows.Forms;
      
      namespace EventExample
      &#123;
          class Program
          &#123;
              static void Main(string[] args)
              &#123;
                  Form form &#x3D; new Form(); &#x2F;&#x2F;form是事件的拥有者
                  Controller controller &#x3D; new Controller(form);
                  &#x2F;&#x2F;controller 事件的响应者
                  form.ShowDialog();
              &#125;
          &#125;
      
          class Controller
          &#123;
              private Form form;
              public Controller(Form form)
              &#123;
                  if (form!&#x3D;null) &#x2F;&#x2F;判断是否为空是因为如果一个对象是空的，那么我们是无法访问它的事件的
                  &#123;
                      this.form &#x3D; form;   &#x2F;&#x2F;this可以区分哪个是字段，哪个是参数
                      this.form.Click +&#x3D; this.FormClicked;    &#x2F;&#x2F;this就是Controller实例
                      &#x2F;&#x2F;事件Click
                  &#125;
              &#125;
      
              &#x2F;&#x2F;事件处理器
              private void FormClicked(object sender, EventArgs e)    &#x2F;&#x2F;你会发现和之前Elapsed的事件约定不同
              &#123;
                  this.form.Text &#x3D; DateTime.Now.ToString();
              &#125;
          &#125;
      
      &#125;
      <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>五大部分分别如下：</p>
<ul>
<li>1.事件的拥有者 form(Form类型的变量)</li>
<li>2.事件成员 Click事件</li>
<li>3.事件的响应者 controller(Controller类的变量)</li>
<li>4.事件的订阅 +=操作符</li>
<li>5.事件的处理器 FormClicked方法(Controller类的方法)</li>
</ul>
</li>
<li><p>运行结果如下，在窗口的标题栏上显示当前的时间</p>
</li>
<li><p><img src="/.com//Users\8y\AppData\Roaming\Typora\typora-user-images\image-20220919201951955.png" alt="image-20220919201951955"></p>
</li>
<li><p>接下来举例2星的例子，事件的拥有者同时也是事件的处理者</p>
<ul>
<li>```c#<br>using System;<br>using System.Windows.Forms;namespace EventExample<br>{<pre><code>class Program
&#123;
    static void Main(string[] args)
    &#123;
        MyForm form = new MyForm();         //form是事件的拥有者，同时也是事件的响应者
        form.Click += form.FormClicked;     //Click事件
        //FormClicked是事件处理器 +=是事件的订阅
        form.ShowDialog();
    &#125;
&#125;

class MyForm : Form
&#123;
    internal void FormClicked(object sender, EventArgs e)
    &#123;
        this.Text = DateTime.Now.ToString();
    &#125;
&#125;
</code></pre>
}<pre class="line-numbers language-none"><code class="language-none"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">
- 五大部分分别如下：

  - 1.事件的拥有者 myForm(MyForm类型的变量)
  - 2.事件成员 Click事件
  - 3.事件的响应者 myForm(MyForm类型的变量)
  - 4.事件的订阅 +&#x3D;操作符
  - 5.事件的处理器 FormClicked方法(属于MyForm类型的方法)

- 接下来举例3星的例子：事件的拥有者是事件的响应者的字段成员，事件的响应者用自己的方法订阅着自己的字段成员的某个事件。

- ![image-20220922150825669](C:\Users\8y\AppData\Roaming\Typora\typora-user-images\image-20220922150825669.png)

  - &#96;&#96;&#96;c#
    using System;
    using System.Windows.Forms;
    
    namespace EventExample
    &#123;
        class Program
        &#123;
            static void Main(string[] args)
            &#123;
                MyForm form &#x3D; new MyForm();   &#x2F;&#x2F;MyForm对象是事件的响应者
                form.ShowDialog();
            &#125;
        &#125;
    
        class MyForm : Form
        &#123;
            &#x2F;&#x2F;事件的拥有者 字段button
            private TextBox textBox;
            private Button button;
    
    
            public MyForm()
            &#123; 
                this.textBox &#x3D; new TextBox();   
                this.button &#x3D; new Button();
                this.Controls.Add(this.textBox);
                this.Controls.Add(this.button);
                this.button.Click +&#x3D; this.ButtonClick;
                &#x2F;&#x2F;非可视化编程
                this.button.Text &#x3D; &quot;Say Hello&quot;;
                this.button.Top &#x3D; 20;
                &#x2F;&#x2F;事件成员(事件)Click +&#x3D;事件订阅
            &#125;
    
            &#x2F;&#x2F;事件处理器
            private void ButtonClick(object sender, EventArgs e)
            &#123;
                this.textBox.Text &#x3D; &quot;Hello,World!&quot;;
            &#125;
        &#125;
    
    &#125;
    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
<li><p>五大部分分别如下：</p>
<ul>
<li>1.事件的拥有者 button(MyForm类型的字段)</li>
<li>2.事件成员 Click事件(MyForm类型的字段button的事件)</li>
<li>3.事件的响应者 myForm(myForm类的变量)</li>
<li>4.事件的订阅 +=操作符</li>
<li>5.事件的处理器 ButtonClicked方法(事件的响应者myForm所拥有的方法)</li>
</ul>
</li>
<li><p>运行结果如下：</p>
</li>
<li><p><img src="/.com//Users\8y\AppData\Roaming\Typora\typora-user-images\image-20220919204217195.png" alt="image-20220919204217195"></p>
</li>
<li><p>有趣的知识点</p>
</li>
<li><p>例如有如下窗口Form1，里面有一个textbox1和button1、button2，你可以同时将两个button的click事件设置为ButtonClick事件</p>
</li>
<li><p><img src="/.com//Users\8y\AppData\Roaming\Typora\typora-user-images\image-20220920195659807.png" alt="image-20220920195659807"></p>
</li>
<li><p>同时代码如下：</p>
<ul>
<li>```c#<br>using System;<br>using System.Collections.Generic;<br>using System.ComponentModel;<br>using System.Data;<br>using System.Drawing;<br>using System.Linq;<br>using System.Text;<br>using System.Threading.Tasks;<br>using System.Windows.Forms;namespace WinFormExample<br>{<pre><code>public partial class Form1 : Form
&#123;
    public Form1()
    &#123;
        InitializeComponent();
    &#125;

    private void ButtonClick(object sender, EventArgs e)
    &#123;
        //sender为事件的拥有者
        if (sender == this.button1)
        &#123;
            this.textBox1.Text = &quot;Hello&quot;;
        &#125;
        else if (sender == this.button2)
        &#123;
            this.textBox1.Text = &quot;World&quot;;
        &#125;
    &#125;
&#125;
</code></pre>
}<pre class="line-numbers language-none"><code class="language-none"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">
- 运行结果是当你点击button1，textbox1的内容为Hello

  - 当你点击button2，textbox1的内容为World

### 12.3 深入理解事件

### 12.4 事件的声明

- 事件的声明

  - 完整声明

    - 事件是基于委托的有两层意思

      - 第一层意思：事件需要委托类型来做一个约束。约束既规定事件能发送什么样的消息给响应者，也规定事件响应者能收到什么样的事件消息。这就决定了事件响应者的事件处理器，必须能够和这个约束匹配上，才能够订阅这个事件。
      - 第二层意思：当事件响应者向事件拥有者提供了能够匹配这个事件的事件处理器之后，需要把事件处理器保存或者记录下来。能够记录或者说引用方法的任务，只有委托类型的实例能够做到。

    - 例子如下：

    - &#96;&#96;&#96;c#
      using System;
      using System.Collections.Generic;
      using System.Linq;
      using System.Text;
      using System.Threading.Tasks;
      using System.Threading;
      
      namespace EventExample
      &#123;
          class Program
          &#123;
              static void Main(string[] args)
              &#123;
                  Customer customer &#x3D; new Customer();     &#x2F;&#x2F;customer事件的拥有者
                  Waiter waiter &#x3D; new Waiter();           &#x2F;&#x2F;waiter事件的响应者
                  customer.Order +&#x3D; waiter.Action;        &#x2F;&#x2F;Order事件 +&#x3D;事件约束 Action事件处理器
                  customer.Action();
                  customer.PayTheBill();
              &#125;
          &#125;
      
          public class OrderEventArgs:EventArgs
          &#123;
              public string DishName &#123; get; set; &#125;
              public string Size &#123; get; set; &#125;
      
          &#125;
      
          &#x2F;&#x2F;委托isClass
          public delegate void OrderEventHandler(Customer customer, OrderEventArgs e);
          &#x2F;&#x2F;第一个参数表明事件的拥有者，这里是Customer
          &#x2F;&#x2F;第二个参数用来保存状态信息，指明什么类型适用于该应用程序，比如点餐和大小
      
          &#x2F;&#x2F;事件的拥有者类Customer顾客
          public class Customer
          &#123;
              private OrderEventHandler orderEventHandler;    &#x2F;&#x2F;引用事件处理器
      
              public event OrderEventHandler Order    &#x2F;&#x2F;事件
              &#123;
                  add &#x2F;&#x2F;事件处理器添加器
                  &#123;
                      this.orderEventHandler +&#x3D; value;
                  &#125;
                  remove &#x2F;&#x2F;事件处理器移除器
                  &#123;
                      this.orderEventHandler -&#x3D; value;
                  &#125;
              &#125;
              public double Bill &#123; get; set; &#125;    &#x2F;&#x2F;点单付费
              public void PayTheBill()
              &#123;
                  Console.WriteLine($&quot;I will pay $&#123;this.Bill&#125;&quot;);
              &#125;
      
              public void WalkIn()
              &#123;
                  Console.WriteLine(&quot;Walk into the restaurant.&quot;);
              &#125;
      
              public void SitDown()
              &#123;
                  Console.WriteLine(&quot;Sit down&quot;);
              &#125;
      
              public void Think()
              &#123;
                  for (int i &#x3D; 0; i &lt; 5; i++)
                  &#123;
                      Console.WriteLine(&quot;Let me think&quot;);
                      Thread.Sleep(1000);
                  &#125;
      
                  if(this.orderEventHandler !&#x3D; null)&#x2F;&#x2F;null意味着没有服务员订阅你的order事件
                  &#123;
                      OrderEventArgs e &#x3D; new OrderEventArgs();
                      e.DishName &#x3D; &quot;Kongpao Chicken&quot;;
                      e.Size &#x3D; &quot;large&quot;;
                      this.orderEventHandler.Invoke(this, e);
                  &#125;
              &#125;
      
              public void Action()
              &#123;
                  Console.ReadLine();
                  this.WalkIn();
                  this.SitDown();
                  this.Think();
              &#125;
          &#125;
      
          public class Waiter
          &#123;
              public void Action(Customer customer, OrderEventArgs e)
              &#123;
                  Console.WriteLine($&quot;I will serve you the dish - &#123;e.DishName&#125;&quot;);
                  double price &#x3D; 10;
                  switch (e.Size)
                  &#123;
                      case &quot;small&quot;:
                          price *&#x3D; 0.5;
                          break;
                      case &quot;large&quot;:
                          price *&#x3D; 1.5;
                          break;
                      default:
                          break;
                  &#125;
                  customer.Bill +&#x3D; price;
              &#125;
          &#125;
      &#125;
      <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

  <pre class="line-numbers language-none"><code class="language-none">  
- 运行结果如下：

- &#96;&#96;&#96;
  
  Walk into the restaurant.
  Sit down
  Let me think
  Let me think
  Let me think
  Let me think
  Let me think
  I will serve you the dish - Kongpao Chicken
  I will pay $15<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><p>五大部分分别如下：</p>
<ul>
<li>1.事件的拥有者 customer(Customer类型的成员)</li>
<li>2.事件成员 Order事件(Customer类型的事件Order)</li>
<li>3.事件的响应者 waiter(Waiter类的变量)</li>
<li>4.事件的订阅 +=操作符</li>
<li>5.事件的处理器 Action方法(Waiter类的方法)</li>
</ul>
</li>
<li><p>简略声明（字段式声明，field-like）</p>
<ul>
<li>```c#<br>using System;<br>using System.Collections.Generic;<br>using System.Linq;<br>using System.Text;<br>using System.Threading.Tasks;<br>using System.Threading;namespace EventExample<br>{<pre><code>class Program
&#123;
    static void Main(string[] args)
    &#123;
        Customer customer = new Customer();     //customer事件的拥有者
        Waiter waiter = new Waiter();           //waiter事件的响应者
        customer.Order += waiter.Action;        //Order事件 +=事件约束 Action事件处理器
        customer.Action();
        customer.PayTheBill();
    &#125;
&#125;

public class OrderEventArgs:EventArgs
&#123;
    public string DishName &#123; get; set; &#125;
    public string Size &#123; get; set; &#125;

&#125;

//委托isClass
public delegate void OrderEventHandler(Customer customer, OrderEventArgs e);
//第一个参数表明事件的拥有者，这里是Customer

//事件的拥有者类Customer顾客
public class Customer
&#123;
    public event OrderEventHandler Order;   //事件的简略声明，field-like
    //事件的完整声明
    /*
    private OrderEventHandler orderEventHandler;    //引用事件处理器

    public event OrderEventHandler Order    //事件
    &#123;
        add //事件处理器添加器
        &#123;
            this.orderEventHandler += value;
        &#125;
        remove //事件处理器移除器
        &#123;
            this.orderEventHandler -= value;
        &#125;
    &#125;
    */
    public double Bill &#123; get; set; &#125;    //点单付费
    public void PayTheBill()
    &#123;
        Console.WriteLine($&quot;I will pay $&#123;this.Bill&#125;&quot;);
    &#125;

    public void WalkIn()
    &#123;
        Console.WriteLine(&quot;Walk into the restaurant.&quot;);
    &#125;

    public void SitDown()
    &#123;
        Console.WriteLine(&quot;Sit down&quot;);
    &#125;

    public void Think()
    &#123;
        for (int i = 0; i &lt; 5; i++)
        &#123;
            Console.WriteLine(&quot;Let me think&quot;);
            Thread.Sleep(1000);
        &#125;

        //这里用事件的名字取代了字段的名字
        if(this.Order != null)  //微软在设计这个语法糖的时候造成了这个语法的前后不一致
        &#123;
            OrderEventArgs e = new OrderEventArgs();
            e.DishName = &quot;Kongpao Chicken&quot;;
            e.Size = &quot;large&quot;;
            this.Order.Invoke(this, e);
        &#125;
    &#125;

    public void Action()
    &#123;
        Console.ReadLine();
        this.WalkIn();
        this.SitDown();
        this.Think();
    &#125;
&#125;

public class Waiter
&#123;
    public void Action(Customer customer, OrderEventArgs e)
    &#123;
        Console.WriteLine($&quot;I will serve you the dish - &#123;e.DishName&#125;&quot;);
        double price = 10;
        switch (e.Size)
        &#123;
            case &quot;small&quot;:
                price *= 0.5;
                break;
            case &quot;large&quot;:
                price *= 1.5;
                break;
            default:
                break;
        &#125;
        customer.Bill += price;
    &#125;
&#125;
</code></pre>
}<pre class="line-numbers language-none"><code class="language-none">
    - 这里用事件的名字取代了字段的名字，微软在设计这个语法糖的时候造成了这个语法的前后不一致

    - ![image-20220921154819013](C:\Users\8y\AppData\Roaming\Typora\typora-user-images\image-20220921154819013.png)

- 有了委托字段&#x2F;属性，为什么还需要事件？

  - 为了程序的逻辑更加“有道理”、更加安全，&lt;font color&#x3D;red&gt;谨防“借刀杀人”&lt;&#x2F;font&gt;

  - &#96;&#96;&#96;c#
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Text;
    using System.Threading.Tasks;
    using System.Threading;
    
    namespace EventExample
    &#123;
        class Program
        &#123;
            static void Main(string[] args)
            &#123;
                Console.ReadLine();
                Customer customer &#x3D; new Customer();     &#x2F;&#x2F;customer事件的拥有者
                Waiter waiter &#x3D; new Waiter();           &#x2F;&#x2F;waiter事件的响应者
                customer.Order +&#x3D; waiter.Action;        &#x2F;&#x2F;Order事件 +&#x3D;事件约束 Action事件处理器
                                                        &#x2F;&#x2F;customer.Action();
    
                OrderEventArgs e &#x3D; new OrderEventArgs();
                e.DishName &#x3D; &quot;Manhanquanxi&quot;;
                e.Size &#x3D; &quot;large&quot;;
    
                OrderEventArgs e2 &#x3D; new OrderEventArgs();
                e2.DishName &#x3D; &quot;Manhanquanxi&quot;;
                e2.Size &#x3D; &quot;large&quot;;
    
                Customer badGuy &#x3D; new Customer();
                badGuy.Order +&#x3D; waiter.Action;
                badGuy.Order.Invoke(customer, e);
                badGuy.Order.Invoke(customer, e2);
    
                customer.PayTheBill();
            &#125;
        &#125;
    
        public class OrderEventArgs:EventArgs
        &#123;
            public string DishName &#123; get; set; &#125;
            public string Size &#123; get; set; &#125;
    
        &#125;
    
        &#x2F;&#x2F;委托isClass
        public delegate void OrderEventHandler(Customer customer, OrderEventArgs e);
        &#x2F;&#x2F;第一个参数表明事件的拥有者，这里是Customer
    
        &#x2F;&#x2F;事件的拥有者类Customer顾客
        public class Customer
        &#123;
            public OrderEventHandler Order;   &#x2F;&#x2F;去掉event之后成了字段,event抑制外部滥用
    
            public double Bill &#123; get; set; &#125;    &#x2F;&#x2F;点单付费
            public void PayTheBill()
            &#123;
                Console.WriteLine($&quot;I will pay $&#123;this.Bill&#125;&quot;);
            &#125;
    
            public void WalkIn()
            &#123;
                Console.WriteLine(&quot;Walk into the restaurant.&quot;);
            &#125;
    
            public void SitDown()
            &#123;
                Console.WriteLine(&quot;Sit down&quot;);
            &#125;
    
            public void Think()
            &#123;
                for (int i &#x3D; 0; i &lt; 5; i++)
                &#123;
                    Console.WriteLine(&quot;Let me think&quot;);
                    Thread.Sleep(1000);
                &#125;
    
                &#x2F;&#x2F;这里用事件的名字取代了字段的名字
                if(this.Order !&#x3D; null)  &#x2F;&#x2F;微软在设计这个语法糖的时候造成了这个语法的前后不一致
                &#123;
                    OrderEventArgs e &#x3D; new OrderEventArgs();
                    e.DishName &#x3D; &quot;Kongpao Chicken&quot;;
                    e.Size &#x3D; &quot;large&quot;;
                    this.Order.Invoke(this, e);
                &#125;
            &#125;
    
            public void Action()
            &#123;
                Console.ReadLine();
                this.WalkIn();
                this.SitDown();
                this.Think();
            &#125;
        &#125;
    
        public class Waiter
        &#123;
            public void Action(Customer customer, OrderEventArgs e)
            &#123;
                Console.WriteLine($&quot;I will serve you the dish - &#123;e.DishName&#125;&quot;);
                double price &#x3D; 10;
                switch (e.Size)
                &#123;
                    case &quot;small&quot;:
                        price *&#x3D; 0.5;
                        break;
                    case &quot;large&quot;:
                        price *&#x3D; 1.5;
                        break;
                    default:
                        break;
                &#125;
                customer.Bill +&#x3D; price;
            &#125;
        &#125;
    &#125;
    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
</li>
</ul>
</li>
<li><p>所以<font color="red">事件的本质</font>是委托字段的一个包装器</p>
<ul>
<li>这个包装器对委托字段的访问起<font color="red">限制作用</font>，相当于一个“蒙版”</li>
<li>封装（encapsulation）的一个重要功能就是隐藏</li>
<li>事件<font color="red">对外界</font>隐藏了委托实例的大部分功能，<font color="red">仅暴露添加/移除事件处理器的功能</font></li>
<li>添加/移除事件处理器的时候可以直接使用方法名，这是委托实例所不具备的功能</li>
</ul>
</li>
<li><p>用于声明事件的委托类型的命名约定</p>
<ul>
<li><p>用于声明Foo事件的委托，一般命名为FooEventHandler（除非是一个非常通用的事件约束）</p>
<ul>
<li><p>使用通过委托EventHandler</p>
</li>
<li><p>```c#<br>using System;<br>using System.Collections.Generic;<br>using System.Linq;<br>using System.Text;<br>using System.Threading.Tasks;<br>using System.Threading;</p>
<p>namespace EventExample<br>{</p>
<pre><code>class Program
&#123;
    static void Main(string[] args)
    &#123;
        Customer customer = new Customer();     //customer事件的拥有者
        Waiter waiter = new Waiter();           //waiter事件的响应者
        customer.Order += waiter.Action;        //Order事件 +=事件约束 Action事件处理器
        customer.Action();
        customer.PayTheBill();
    &#125;
&#125;

public class OrderEventArgs : EventArgs
&#123;
    public string DishName &#123; get; set; &#125;
    public string Size &#123; get; set; &#125;

&#125;

//委托isClass
//public delegate void OrderEventHandler(Customer customer, OrderEventArgs e);
//第一个参数表明事件的拥有者，这里是Customer

//事件的拥有者类Customer顾客
public class Customer
&#123;
    public event EventHandler Order;   //事件的简略声明，field-like

    public double Bill &#123; get; set; &#125;    //点单付费
    public void PayTheBill()
    &#123;
        Console.WriteLine($&quot;I will pay $&#123;this.Bill&#125;&quot;);
    &#125;

    public void WalkIn()
    &#123;
        Console.WriteLine(&quot;Walk into the restaurant.&quot;);
    &#125;

    public void SitDown()
    &#123;
        Console.WriteLine(&quot;Sit down&quot;);
    &#125;

    public void Think()
    &#123;
        for (int i = 0; i &lt; 5; i++)
        &#123;
            Console.WriteLine(&quot;Let me think&quot;);
            Thread.Sleep(1000);
        &#125;

        //这里用事件的名字取代了字段的名字
        if (this.Order != null)  //微软在设计这个语法糖的时候造成了这个语法的前后不一致
        &#123;
            OrderEventArgs e = new OrderEventArgs();
            e.DishName = &quot;Kongpao Chicken&quot;;
            e.Size = &quot;large&quot;;
            this.Order.Invoke(this, e);
        &#125;
    &#125;

    public void Action()
    &#123;
        Console.ReadLine();
        this.WalkIn();
        this.SitDown();
        this.Think();
    &#125;
&#125;

public class Waiter
&#123;
    public void Action(object sender, EventArgs e)
    &#123;
        //类型转换
        Customer customer = sender as Customer;
        OrderEventArgs orderInfo = e as OrderEventArgs;
        Console.WriteLine($&quot;I will serve you the dish - &#123;orderInfo.DishName&#125;&quot;);
        double price = 10;
        switch (orderInfo.Size)
        &#123;
            case &quot;small&quot;:
                price *= 0.5;
                break;
            case &quot;large&quot;:
                price *= 1.5;
                break;
            default:
                break;
        &#125;
        customer.Bill += price;
    &#125;
&#125;
</code></pre>
<p>}</p>
<pre class="line-numbers language-none"><code class="language-none">
    

- FooEventHandler委托的参数一般有两个（由Win32 API演化而来，历史悠久）

  - 第一个是object类型，名字为sender，实际上就是事件的拥有者、事件的source
    - 用于保存触发事件的对象的引用
  - 第二个是EventArgs类的派生类，类名一般为FooEventArgs，参数名为e。也就是前面讲过的事件参数
    - 用来保存状态信息，指明什么类型适用于该应用程序
  - 虽然没有官方的说法，但我们可以把委托的参数列表看作是事件发生后发给给事件响应者的&lt;font color&#x3D;red&gt;“事件消息”&lt;&#x2F;font&gt;

- 触发Foo事件的方法一般命名为OnFoo，即“因何引发”、&lt;font color&#x3D;red&gt;“事出有因”&lt;&#x2F;font&gt;

  - 访问级别为protected，不能用public，不然又成了可以“借刀杀人了”

    - 之前我们写的think方法违反了.net规定的原则，即一个方法只能做一件事

    - &#96;&#96;&#96;c#
      		  public void Think()
             &#123;
                 for (int i &#x3D; 0; i &lt; 5; i++)
                 &#123;
                     Console.WriteLine(&quot;Let me think&quot;);
                     Thread.Sleep(1000);
                 &#125;
                 this.OnOrder(&quot;Gongpao chicken&quot;, &quot;large&quot;);
             &#125;
       
             protected void OnOrder(string dishName,string size)
             &#123;
                 &#x2F;&#x2F;这里用事件的名字取代了字段的名字
                 if (this.Order !&#x3D; null)  &#x2F;&#x2F;微软在设计这个语法糖的时候造成了这个语法的前后不一致
                 &#123;
                     OrderEventArgs e &#x3D; new OrderEventArgs();
                     e.DishName &#x3D; dishName;
                     e.Size &#x3D; size;
                     this.Order.Invoke(this, e);
                 &#125;
             &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

</li>
</ul>
</li>
</ul>
</li>
<li><p>事件的命名约定</p>
<ul>
<li>带有时态的动词或者动词短语</li>
<li>事件拥有者“正在做”什么事情，用进行时；事件拥有者“做完了”什么事情，用完成时</li>
</ul>
</li>
</ul>
<h3 id="12-5-问题辨析"><a href="#12-5-问题辨析" class="headerlink" title="12.5 问题辨析"></a>12.5 问题辨析</h3><ul>
<li>很多有经验的程序员认为事件是特殊的委托</li>
<li>事件真的是“以特殊方式声明的委托字段/实例”吗？<ul>
<li><font color="red">不是！</font>只是声明的时候“看起来像”（对比委托字段与事件的简化声明，field-like）</li>
<li>事件声明的时候使用了委托类型，简化声明造成事件看上去像一个委托的字段（实例），而event关键字则更像是一个修饰符——这就是<font color="FF99##">错觉的来源之一</font></li>
<li>订阅事件的时候 += 操作符后面可以是一个委托实例，这与委托实例的赋值方法语法相同，这也让事件看起来像是一个委托字段——这是<font color="FF99##">错觉的又一来源</font></li>
<li>重申：事件的本质是假装在委托字段上的一个“蒙版”（mask），是个起掩蔽作用的包装器。这个用于阻挡非法操作的“蒙版”绝不是委托字段本身</li>
</ul>
</li>
<li>为什么要使用委托类型来声明事件？<ul>
<li>站在source（事件的拥有者）的角度来看，是为了表明source能对外传递哪些信息</li>
<li>站在subscriber（事件的响应者）的角度来看，它是一种约定，是为了约束能够使用什么样签名的方法来处理（响应）事件</li>
<li>委托类型的实例将用于存储（引用）事件处理器</li>
</ul>
</li>
<li>对比事件与属性<ul>
<li>属性不是字段——<font color="red">很多时候</font>属性是字段的包装器，这个包装器用来保护字段不被滥用</li>
<li>事件不是委托字段——它是委托字段的包装器，这个包装器用来保护委托字段不被滥用</li>
<li>包装器永远都不可能是被包装的东西</li>
</ul>
</li>
</ul>
<h2 id="13-什么是类（Class）"><a href="#13-什么是类（Class）" class="headerlink" title="13.  什么是类（Class）"></a>13.  什么是类（Class）</h2><ul>
<li>《C#语言规范》<ul>
<li>类是一种数据结构，它可以包含数据成员（常量和字段）、函数成员（方法、属性、索引器、运算符、实力构造器、静态构造器和析构器）以及嵌套类型。类类型支持继承，继承是一种机制，它使派生类可以对基类进行扩展和专用华。</li>
</ul>
</li>
</ul>
<h3 id="13-1-什么是类"><a href="#13-1-什么是类" class="headerlink" title="13.1 什么是类"></a>13.1 什么是类</h3><ul>
<li><p>是一种数据结构（data structure）</p>
</li>
<li><p>是一种数据类型</p>
<ul>
<li><p>类是引用类型，例如Student类是自定义的引用类型</p>
</li>
<li><p>```c#<br>using System;</p>
<p>namespace HelloClass<br>{</p>
<pre><code>class Program
&#123;
    static void Main(string[] args)
    &#123;
        Student stu = new Student() &#123; ID=1,Name=&quot;8yyy&quot;&#125;;
        Console.WriteLine(stu.ID);
        Console.WriteLine(stu.Name);
        stu.Report();
    &#125;
&#125;

class Student
&#123;
    public int ID &#123; get; set; &#125;
    public string Name &#123; get; set; &#125;
    public void Report()
    &#123;
        Console.WriteLine($&quot;I&#39;m #&#123;this.ID&#125; student,my name is &#123;this.Name&#125;.&quot;);
    &#125;
&#125;
</code></pre>
<p>}</p>
<pre class="line-numbers language-none"><code class="language-none">
    

- 代表现实世界中的“种类”

  - &#96;&#96;&#96;c#
    using System;
    
    namespace HelloClass
    &#123;
        class Program
        &#123;
            static void Main(string[] args)
            &#123;
                Student stu1 &#x3D; new Student(1, &quot;8yyy&quot;);
                Student stu2 &#x3D; new Student(2, &quot;TimothyLiu&quot;);
                Console.WriteLine(Student.Amount);
            &#125;
        &#125;
    
        class Student
        &#123;
            public static int Amount &#123; get; set; &#125;
            static Student()
            &#123;
                Amount &#x3D; 100; 
            &#125;
            ~Student()&#123;
                Student.Amount--;
            &#125;
            public Student(int id,string name)
            &#123;
                this.ID &#x3D; id;
                this.Name &#x3D; name;
                Student.Amount++;
            &#125;
            public int ID &#123; get; set; &#125;
            public string Name &#123; get; set; &#125;
            public void Report()
            &#123;
                Console.WriteLine($&quot;I&#39;m #&#123;this.ID&#125; student,my name is &#123;this.Name&#125;.&quot;);
            &#125;
        &#125;
    &#125;
    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
</li>
</ul>
<h3 id="13-2-构造器与析构器"><a href="#13-2-构造器与析构器" class="headerlink" title="13.2 构造器与析构器"></a>13.2 构造器与析构器</h3><ul>
<li><p>实例</p>
</li>
<li><p>静态</p>
<ul>
<li>静态构造器用于初始化静态成员</li>
</ul>
</li>
<li><p>如何不使用new操作符创建实例？</p>
<ul>
<li><p>```c#<br>using System;</p>
<p>namespace HelloClass<br>{</p>
<pre><code>class Program
&#123;
    static void Main(string[] args)
    &#123;
        Type t = typeof(Student);
        object o = Activator.CreateInstance(t,1,&quot;8yyy&quot;);
        Student stu = (Student)o;
        Student stu1 = o as Student;
        dynamic stu2 = Activator.CreateInstance(t, 1, &quot;8yyy&quot;);
        Console.WriteLine(stu.Name);
        Console.WriteLine(stu1.Name);
        Console.WriteLine(stu2.Name);
    &#125;
&#125;

class Student
&#123;
    public Student(int id,string name)
    &#123;
        this.ID = id;
        this.Name = name;
    &#125;
    public int ID &#123; get; set; &#125;
    public string Name &#123; get; set; &#125;
    public void Report()
    &#123;
        Console.WriteLine($&quot;I&#39;m #&#123;this.ID&#125; student,my name is &#123;this.Name&#125;.&quot;);
    &#125;
&#125;
</code></pre>
<p>}</p>
<pre class="line-numbers language-none"><code class="language-none">








## 14. 类的声明与访问级别

- 类声明的全貌

  - C#类声明的位置
    - 名称空间里（99%的情况）
    - 看似名称空间外（不推荐的做法，其实声明是在全局名称空间里）
    - 类里，嵌套类
  - 声明即定义（C#与Java）
    - 在C&#x2F;C++中声明和定义是分开的

- 最简单的类声明

  - class 关键字 identifier 类名 class-body 类体
  - 类的访问控制
    - 类默认的访问级别是internal（在本程序集内Assembly可访问，本项目object）
    - 不能使用private，当这个类是某个类的成员的时候可以使用private

- 类成员的访问控制

  - public 均可访问
  - private 类体内可访问，子类不能访问
  - protected 类的继承链上的类可以访问，可以跨程序集
    - 更多应用在方法上
  - internal 本程序集内可访问

- 类的继承

  - &#96;&#96;&#96;c#
    using System;
    
    namespace HelloOOP
    &#123;
        class Program
        &#123;
            static void Main(string[] args)
            &#123;
                Type t &#x3D; typeof(Car);
                Type tb &#x3D; t.BaseType;   &#x2F;&#x2F;结果为HelloOOP.Vehicle，说明Car是Vehicle的派生类
                Type ttop &#x3D; tb.BaseType;    &#x2F;&#x2F;结果为System.Object,说明所有类的基类为Object
                Console.WriteLine(tb.FullName);
                Console.WriteLine(ttop.FullName);
    
            &#125;
        &#125;
    
        class Vehicle
        &#123;
    
        &#125;
    
        class Car : Vehicle
        &#123;
    
        &#125;
    &#125;
    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>三层 System.Object &lt;–  Vehicle &lt;– Car</p>
</li>
<li><p>类在功能上的扩展（extend）</p>
</li>
<li><p>只能由一个基类（base-class），但可以实现多个其接口</p>
<ul>
<li>C++中可以有多个基类</li>
</ul>
</li>
<li><p>类访问级别对其继承的影响</p>
<ul>
<li>子类的访问级别不能超越父类</li>
</ul>
</li>
<li><p>sealed类不能被继承</p>
</li>
<li><p>《是一个 is a 概念》一个派生类的实例从语义上来讲也是基类的实例</p>
<ul>
<li>```c#<br>using System;namespace HelloOOP<br>{<pre><code>class Program
&#123;
    static void Main(string[] args)
    &#123;
        Car car = new Car();
        Console.WriteLine(car is Vehicle);  //True
        Console.WriteLine(car is object);   //True
    &#125;
&#125;

class Vehicle
&#123;

&#125;

class Car : Vehicle
&#123;

&#125;
</code></pre>
}<pre class="line-numbers language-none"><code class="language-none">
- 可以用父类类型的变量来实现子类的实例

- &#96;&#96;&#96;c#
  using System;
  
  namespace HelloOOP
  &#123;
      class Program
      &#123;
          static void Main(string[] args)
          &#123;
              Vehicle vehicle &#x3D; new Car();
              object o1 &#x3D; new Vehicle();
              object o2 &#x3D; new Car();
          &#125;
      &#125;
  
      class Vehicle
      &#123;
  
      &#125;
  
      class Car : Vehicle
      &#123;
  
      &#125;
  &#125;
  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
</li>
<li><p><strong>继承的本质</strong>：继承的本质是派生类在基类已有的成员的基础之上对基类进行<strong>横向</strong>或者<strong>纵向</strong>上的扩展</p>
<ul>
<li>横向扩展指类成员的扩充</li>
<li>纵向扩展指不扩充类成员的个数，对某些类成员的版本扩展（override）</li>
</ul>
</li>
</ul>
</li>
<li><p>成员的继承与访问</p>
<ul>
<li><p>类成员的访问级别的上限是类的访问级别</p>
</li>
<li><p>派生类对继承成员的访问</p>
</li>
<li><p>派生类对基类成员的访问 base</p>
<ul>
<li><p>```c#<br>using System;</p>
<p>namespace HelloOOP<br>{</p>
<pre><code>class Program
&#123;
    static void Main(string[] args)
    &#123;
        Car car = new Car();
        car.ShowOwner();
    &#125;
&#125;

class Vehicle
&#123;
    public Vehicle()
    &#123;
        this.Owner = &quot;N/A&quot;;
    &#125;
    public string Owner &#123; get; set; &#125;
&#125;

class Car : Vehicle
&#123;
    public Car()
    &#123;
        this.Owner = &quot;Car Owner&quot;;
    &#125;
    public void ShowOwner()
    &#123;
        Console.WriteLine(base.Owner);  //访问父类的Owner，在这和下面的结果是一样的，因为子类对父类的Owner进行了重写
        Console.WriteLine(this.Owner);
    &#125;
&#125;
</code></pre>
<p>}</p>
<pre class="line-numbers language-none"><code class="language-none">
  - 用base可以访问父类的Owner，在这和下面的this结果一样，因为子类对父类的Owner进行了重写

- 构造器的不可继承性

  - 当父类只有一个有参的构造器之后

  - 写法1：base

  - &#96;&#96;&#96;c#
    class Vehicle
       &#123;
           public Vehicle(string owner)
           &#123;
               this.Owner &#x3D; owner;
           &#125;
           public string Owner &#123; get; set; &#125;
       &#125;
     
       class Car : Vehicle
       &#123;
           public Car():base(&quot;N&#x2F;A&quot;)
           &#123;
     
           &#125;
           public void ShowOwner()
           &#123;
               Console.WriteLine(base.Owner); 
               Console.WriteLine(this.Owner);
           &#125;
       &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>写法2：</p>
</li>
<li><p>```c#<br>class Vehicle<br>   {</p>
<pre><code>   public Vehicle(string owner)
   &#123;
       this.Owner = owner;
   &#125;
   public string Owner &#123; get; set; &#125;
</code></pre>
<p>   }</p>
<p>   class Car : Vehicle<br>   {</p>
<pre><code>   public Car(string owner):base(owner)
   &#123;
       
   &#125;
</code></pre>
<p>   }</p>
<pre class="line-numbers language-none"><code class="language-none">
    - &lt;font color&#x3D;red&gt;注意：因为在基类构造器里已经把Owner的值设置为owner参数的值了，所以我们不必要在Car的构造器里再设置一遍，让Car里面的构造器空着就可以了&lt;&#x2F;font&gt;

    - 说明实例构造器不被继承

    - 变量名+_下划线，表明实例字段且为私有字段

- 面向对象的实现风格

  - Class-based 基于类
    - 编程界主流
    - C#、Java、C++
  - Prototype-based 基于原型
    - JavaScript

















## 15. 重写，多态

Rider

### 15.1 类的继承

- 类成员的“ 横向扩展 ”（成员越来越多）

- 类成员的“ 纵向扩展 ”（行为改变，版本增高）

- 类成员的隐藏（不常用）

  - 在子类中写了一个和父类一样的方法，就会隐藏掉继承自父类的方法（完全不推荐）

- 重写（Override）

  - 父类成员标记为 **virtual**，子类成员标记为 **override**
  - 注：被标记为 override 的成员，隐含也是 virtual 的，可以继续被重写。

- 重写（Override）与隐藏（Hide）的发生条件：函数成员、可见、签名一致

  - 新手不必过于纠结 Override 和 Hide 的区分、关联。因为原则上是不推荐用 Hide 的。很多时候甚至会视 Hide 为一种错误

  - 函数成员（Function members）

    - ![image-20220923111905199](C:\Users\8y\AppData\Roaming\Typora\typora-user-images\image-20220923111905199.png)

    - Methods 方法 Properties 属性 在多态上体现的比较多

    - &#96;&#96;&#96;c#
      using System;
      
      
      namespace OverrideExample
      &#123;
          class Program
          &#123;
              static void Main(string[] args)
              &#123;
                  Car car &#x3D; new Car();
                  car.Run();
                  Console.WriteLine(car.Speed);
              &#125;
          &#125;
      
          class Vehicle
          &#123;
              private int _speed; &#x2F;&#x2F;_用于表明访问类型为private
              public virtual int Speed &#123; get &#123; return _speed; &#125; set &#123; _speed &#x3D; value; &#125; &#125;
              public virtual void Run()
              &#123;
                  Console.WriteLine(&quot;I&#39;am running&quot;);
                  _speed &#x3D; 100;
              &#125;
          &#125;
      
          class Car : Vehicle
          &#123;
              private int _rpm;
              public override int Speed &#123; get &#123; return _rpm&#x2F;100; &#125; set &#123; _rpm &#x3D; value*100; &#125; &#125;
              public string CarName &#123; get; set; &#125; &#x2F;&#x2F;横向扩展
              public override void Run()  &#x2F;&#x2F;纵向扩展，重写
              &#123;
                  Console.WriteLine(&quot;car is running&quot;);
                  _rpm &#x3D; 5000;
              &#125;
          &#125;
      &#125;
      <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
</li>
<li><p>只有对子类可见的父类成员可以重写， public/protected</p>
</li>
</ul>
</li>
</ul>
<h3 id="15-2-多态（polymorphism）"><a href="#15-2-多态（polymorphism）" class="headerlink" title="15.2 多态（polymorphism）"></a>15.2 多态（polymorphism）</h3><ul>
<li><p><strong>什么是多态？</strong></p>
<ul>
<li><p>父类型变量指向子类型对象；</p>
<ul>
<li><code>class Car : Vehicle</code></li>
<li><code>Vehicle vehicle = new Car();</code></li>
</ul>
</li>
<li><p>父类型中的函数成员被子类重写了；</p>
<ul>
<li><p>```c#<br>public virtual void Run()<br>{</p>
<pre><code>Console.WriteLine(&quot;I&#39;am running&quot;);
</code></pre>
<p>}<br>public override void Run()<br>{</p>
<pre><code>Console.WriteLine(&quot;car is running&quot;);
</code></pre>
<p>}</p>
<pre class="line-numbers language-none"><code class="language-none">
- 当父类型引用调用函数成员时，调用的时子类中重写了的函数成员；

  - &#96;&#96;&#96;
    vehicle.run();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>运行结果为：<strong>car is running</strong></p>
</li>
</ul>
</li>
<li><p>以上就是对多态的描述，它隐含了：继承、重写。</p>
</li>
</ul>
</li>
<li><p>c#的多态性主要体现在类的继承上：子类继承父类的时候，可能出现同名但方法定义不同的情况， 所以在子类中会将原方法覆盖，实现自身的要求</p>
</li>
<li><p>当用父类类型的的变量引用子类类型的的实例，调用被重写的方法，一定是调用<strong>子类</strong>的方法</p>
<ul>
<li>```c#<br>using System;namespace EventExample<br>{<pre><code>class Program
&#123;
    static void Main(string[] args)
    &#123;
        People peopleOne = new Student();
        peopleOne.WhoIam();

        People peopleTwo = new Eight();
        peopleTwo.WhoIam();
        
        Student studentOne = new Eight();
        studentOne.WhoIam();
    &#125;
&#125;

class People
&#123;
    public virtual void WhoIam()
    &#123;
        Console.WriteLine(&quot;I&#39;am people!&quot;);
    &#125;        
&#125;

class Student : People
&#123;
    public override void WhoIam()
    &#123;
        Console.WriteLine(&quot;I&#39;am a student!&quot;);
    &#125;
&#125;

class Eight:Student
&#123;
    public override void WhoIam()
    &#123;
        Console.WriteLine(&quot;I&#39;am 8!&quot;);
    &#125;
&#125;
</code></pre>
}<pre class="line-numbers language-none"><code class="language-none">
- 运行结果如下:

- &#96;&#96;&#96;
  I&#39;am a student!
  I&#39;am 8!
  I&#39;am 8!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
</li>
<li><p>基于重写机制（virtual –&gt; override）</p>
<ul>
<li><p>virtual 可理解为可被重写的，名存实亡的，可被推翻的</p>
</li>
<li><p>```c#<br>using System;</p>
<p>namespace OverrideExample<br>{</p>
<pre><code>class Program
&#123;
    static void Main(string[] args)
    &#123;
        Car car = new Car();
        car.Run();
        Vehicle vehicle = new Car();
        vehicle.Run();
    &#125;
&#125;

class Vehicle
&#123;
    public virtual void Run()
    &#123;
        Console.WriteLine(&quot;I&#39;am running&quot;);
    &#125;
&#125;

class Car : Vehicle
&#123;
    public string CarName &#123; get; set; &#125; //横向扩展
    public override void Run()  //纵向扩展，重写
    &#123;
        Console.WriteLine(&quot;car is running&quot;);
    &#125;
&#125;
</code></pre>
<p>}</p>
<pre class="line-numbers language-none"><code class="language-none">
- 运行结果如下：

- &#96;&#96;&#96;
  car is running
  car is running<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>而在Java中不需要加virtual和override即可实现重写</p>
</li>
</ul>
</li>
<li><p>函数成员的具体行为（版本）由对象决定</p>
</li>
<li><p>回顾：C#语言的变量和对象都是有类型的，所以会有“代差”</p>
</li>
<li><p>Python 是对象有类型，变量没有类型的语言，Python 变量的类型永远跟着对象走。 所以在 Python 中即使重写了，也没有多态的效果。</p>
</li>
</ul>
<h2 id="16-接口，抽象类，SOLID，单元测试，反射"><a href="#16-接口，抽象类，SOLID，单元测试，反射" class="headerlink" title="16. 接口，抽象类，SOLID，单元测试，反射"></a>16. 接口，抽象类，SOLID，单元测试，反射</h2><p><font color="red" size="5">C#中SOLID原则:</font></p>
<ol>
<li><p><strong>S  表示 Single responsibility（单一责任）；</strong></p>
<ul>
<li>单一责任原则，简单来说就是一个类或一个模块，只负责一种或一类职责。</li>
</ul>
</li>
<li><p><strong>O 表示 Open for extension and closed for modification（扩展时打开和修改时关闭，关闭原则）；</strong></p>
<ul>
<li>开闭原则要求类、模块、函数等实体应该对扩展开放，对修改关闭。</li>
</ul>
</li>
<li><p><strong>L  表示 Liskov 替换（里氏替换原则）；</strong></p>
<ul>
<li>子类可以扩展父类的功能，但不能改变基类原有的功能。它有四层含义：<ol>
<li>子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法；</li>
<li>子类中可以增加自己的特有方法；</li>
<li>当子类重载父类的方法时，方法的前置条件（形参）要比父类的输入参数更宽松；</li>
<li>当子类实现父类的抽象方法时，方法的后置条件（返回值）要比父类更严格。</li>
</ol>
</li>
</ul>
</li>
<li><p><strong>I   表示 Interface segregation（接口隔离）；</strong></p>
<ul>
<li><p>接口隔离原则要求客户不依赖于它不使用的接口和方法；一个类对另一个类的依赖应该建立在最小的接口上。</p>
<p>通常的做法，是把一个臃肿的接口拆分成多个更小的接口，以保证客户只需要知道与它相关的方法。</p>
</li>
</ul>
</li>
<li><p><strong>D  表示 Dependency injection（依赖关系注入）。</strong></p>
<ul>
<li>依赖倒置原则要求高层模块不能依赖于低层模块，而是两者都依赖于抽象。另外，抽象不应该依赖于细节，而细节应该依赖于抽象。</li>
</ul>
</li>
</ol>
<p>解释摘自：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/tiger-wang/p/13525841.html">https://www.cnblogs.com/tiger-wang/p/13525841.html</a></p>
<hr>
<ul>
<li><p>为做基类而生的”抽象类“与”开放/关闭原则“</p>
</li>
<li><p>```c#<br>using System;</p>
<p>namespace Example027<br>{</p>
<pre><code>class Program
&#123;
    static void Main(string[] args)
    &#123;
        //Vehicle vehicle = new Vehicle();
        //无法创建抽象类的实例
        Vehicle v = new Car();
        v.Run();
    &#125;
&#125;

abstract class Vehicle
&#123;
    public void Stop()
    &#123;
        Console.WriteLine(&quot;Stopped!&quot;);
    &#125;

    public abstract void Run();
&#125;

class Car:Vehicle
&#123;
    public override void Run()  //实现抽象方法必须使用override
    &#123;
        Console.WriteLine(&quot;Car is running...&quot;);
    &#125;
&#125;


class Truck:Vehicle //卡车
&#123;
    public override void Run()
    &#123;
        Console.WriteLine(&quot;Truck is running...&quot;);
    &#125;

&#125;

//抽象方法必须放在抽象类里
abstract class Student
&#123;
    abstract public void Study();   //像这种就是抽象方法，没有方法体&#123;&#125;，不能是private
&#125;
</code></pre>
<p>}</p>
<pre class="line-numbers language-none"><code class="language-none">
- 一个抽象类里的所有类成员都是抽象的实际上就是接口

- 接口由抽象类进化而来

  - &#96;&#96;&#96;c#
    abstract class VehicleBase
        &#123;
            abstract public void Stop();
            abstract public void Run();
            abstract public void Fill();
        &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><p>将abstract class 改为 interface，去掉 abstract public</p>
</li>
<li><p>接口的默认成员都是public的</p>
</li>
<li><p>```c#<br>interface VehicleBase</p>
<pre><code>&#123;
    void Stop();
    void Run();
    void Fill();
&#125;
</code></pre>
<pre class="line-numbers language-none"><code class="language-none">
  - 派生类的方法的override也需要去掉

- &#96;&#96;&#96;c#
  using System;
  
  namespace Example027
  &#123;
      class Program
      &#123;
          static void Main(string[] args)
          &#123;
              &#x2F;&#x2F;Vehicle vehicle &#x3D; new Vehicle();
              &#x2F;&#x2F;无法创建抽象类的实例
              Vehicle v &#x3D; new Car();
              v.Run();
          &#125;
      &#125;
  
      interface VehicleBase	&#x2F;&#x2F;接口
      &#123;
          void Stop();
          void Run();
          void Fill();
      &#125;
  
      abstract class Vehicle:VehicleBase	&#x2F;&#x2F;需要实现接口的所有成员
      &#123;
          public void Stop()	&#x2F;&#x2F;需要去掉override
          &#123;
              Console.WriteLine(&quot;Stopped!&quot;);
          &#125;
  
          public void Fill()
          &#123;
              Console.WriteLine(&quot;Pay and Fill...&quot;);
          &#125;
          public abstract void Run();
      &#125;
  
      
  
      class Car:Vehicle
      &#123;
          public override void Run()  &#x2F;&#x2F;实现抽象方法必须使用override
          &#123;
              Console.WriteLine(&quot;Car is running...&quot;);
          &#125;
      &#125;
  
      
      class Truck:Vehicle &#x2F;&#x2F;卡车
      &#123;
          public override void Run()
          &#123;
              Console.WriteLine(&quot;Truck is running...&quot;);
          &#125;
  
      &#125;
  &#125;
  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
</li>
<li><p>如果一个接口继承其他接口，那么实现类或结构就需要实现所有接口的成员。</p>
</li>
</ul>
<h3 id="16-1-什么是接口和抽象类"><a href="#16-1-什么是接口和抽象类" class="headerlink" title="16.1 什么是接口和抽象类"></a>16.1 什么是接口和抽象类</h3><ul>
<li><p>接口和抽象类都是“软件工程产物”</p>
</li>
<li><p>具体类 –&gt; 抽象类 –&gt; 接口：越来越抽象，内部实现的东西越来越少</p>
</li>
<li><p><strong>抽象类是未完全实现逻辑的类</strong>（可以有字段和非public成员，它们代表了“具体逻辑”）</p>
<ul>
<li>不能是private的成员</li>
</ul>
</li>
<li><p>抽象类为复用而生：专门作为基类来使用，也就有解耦功能</p>
</li>
<li><p>封装确定的，开放不确定的，推迟到合适的子类中去实现</p>
<ul>
<li>开闭原则</li>
</ul>
</li>
<li><p><strong>接口是完全未实现逻辑的“类”</strong>（“纯虚类”：只有函数成员；成员全部public）</p>
<ul>
<li>听说C# 8.0之后存在接口默认方法</li>
</ul>
</li>
<li><p>接口为解耦而生：”高内聚，低耦合“，方便单元测试</p>
<ul>
<li><p>内聚：每个模块尽可能独立完成自己的功能，不依赖于模块外部的代码。           </p>
<p>耦合：模块与模块之间接口的复杂程度，模块之间联系越复杂耦合度越高，牵一发而动全身。 </p>
<p>目的：使得模块的“可重用性”、“移植性”大大增强 </p>
</li>
<li><p>紧耦合的例子</p>
</li>
<li><p>```c#<br>using System;<br>using System.Collections;</p>
<p>namespace InterfaceExample<br>{</p>
<pre><code>class Program
&#123;
    static void Main(string[] args)
    &#123;
        var engine = new Engine();
        var car = new Car(engine);
        car.Run(3);
        Console.WriteLine(car.Speed);
    &#125;

&#125;

class Engine
    &#123;
        public int RPM &#123; get; private set; &#125;

        public void Work(int gas)
        &#123;
            this.RPM = 1000 * gas;
            //例如将this.RPM = 1000 * gas;改为RPM=0;
        &#125;
    &#125;
</code></pre>
<p>   class Car</p>
<pre><code>    &#123;
        private Engine _engine;
        public Car(Engine engine)
        &#123;
            _engine = engine;
        &#125;

        public int Speed &#123; get; private set; &#125;

        public void Run(int gas)
        &#123;
            _engine.Work(gas);
            this.Speed = _engine.RPM / 100;
        &#125;
    &#125;
</code></pre>
<p>}</p>
<pre class="line-numbers language-none"><code class="language-none">
- Car类依赖于Engine类，Engine出问题，Car也会出问题

- 使用接口低耦合

- &#96;&#96;&#96;c#
  using System;
  using System.Collections;
  
  namespace InterfaceExample
  &#123;
      class Program
      &#123;
          static void Main(string[] args)
          &#123;
              var user &#x3D; new PhoneUser(new NokiaPhone());
              &#x2F;&#x2F;改动new NokiaPhone()即可
              user.UsePhone();
          &#125;
  
      &#125;
  
      class PhoneUser
      &#123;
          private IPhone _phone;
          public PhoneUser(IPhone phone)
          &#123;
              _phone &#x3D; phone;
          &#125;
  
          public void UsePhone()
          &#123;
              _phone.Dail();
              _phone.PickUp();
              _phone.Send();
              _phone.Receive();
          &#125;
      &#125;
  
      interface IPhone
      &#123;
          void Dail();
          void PickUp();
          void Send();
          void Receive();
      &#125;
      class NokiaPhone : IPhone
      &#123;
          public void Dail()
          &#123;
              Console.WriteLine(&quot;Nokia calling...&quot;);
          &#125;
  
          public void PickUp()
          &#123;
              Console.WriteLine(&quot;Hello!This is Tim!&quot;);
          &#125;
  
          public void Receive()
          &#123;
              Console.WriteLine(&quot;Nokia message ring...&quot;);
          &#125;
  
          public void Send()
          &#123;
              Console.WriteLine(&quot;Hello!&quot;);
          &#125;
      &#125;
      class EricssonPhone : IPhone
      &#123;
          public void Dail()
          &#123;
              Console.WriteLine(&quot;Ericsson calling...&quot;);
          &#125;
  
          public void PickUp()
          &#123;
              Console.WriteLine(&quot;Hello!This is Tim!&quot;);
          &#125;
  
          public void Receive()
          &#123;
              Console.WriteLine(&quot;Ericsson ring...&quot;);
          &#125;
  
          public void Send()
          &#123;
              Console.WriteLine(&quot;Hello!&quot;);
          &#125;
      &#125;
  &#125;
  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>只需要改动<code>var user = new PhoneUser(new NokiaPhone());</code>中的<code>new NokiaPhone()</code>，即可更换手机</p>
</li>
</ul>
</li>
<li><p><strong>接口是一个”协约“</strong>，早已为工业生产所熟知（有分工必有协作，有协作必有协约）</p>
<ul>
<li>在面向对象中协作就是类和类之间的协作，协作就意味着产生了依赖关系</li>
</ul>
</li>
<li><p><strong>它们都不能实例化</strong>，只能用来声明变量，引用具体类（concrete class）的实例</p>
</li>
</ul>
<p><img src="/.com//Users\8y\AppData\Roaming\Typora\typora-user-images\image-20220924164637540.png" alt="image-20220924164637540"></p>
<p>接口与单元测试</p>
<ul>
<li>接口的产生：自底向上（重构），自顶向下（设计）<ul>
<li>“自顶向下，逐步求精”（紧耦合形成的金字塔）</li>
<li><img src="/.com//Users\8y\AppData\Roaming\Typora\typora-user-images\image-20220924200503886.png" alt="image-20220924200503886"></li>
</ul>
</li>
<li>C#中接口的实现（隐式，显示，多接口）</li>
<li>语言对面向对象设计的内建支持：依赖反转，接口隔离，开/闭原则<ul>
<li>依赖反转用于平衡“自顶向下，逐步求精”的思路</li>
<li>解耦在代码中的表现就是依赖反转。单元测试就是依赖反转在开发中的直接应用和直接受益者。</li>
<li>依赖关系：服务的使用者和服务的提供者之间有依赖关系，服务的使用者依赖在服务的提供者之上。依赖越直接，耦合越紧密。服务的提供者出问题时，服务的使用者也会出问题。</li>
<li><img src="/.com//Users\8y\AppData\Roaming\Typora\typora-user-images\image-20220925105343376.png" alt="image-20220925105343376"></li>
</ul>
</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using System;
using System.Collections;

namespace InterfaceExample
&#123;
    class Program
    &#123;
        static void Main(string[] args)
        &#123;
            int[] nums1 &#x3D; new int[] &#123; 1, 2, 3, 4, 5 &#125;;
            ArrayList nums2 &#x3D; new ArrayList &#123; 1, 2, 3, 4, 5 &#125;;   &#x2F;&#x2F;object类型，非泛型，需要引入System.Collections类库
            &#x2F;&#x2F;ArrayList实现了IEnumerable接口 支持迭代
            Console.WriteLine(Sum(nums1));
            Console.WriteLine(Avg(nums1));
            Console.WriteLine(Sum1(nums2));
            Console.WriteLine(Avg1(nums2));

        &#125;

        &#x2F;&#x2F;在没有使用接口的情况下,需要四个方法
        static int Sum(int[] nums)&#123;
            int sum &#x3D; 0;
            foreach (var n in nums)
            &#123;
                sum +&#x3D; n;
            &#125;
            return sum;
        &#125;

        static double Avg(int[] nums)
        &#123;
            double sum&#x3D;0;
            int count&#x3D;0;
            foreach (var n in nums)
            &#123;
                sum +&#x3D; n;
                count++;
            &#125;
            return sum &#x2F; count;
        &#125;

        static int Sum1(ArrayList nums)
        &#123;
            int sum &#x3D; 0;
            foreach (var n in nums)
            &#123;
                sum +&#x3D; (int)n;
            &#125;
            return sum;
        &#125;

        static double Avg1(ArrayList nums)
        &#123;
            double sum &#x3D; 0;
            int count &#x3D; 0;
            foreach (var n in nums)
            &#123;
                sum +&#x3D; (int)n;
                count++;
            &#125;
            return sum &#x2F; count;
        &#125;
    &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>使用接口</p>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using System;
using System.Collections;

namespace InterfaceExample
&#123;
    class Program
    &#123;
        static void Main(string[] args)
        &#123;
            int[] nums1 &#x3D; new int[] &#123; 1, 2, 3, 4, 5 &#125;;
            ArrayList nums2 &#x3D; new ArrayList &#123; 1, 2, 3, 4, 5 &#125;;
            Console.WriteLine(Sum(nums1));
            Console.WriteLine(Sum(nums2));

        &#125;

        static int Sum(IEnumerable nums)
        &#123;
            int sum &#x3D; 0;
            foreach (var n in nums)
            &#123;
                sum +&#x3D; (int)n;
            &#125;
            return sum;
        &#125;

        static double Avg(IEnumerable nums)
        &#123;
            double sum &#x3D; 0;
            int count &#x3D; 0;
            foreach (var n in nums)
            &#123;
                sum +&#x3D; (int)n;
                count++;
            &#125;
            return sum &#x2F; count;
        &#125;
    &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在需求方（Sum和Avg函数）只需要传进来的对象能够被迭代，因为要用foreach循环去迭代每一个整数，不要求其他功能。<br>需求方只需要可以被迭代，而供方（整型数组和ArrayList实例）是可以被迭代的。整型数组的基类是Array，它实现了IEnumerable接口，就是说Array对外声称自己遵循这个契约，保证自己可以被迭代。ArrayList同理。<br>因此就不需要再使用具体的int[]类型和ArrayList类型了，统一替换成IEnumerable。<br>摘自：<a target="_blank" rel="noopener" href="https://blog.csdn.net/Mr_Tfos/article/details/115556289">https://blog.csdn.net/Mr_Tfos/article/details/115556289</a></p>
<p>例子2：</p>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using System;
using System.Collections;

namespace InterfaceExample
&#123;
    class Program
    &#123;
        static void Main(string[] args)
        &#123;
            var fan &#x3D; new DeskFan(new PowerSupply());
            Console.WriteLine(fan.Work());
        &#125;
    &#125;

    class PowerSupply &#x2F;&#x2F;电源
    &#123;
        public int GetPower()
        &#123;
            return 210;
        &#125;

    &#125;
    class DeskFan
    &#123;
        private PowerSupply _powerSupply;
        public DeskFan(PowerSupply powerSupply)
        &#123;
            _powerSupply &#x3D; powerSupply;
        &#125;
        public string Work()
        &#123;
            int power &#x3D; _powerSupply.GetPower();
            if(power &lt;&#x3D;0)
            &#123;
                return &quot;Wont work.&quot;;
            &#125;
            else if (power &lt; 100)
            &#123;
                return &quot;Slow.&quot;;
            &#125;
            else if (power &lt; 200)
            &#123;
                return &quot;Work Fine.&quot;;
            &#125;
            else
            &#123;
                return &quot;Warning.&quot;;
            &#125;
        &#125;
    &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>输出结构为<code>Warning.</code></p>
<p>以上这个例子当你想要测试的时候就必须动PowerSupply类，这在实际工作中是不允许的，因为可能还有其他电器需要用到PowerSupply类，你为了测试DeskFan直接改动PowerSupply类就可能导致其他电器不能正常运行，这个紧耦合就会造成很大的问题。</p>
<p>接下来使用接口解耦</p>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using System;
using System.Collections;

namespace InterfaceExample
&#123;
    class Program
    &#123;
        static void Main(string[] args)
        &#123;
            var fan &#x3D; new DeskFan(new PowerSupply());
            Console.WriteLine(fan.Work());
        &#125;
    &#125;

    public interface IPowerSupply
    &#123;
        int GetPower();
    &#125;

    public class PowerSupply:IPowerSupply &#x2F;&#x2F;电源
    &#123;
        public int GetPower()
        &#123;
            return 110;
        &#125;

    &#125;
    public class DeskFan
    &#123;
        private IPowerSupply _powerSupply;
        public DeskFan(IPowerSupply powerSupply)
        &#123;
            _powerSupply &#x3D; powerSupply;
        &#125;
        public string Work()
        &#123;
            int power &#x3D; _powerSupply.GetPower();
            if(power &lt;&#x3D;0)
            &#123;
                return &quot;Wont work.&quot;;
            &#125;
            else if (power &lt; 100)
            &#123;
                return &quot;Slow.&quot;;
            &#125;
            else if (power &lt; 200)
            &#123;
                return &quot;Work Fine.&quot;;
            &#125;
            else
            &#123;
                return &quot;Warning.&quot;;
            &#125;
        &#125;
    &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



















<h3 id="16-2-测试单元"><a href="#16-2-测试单元" class="headerlink" title="16.2 测试单元"></a>16.2 测试单元</h3><ul>
<li>打开测试资源管理器 Ctrl E,T</li>
<li><img src="/.com//Users\8y\AppData\Roaming\Typora\typora-user-images\image-20220925143358131.png" alt="image-20220925143358131"></li>
</ul>
<ul>
<li><p>右键解决方案添加一个<code>xUnit Project</code>，命名为<code>InterfaceExample.Tests</code></p>
</li>
<li><p>将类名改名为<code>DeskFanTests</code></p>
</li>
<li><p>依赖项添加项目引用<code>InterfaceExample</code>，以便使用接口<code>IPowerSupply</code></p>
</li>
<li><p>Solution如下图所示</p>
</li>
<li><p><img src="/.com//Users\8y\AppData\Roaming\Typora\typora-user-images\image-20220925144730231.png" alt="image-20220925144730231"></p>
</li>
<li><p>主要测试代码如下</p>
</li>
<li><p>```c#<br>using System;<br>using Xunit;</p>
<p>namespace InterfaceExample.Tests<br>{</p>
<pre><code>public class DeskFanTests
&#123;
    [Fact]  //特征特性
    //测试case
    public void PowerLowerThanZero_OK()
    &#123;
        var fan = new DeskFan(new PowerSupplyLowerThanZero());
        var expected = &quot;Wont work.&quot;;
        var actual = fan.Work();
        Assert.Equal(expected,actual);
    &#125;
    
    [Fact]
    public void PowerLowerThan200_Warning()
    &#123;
        var fan = new DeskFan(new PowerSupplyHigherThan200());
        var expected = &quot;Warning.&quot;;
        var actual = fan.Work();
        Assert.Equal(expected, actual);
    &#125;
&#125;

class PowerSupplyLowerThanZero : IPowerSupply
&#123;
    public int GetPower()
    &#123;
        return 0;
    &#125;
&#125;

class PowerSupplyHigherThan200 : IPowerSupply
&#123;
    public int GetPower()
    &#123;
        return 220;
    &#125;
&#125;
</code></pre>
<p>}</p>
<pre class="line-numbers language-none"><code class="language-none">
- &#96;[Fact]&#96;代表特征特性，它表明接下来的方法为测试case

- 上述代码运行结果如下：

- 

![image-20220925144857205](C:\Users\8y\AppData\Roaming\Typora\typora-user-images\image-20220925144857205.png)

- 在平时工作中测试case和写代码的重要程度是一样的

- 在上述单元测试里有一个很大的问题，就是为了测试不同的情况，我们需要创建不同的类

- 因此我们可以使用&#96;Moq&#96;，打开&#96;管理NuGet程序包&#96;，安装Moq

- ![image-20220925145225757](C:\Users\8y\AppData\Roaming\Typora\typora-user-images\image-20220925145225757.png)

- 接下来我们就直接用Moq直接创建这种实现接口的实例，而略过创建类的这一步

- &#96;&#96;&#96;c#
  using System;
  using Xunit;
  using Moq;		&#x2F;&#x2F;引入Moq
  
  namespace InterfaceExample.Tests
  &#123;
      public class DeskFanTests
      &#123;
          [Fact]  &#x2F;&#x2F;特征特性
          &#x2F;&#x2F;测试case
          public void PowerLowerThanZero_OK()
          &#123;
              var mock &#x3D; new Mock&lt;IPowerSupply&gt;();
              mock.Setup(ps &#x3D;&gt; ps.GetPower()).Returns(() &#x3D;&gt; 0);
              var fan &#x3D; new DeskFan(mock.Object);
              var expected &#x3D; &quot;Wont work.&quot;;
              var actual &#x3D; fan.Work();
              Assert.Equal(expected,actual);
          &#125;
          [Fact]
          public void PowerLowerThan200_Warning()
          &#123;
              var mock &#x3D; new Mock&lt;IPowerSupply&gt;();
              mock.Setup(ps &#x3D;&gt; ps.GetPower()).Returns(() &#x3D;&gt; 220);
              var fan &#x3D; new DeskFan(mock.Object);
              var expected &#x3D; &quot;Warning.&quot;;
              var actual &#x3D; fan.Work();
              Assert.Equal(expected, actual);
          &#125;
      &#125;
  &#125;
  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>运行结果如下：</p>
</li>
<li><p><img src="/.com//Users\8y\AppData\Roaming\Typora\typora-user-images\image-20220925145753984.png" alt="image-20220925145753984"></p>
</li>
<li><p>简单来说就是一个代码自动生成工具，简化了单元测试的流程</p>
</li>
</ul>
<h3 id="16-3-反射与依赖注入"><a href="#16-3-反射与依赖注入" class="headerlink" title="16.3 反射与依赖注入"></a>16.3 反射与依赖注入</h3><p>可直接参考：<a target="_blank" rel="noopener" href="https://www.sogou.com/link?url=hedJjaC291OfPyaFZYFLI4KQWvqt63NBtcOkgzSJL054AydClNZNQQ">https://www.sogou.com/link?url=hedJjaC291OfPyaFZYFLI4KQWvqt63NBtcOkgzSJL054AydClNZNQQ</a>..</p>
<p>SOILD中的I，<strong>接口隔离原则</strong>（Interface segregation）：调用者不会多要</p>
<p>接口隔离原则要求客户不依赖于它不使用的接口和方法；一个类对另一个类的依赖应该建立在最小的接口上。</p>
<p>通常的做法，是把一个臃肿的接口拆分成多个更小的接口，以保证客户只需要知道与它相关的方法。</p>
<p>例子1：给女朋友买车，日常用车只需要能跑就行，不需要开火</p>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using System;

namespace IspExample
&#123;
    class Program
    &#123;
        static void Main(string[] args)
        &#123;
            var driverOne &#x3D; new Driver(new Car());
            driverOne.Drive();
            var driverTwo &#x3D; new Driver(new LightTank());
            driverTwo.Drive();
            var driverThree &#x3D; new Driver(new HeavyTank());
            driverThree.Drive();
        &#125;
    &#125;

    class Driver	&#x2F;&#x2F;客户即女朋友，只需要Run方法，不多要
    &#123;
        private IVehicle _vehicle;
        public Driver(IVehicle vehicle)
        &#123;
            _vehicle &#x3D; vehicle;
        &#125;

        public void Drive()
        &#123;
            _vehicle.Run();
        &#125;
    &#125;
    interface IVehicle
    &#123;
        void Run();
    &#125;

    class Car : IVehicle
    &#123;
        public void Run()
        &#123;
            Console.WriteLine(&quot;Car is running...&quot;);
        &#125;
    &#125;

    class Truck : IVehicle
    &#123;
        public void Run()
        &#123;
            Console.WriteLine(&quot;Truck is running...&quot;);
        &#125;
    &#125;

    interface IWeapon
    &#123;
        void Fire();
    &#125;

    interface ITank:IVehicle,IWeapon    &#x2F;&#x2F;一个接口可以继承多个接口
    &#123;
    &#125;

    class LightTank : ITank &#x2F;&#x2F;轻型坦克
    &#123;
        public void Fire()
        &#123;
            Console.WriteLine(&quot;Boom!&quot;);
        &#125;
        public void Run()
        &#123;
            Console.WriteLine(&quot;Ka ka ka ...&quot;);
        &#125;
    &#125;

    class MediumTank : ITank
    &#123;
        public void Fire()
        &#123;
            Console.WriteLine(&quot;Boom!!&quot;);
        &#125;
        public void Run()
        &#123;
            Console.WriteLine(&quot;Ka! ka! ka! ...&quot;);
        &#125;
    &#125;

    class HeavyTank : ITank
    &#123;
        public void Fire()
        &#123;
            Console.WriteLine(&quot;Boom!!!&quot;);
        &#125;
        public void Run()
        &#123;
            Console.WriteLine(&quot;Ka!! ka!! ka!! ...&quot;);
        &#125;
    &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>运行结果如下：</p>
<pre class="line-numbers language-none"><code class="language-none">Car is running...
Ka ka ka ...
Ka!! ka!! ka!! ...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p><img src="file://C:/Users/8y/AppData/Roaming/Typora/typora-user-images/image-20220925105343376.png?lastModify=1664238152" alt="image-20220925105343376"></p>
<p>例子2：</p>
<h4 id="16-3-1-手写迭代器"><a href="#16-3-1-手写迭代器" class="headerlink" title="16.3.1 手写迭代器"></a>16.3.1 手写迭代器</h4><p><code>Array</code>和<code>ArrayList</code>均实现了<code>ICollection接口</code>与<code>IEnumerable接口</code></p>
<p><code>ICollection接口</code>继承了<code>IEnumerable接口</code>，也就是说除了实现了<code>IEnumerable接口</code>的功能，还实现了其他的功能</p>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">namespace System.Collections
&#123;
    public interface ICollection : IEnumerable
    &#123;
        int Count &#123; get; &#125;
        bool IsSynchronized &#123; get; &#125;
        object SyncRoot &#123; get; &#125;
        void CopyTo(Array array, int index);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在.net框架中，没有一种集合是只实现了<code>IEnumerable接口</code>，没有实现<code>ICollection接口</code>，所以我们需要自己写一个</p>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using System;
using System.Collections;

namespace IspExample2
&#123;
    class Program
    &#123;
        static void Main(string[] args)
        &#123;             
            int[] nums1 &#x3D; &#123; 1,2,3,4,5&#125;;
            ArrayList nums2 &#x3D; new ArrayList &#123; 1, 2, 3, 4, 5 &#125;;
            Console.WriteLine(Sum(nums1));
            Console.WriteLine(Sum(nums2));
            var roc &#x3D; new ReadOnlyCollection(nums1);
            foreach (var n in roc)
            &#123;
                Console.WriteLine(n);
            &#125;
        &#125;

        static int Sum(ICollection nums)
        &#123;
            int result &#x3D; 0;
            foreach (var n in nums)
            &#123;
                result +&#x3D; (int)n;
            &#125;
            return result;
        &#125;
    &#125;

    class ReadOnlyCollection : IEnumerable  &#x2F;&#x2F;只能被迭代，不能删除添加元素
    &#123;
        private int[] _array;
        public ReadOnlyCollection(int[] array)
        &#123;
            _array &#x3D; array;
        &#125;
        public IEnumerator GetEnumerator() &#x2F;&#x2F;实现接口的代码，需要返回一个IEnumerator类型的实例
        &#123;
            return new Enumerator(this);
        &#125;

        public class Enumerator : IEnumerator	
        &#123;
            private ReadOnlyCollection _collection;
            private int _head;
            public Enumerator(ReadOnlyCollection collection)
            &#123;
                _collection &#x3D; collection;
                _head &#x3D; -1;
            &#125;
            public object Current   &#x2F;&#x2F;数组的_head
            &#123;
                get
                &#123;
                    object o &#x3D; _collection._array[_head];
                    return o;
                &#125;
            &#125;

            public bool MoveNext()
            &#123;
                if (++_head &lt; _collection._array.Length)
                &#123;
                    return true;
                &#125;
                else
                &#123;
                    return false;
                &#125;
            &#125;

            public void Reset()
            &#123;
                _head &#x3D; -1;
            &#125;
        &#125;
    &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>如果我们想用如下语法</p>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">var roc &#x3D; new ReadOnlyCollection(nums1);
Console.WriteLine(Sum(roc));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>那么我们就需要将<code>static int Sum(ICollection nums)</code>更改为<code>static int Sum(IEnumerable nums)</code>，原因是因为<code>ICollection接口</code>实现了其他的方法，而<code>ReadOnlyCollection</code>只实现了<code>IEnumerable接口</code></p>
<p>例子3：显示接口实现（C#独有）</p>
<p>这个杀手不太冷的男主角，杀手的身份需要隐藏</p>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using System;

namespace IspExample3
&#123;
    class Program
    &#123;
        static void Main(string[] args)
        &#123;
            IKiller killer &#x3D; new WarmKill();
            killer.Kill();

            &#x2F;&#x2F;这时候如果我们想调用love方法
            &#x2F;&#x2F;方法1类型转换
            var wk1 &#x3D; killer as WarmKill;
            &#x2F;&#x2F;方法2强制类型转换
            var wk2 &#x3D; (IGentelman)killer;
            
            wk1.Love();
            wk2.Love();
        &#125;
    &#125;

    interface IGentelman
    &#123;
        void Love();
    &#125;

    interface IKiller
    &#123;
        void Kill();
    &#125;

    class WarmKill : IGentelman, IKiller
    &#123;
        public void Love()
        &#123;
            Console.WriteLine(&quot;I will love you forever...&quot;);
        &#125;

        void IKiller.Kill() &#x2F;&#x2F;杀手的身份需要隐藏，所以我们需要显示实现接口成员
        &#123;
            Console.WriteLine(&quot;Let me kill the enemy...&quot;);
        &#125;
    &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>运行结果如下：</p>
<pre class="line-numbers language-none"><code class="language-none">Let me kill the enemy...
I will love you forever...
I will love you forever...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>



<ul>
<li>反射：以不变应万变（更松的耦合）</li>
</ul>
<h4 id="16-3-2-什么是反射"><a href="#16-3-2-什么是反射" class="headerlink" title="16.3.2 什么是反射"></a>16.3.2 什么是反射</h4><ul>
<li><p>.net框架所具有的功能</p>
</li>
<li><p>简单理解：给我一个对象，我能在<strong>不用new操作符</strong>的情况下，也不知道是什么静态类型的情况下，创建一个同类型的对象，还能访问这个对象的各个成员</p>
</li>
<li><p>《C#图解教程》——大多数程序都要处理数据，包括读、写、操作和显示数据。（图形也是数据的一种形式。）然而，对于某些程序来说，它们操作的数据不是数字、文本或图形，而是关于程序和程序类型的信息。</p>
<ul>
<li>有关程序及其类型的数据被成员<strong>元数据</strong>（metadata），它们保存在程序的程序集中。</li>
<li>程序在运行时，可以查看其他程序集或其本身的元数据。运行中的程序查看本身的元数据或其他程序的元数据的行为叫做<strong>反射</strong>（reflection）。</li>
</ul>
</li>
<li><p>对象浏览器是显示元数据的程序的一个示例。它可以读取程序集，然后显示其所包含的类型以及类型的所有特征和成员。</p>
</li>
<li><p>反射是C#/JAVA这类托管类型语言与C/C++这类原生类型语言最大的区别之一</p>
</li>
<li><p>单元测试/泛型等均基于反射</p>
</li>
<li><p><font size="5">2、为什么需要反射</font></p>
</li>
<li><p><strong>原因</strong>：</p>
</li>
<li><ul>
<li>很多时候程序的逻辑并不是在写的时候就能确定，有时需要用户交互时才确定<ul>
<li>此时程序已经属于运行状态（Dynamic，动态）</li>
<li>如果要程序员在静态（static）编写时，去枚举用户可能做的操作，会让程序变得十分臃肿，可读性、可维护性都很烂，并且枚举用户可能做的操作这件事是很难实现的</li>
<li>这是我们需要的这种：<strong>以不变应万变</strong>的能力，就是反射机制</li>
</ul>
</li>
</ul>
</li>
<li><p><font size="5">3、反射优缺点</font></p>
<ul>
<li><p><strong>优点</strong></p>
</li>
<li><ul>
<li>1、反射提高了程序的灵活性和扩展性。</li>
<li>2、降低耦合性，提高自适应能力。</li>
<li>3、它允许程序创建和控制任何类的对象，无需提前硬编码目标类。</li>
</ul>
</li>
<li><p><strong>缺点</strong></p>
</li>
<li><ul>
<li>1、性能问题：反射是去内存中动态拿到对象/类型描述，再用这些描述去创建对象，这个过程是对性能有影响的（使用反射基本上是一种解释操作，用于字段和方法接入时要远慢于直接代码。因此反射机制主要应用在对灵活性和拓展性要求很高的系统框架上，普通程序不建议使用。）</li>
<li>2、使用反射会模糊程序内部逻辑；程序员希望在源代码中看到程序的逻辑，反射却绕过了源代码的技术，因而会带来维护的问题，反射代码比相应的直接代码更复杂。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>部分摘自：<a target="_blank" rel="noopener" href="https://www.sogou.com/link?url=hedJjaC291OfPyaFZYFLI4KQWvqt63NBtcOkgzSJL054AydClNZNQQ">https://www.sogou.com/link?url=hedJjaC291OfPyaFZYFLI4KQWvqt63NBtcOkgzSJL054AydClNZNQQ</a>..</p>
<ul>
<li><p>实例1，用第一个给女朋友买车的例子，反射的基本原理</p>
</li>
<li><p>Main方法的主要代码如下</p>
</li>
<li><p>```c#<br>using System;<br>using System.Reflection;</p>
<p>namespace IspExample<br>{</p>
<pre><code>class Program
&#123;
    static void Main(string[] args)
    &#123;
        ITank tank = new HeavyTank();
        //=========华丽的分割线=========
        var t = tank.GetType();
        object o = Activator.CreateInstance(t);
        //Activator.CreateInstance方法 使用最符合指定参数的构造函数创建指定类型的实例
        MethodInfo fireMi = t.GetMethod(&quot;Fire&quot;);
        MethodInfo runMi = t.GetMethod(&quot;Run&quot;);
        //MethodInfo 发现方法的属性并提供对方法元数据的访问。
        fireMi.Invoke(o, null);
        runMi.Invoke(o, null);
    &#125;
&#125;
</code></pre>
<p>}</p>
<pre class="line-numbers language-none"><code class="language-none">
- 运行结果如下：

- &#96;&#96;&#96;
  Boom!!!
  Ka!! ka!! ka!! ...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>主体程序和插件的关系就是以不变应万变</p>
</li>
<li><p>主体程序一般都会发布包含程序开发接口API，程序开发包SDK</p>
<ul>
<li>程序开发接口API不一定都是接口</li>
<li>依赖注入的高自由度意味着错误率提高，例如调方法时大小写写错，就无法找到对应的方法再成功调用了。</li>
<li>开发插件过程中，为了避免自由度过高导致的错误，我们需要有一定的约束，就是SDK中的API</li>
</ul>
</li>
<li><p>孩子玩具的例子</p>
</li>
<li><p>创建一个.net core的程序控制台应用<code>BabyStroller.App</code></p>
</li>
<li><p>首先使用<code>Console.WriteLine(Environment.CurrentDirectory);</code>获取程序所在文件夹的位置</p>
</li>
<li><p>然后在文件夹内新建一个Animals文件夹</p>
</li>
<li><p>```c#<br>using System;<br>using System.IO;<br>using System.Collections.Generic;<br>using System.Runtime.Loader;</p>
<p>namespace BabyStroller.App<br>{</p>
<pre><code>class Program
&#123;
    static void Main(string[] args)
    &#123;
        //Console.WriteLine(Environment.CurrentDirectory);
        var folder = Path.Combine(Environment.CurrentDirectory, &quot;Animals&quot;);
        //得到Animals文件夹
        var files = Directory.GetFiles(folder);
        //从Path中把所有.dll文件load进来，当然目前是没有文件的
        var animalsTypes = new List&lt;Type&gt;();
        foreach (var file in files)
        &#123;
            var assembly = AssemblyLoadContext.Default.LoadFromAssemblyPath(file);
            //将assembly里所有的动物类型加到animalsTypes里
            var types = assembly.GetTypes();
            foreach (var t in types)
            &#123;
                if (t.GetMethod(&quot;Voice&quot;) != null)
                &#123;
                    animalsTypes.Add(t);
                &#125;
            &#125;
        &#125;


        while (true)
        &#123;
            for (int i = 0; i &lt; animalsTypes.Count; i++)
            &#123;
                Console.WriteLine($&quot;&#123;i+1&#125;.&#123;animalsTypes[i].Name&#125;&quot;);
            &#125;
            Console.WriteLine(&quot;======================&quot;);
            Console.WriteLine(&quot;Please choose animal.&quot;);
            int index = int.Parse(Console.ReadLine());
            if(index&gt;animalsTypes.Count || index &lt; 1)
            &#123;
                Console.WriteLine(&quot;No such an animal.Try again!&quot;);
                continue;
            &#125;

            int times = int.Parse(Console.ReadLine());
            var t = animalsTypes[index - 1];
            var m = t.GetMethod(&quot;Voice&quot;);
            var o = Activator.CreateInstance(t);
            m.Invoke(o, new object[] &#123; times &#125;);
        &#125;
    &#125;
&#125;
</code></pre>
<p>}</p>
<pre class="line-numbers language-none"><code class="language-none">
- 之后创建插件，创建一个类库，解决方案如下，两个类库，每个类库下都有两个类

- ![image-20220926151204152](C:\Users\8y\AppData\Roaming\Typora\typora-user-images\image-20220926151204152.png)

- 每个类里都只有一个&#96;public void Voice(int times)&#96;方法，主要内容类似

- &#96;&#96;&#96;c#
  using System;
  
  namespace Animals.Lib
  &#123;
      public class Cat
      &#123;
          public void Voice(int times)
          &#123;
              for (int i &#x3D; 0; i &lt; times; i++)
              &#123;
                  Console.WriteLine(&quot;Meow!&quot;);
              &#125;
          &#125;
      &#125;
  &#125;
  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>之后右击解决方案<code>生成解决方案</code></p>
</li>
<li><p>右键解决方案，在<code>文件资源管理器中打开文件夹</code>，找到两个dll文件复制到主程序Animals的文件夹下</p>
</li>
<li><p>之后回到主程序<code>BabyStroller.App</code></p>
</li>
<li><p>运行程序结果如下</p>
</li>
<li><p><img src="/.com//Users\8y\AppData\Roaming\Typora\typora-user-images\image-20220926152015097.png" alt="image-20220926152015097"></p>
</li>
<li><p>纯反射，很容易发生错误，接下来开发<strong>程序开发包SDK</strong></p>
</li>
<li><p>右键<code>BabyStroller.App</code>解决方案，添加一个新的类库<code>BabyStroller.SDK</code></p>
</li>
<li><p>删除默认的类class1，添加一个interface<code>IAnimal</code>，代码如下</p>
</li>
<li><p>```c#<br>using System;<br>using System.Collections.Generic;<br>using System.Text;</p>
<p>namespace BabyStroller.SDK<br>{</p>
<pre><code>public interface IAnimal
&#123;
    void Voice(int times);
&#125;
</code></pre>
<p>}</p>
<pre class="line-numbers language-none"><code class="language-none">
- 接下来在添加一个类&#96;UnfinishedAttribute&#96;

- 就是未完成的插件可以用这个特性进行标记，当sdk的提供商扫描到这个特性的时候就知道这个插件还没有完成，就会忽略它的调用

- &#96;&#96;&#96;c#
  using System;
  using System.Collections.Generic;
  using System.Text;
  
  namespace BabyStroller.SDK
  &#123;
      public class UnfinishedAttribute:Attribute
      &#123;
      &#125;
  &#125;
  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>右键<code>BabyStroller.App</code>解决方案进行生成解决方案</p>
</li>
<li><p>右键<code>BabyStroller.SDK</code>，找到dll文件，让第三方进行使用</p>
</li>
<li><p>主体程序需要引用SDK，主体程序解决方案如下：</p>
</li>
<li><p><img src="/.com//Users\8y\AppData\Roaming\Typora\typora-user-images\image-20220926153138910.png" alt="image-20220926153138910"></p>
</li>
<li><p>之后回到第三方插件，为两个类库在依赖项中添加dll文件的引用</p>
</li>
<li><p>程序代码无需做过多修改，只需要加上接口即可</p>
</li>
<li><p>```c#<br>using System;<br>using BabyStroller.SDK;</p>
<p>namespace Animals.Lib<br>{</p>
<pre><code>public class Cat:IAnimal
&#123;
    public void Voice(int times)
    &#123;
        for (int i = 0; i &lt; times; i++)
        &#123;
            Console.WriteLine(&quot;Meow!&quot;);
        &#125;
    &#125;
&#125;
</code></pre>
<p>}</p>
<pre class="line-numbers language-none"><code class="language-none">
- 如果在开发过程发现某个还没有做完，只需要用&#96;[Unfinished]&#96;标注即可

- ![image-20220926153608623](C:\Users\8y\AppData\Roaming\Typora\typora-user-images\image-20220926153608623.png)

- 之后重新生成解决方案，将主程序文件夹下Aniaml文件夹里的两个旧版本第三方插件的dll文件更替为新版本的

- 之后可以对主程序代码进行优化

- 优化1

- &#96;&#96;&#96;c#
  &#x2F;*
                      if (t.GetMethod(&quot;Voice&quot;) !&#x3D; null)
                      &#123;
                          animalsTypes.Add(t);
                      &#125;
                      *&#x2F;
                      if(t.GetInterfaces().Contains(typeof(IAnimal)) &amp;&amp; !t.GetCustomAttributes(false).Contains(typeof(UnfinishedAttribute)))
                      &#123;
                          animalsTypes.Add(t);
                      &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>这样能够减少插件开发者的工作量或者错误使用</p>
</li>
<li><p>优化2</p>
</li>
<li><p>```c#</p>
<pre><code>            //m.Invoke(o, new object[] &#123; times &#125;);
            var a = o as IAnimal;
            a.Voice(times);
</code></pre>
<pre class="line-numbers language-none"><code class="language-none">
- 接下来debug程序发现没有成功过滤掉Cow和Cat

- ![image-20220926155545576](C:\Users\8y\AppData\Roaming\Typora\typora-user-images\image-20220926155545576.png)

- &#96;&#96;&#96;c#
  &#x2F;*
                      if (t.GetMethod(&quot;Voice&quot;) !&#x3D; null)
                      &#123;
                          animalsTypes.Add(t);
                      &#125;
                      *&#x2F;
                      if(t.GetInterfaces().Contains(typeof(IAnimal)))
                      &#123;
                          var isUnfinished &#x3D; t.GetCustomAttributes(false).Any(a &#x3D;&gt; a.GetType() &#x3D;&#x3D; typeof(UnfinishedAttribute));
                          if (isUnfinished) continue;
                          animalsTypes.Add(t);
                      &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>debug后发现成功过滤</p>
<ul>
<li>第一种写法获取到的object[]里面是类本身，Contains里面是类的类型(typeof)，两个肯定是不同的</li>
<li>第二种写法是先获取了object[]里面的类型，也就是a.GetType()这一步，所以判断是对了的</li>
</ul>
</li>
</ul>
<ul>
<li><p>反射与接口的结合</p>
</li>
<li><p>反射与特性的结合</p>
</li>
<li><p>依赖注入：此DI非彼DI，但没有彼DI就没有此DI……</p>
<ul>
<li><p><strong>什么是注入？</strong></p>
<ul>
<li><p>最重要的一点：<strong>Container（容器）</strong></p>
</li>
<li><ul>
<li><p>把各种类型、接口放到容器中，就是“注册”</p>
</li>
<li><ul>
<li>注册类型的时候还可以设置，创建对象时是每次创建都是一个新对象，还是创建一个单例模式（每次要对象都给你同一个实例）</li>
</ul>
</li>
<li><p>后边需要创建实例的时候，向容器“要实例”即可</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>封装好的反射最重要的功能是依赖注入</p>
</li>
<li><p>依赖注入DI（Dependency Injection）</p>
</li>
<li><p>依赖反转原则（Dependency inversion principle）</p>
</li>
<li><p>没有依赖反转原则就没有依赖注入，依赖注入是在依赖反转原则这个概念的基础上，结合接口及反射机制等的应用</p>
</li>
<li><p>添加依赖注入框架，右键 <code>依赖项</code> –&gt; <code>管理NuGet程序包</code> –&gt; 输入<code>DependencyInjection</code></p>
</li>
<li><p>依赖注入的基本用法，Main方法的主要代码如下：</p>
</li>
<li><p>```c#<br>using System;<br>using System.Reflection;<br>using Microsoft.Extensions.DependencyInjection;</p>
<p>namespace IspExample<br>{</p>
<pre><code>class Program
&#123;
    static void Main(string[] args)
    &#123;
        var sc = new ServiceCollection();
        //ServiceCollection 容器
        sc.AddScoped(typeof(ITank), typeof(HeavyTank));
        //往容器里装东西，ITank是静态类型，typeof(ITank)拿到动态类型描述
      var sp = sc.BuildServiceProvider();
        //分割线以上为一次性注册
      //=====================华丽的分割线==============
        ITank tank = sp.GetService&lt;ITank&gt;();
        tank.Fire();
        tank.Run();
    &#125;
&#125;
</code></pre>
<p>}</p>
<pre class="line-numbers language-none"><code class="language-none">
- 优势在于如果在程序过程中有千千万万个&#96;ITank&#96;实例，只需要更改&#96;sc.AddScoped(typeof(ITank), typeof(HeavyTank));&#96;中的&#96;typeof(HeavyTank)&#96;即可

- &#96;&#96;&#96;c#
  using System;
  using System.Reflection;
  using Microsoft.Extensions.DependencyInjection;
  
  namespace IspExample
  &#123;
      class Program
      &#123;
          static void Main(string[] args)
          &#123;
              var sc &#x3D; new ServiceCollection();
              sc.AddScoped(typeof(ITank), typeof(HeavyTank));
              sc.AddScoped(typeof(IVehicle), typeof(Car));
            sc.AddScoped&lt;Driver&gt;();
              &#x2F;&#x2F;Driver是类所以不需要typeof
              var sp &#x3D; sc.BuildServiceProvider();
              &#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;华丽的分割线&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;
              var driver &#x3D; sp.GetService&lt;Driver&gt;();
              driver.Drive();
          &#125;
      &#125;
  &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
</li>
</ul>
<h2 id="17-泛型，partial类，枚举，结构"><a href="#17-泛型，partial类，枚举，结构" class="headerlink" title="17.泛型，partial类，枚举，结构"></a>17.泛型，partial类，枚举，结构</h2><h3 id="17-1-泛型-generic-无处不在"><a href="#17-1-泛型-generic-无处不在" class="headerlink" title="17.1 泛型(generic)无处不在"></a>17.1 泛型(generic)无处不在</h3><ul>
<li><p>为什么需要泛型：避免成员膨胀或者类型膨胀</p>
<ul>
<li><p>本次实例讲的是在一给商店，一开始只卖苹果</p>
</li>
<li><p>```c#<br>using System;</p>
<p>namespace HelloGeneric<br>{</p>
<pre><code>class Program
&#123;
    static void Main(string[] args)
    &#123;
        Apple apple = new Apple() &#123; Color = &quot;Red&quot; &#125;;
        Box box = new Box() &#123; Cargo = apple &#125;;
        Console.WriteLine(box.Cargo.Color);
    &#125;
&#125;

class Apple
&#123;
    public string Color &#123; get; set; &#125;
&#125;

class Box
&#123;
    public Apple Cargo &#123; get; set; &#125;
&#125;
</code></pre>
<p>}</p>
<pre class="line-numbers language-none"><code class="language-none">
- 随着商店经营变好，卖的东西增多，开始卖书了，这时候就需要增加一个&#96;Book类&#96;，也是需要装进&#96;Box&#96;里，让客服带回家

- 这时候就面临四个选择

  - 第一种是为&#96;Book&#96;新准备一个盒子&#96;BookBox类&#96;

    - 产生&#96;类型膨胀&#96;问题，例如随着商品变多，一千种商品需要准备一千种类型

    - &#96;&#96;&#96;c#
      using System;
      
      namespace HelloGeneric
      &#123;
          class Program
          &#123;
              static void Main(string[] args)
              &#123;
                  Apple apple &#x3D; new Apple() &#123; Color &#x3D; &quot;Red&quot; &#125;;
                  AppleBox box &#x3D; new AppleBox() &#123; Apple &#x3D; apple &#125;;
                  Console.WriteLine(box.Apple.Color);
      
                  Book book &#x3D; new Book() &#123; Name &#x3D; &quot;BOOK&quot; &#125;;
                  BooxBox booxBox &#x3D; new BooxBox() &#123; Book &#x3D; book &#125;;
                  Console.WriteLine(booxBox.Book.Name);
      
              &#125;
          &#125;
      
          class Book
          &#123;
              public string Name &#123; get; set; &#125;
          &#125;
      
          class Apple
          &#123;
              public string Color &#123; get; set; &#125;
          &#125;
      
          class AppleBox
          &#123;
              public Apple Apple &#123; get; set; &#125;
          &#125;
      
          class BooxBox
          &#123;
              public Book Book &#123; get; set; &#125;
          &#125;
      &#125;
      <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><p>第二种是在<code>Box类</code>添加一个<code>public Book book &#123; get; set; &#125;</code>属性</p>
<ul>
<li><p>产生成员膨胀的问题，Box类里的成员在大多数时候都用不到</p>
</li>
<li><p>```c#<br>using System;</p>
<p>namespace HelloGeneric<br>{</p>
<pre><code>class Program
&#123;
    static void Main(string[] args)
    &#123;
        Apple apple = new Apple() &#123; Color = &quot;Red&quot; &#125;;
        Book book = new Book() &#123; Name = &quot;8yyy&quot; &#125;;
        Box box1 =new Box()&#123; Apple=apple&#125;;
        Box box2 = new Box() &#123; Book=book &#125;;
        Console.WriteLine(box1.Apple.Color);
        Console.WriteLine(box2.Book.Name);
    &#125;
&#125;

class Book
&#123;
    public string Name &#123; get; set; &#125;
&#125;

class Apple
&#123;
    public string Color &#123; get; set; &#125;
&#125;

class Box
&#123;
    public Apple Apple &#123; get; set; &#125;
    public Book Book &#123; get; set; &#125;
&#125;
</code></pre>
<p>}</p>
<pre class="line-numbers language-none"><code class="language-none">
- 第三种是在&#96;Box类&#96;里声明Object类型的成员

  - &#96;public Object Cargo &#123; get; set; &#125;&#96;
  - &#96;Console.WriteLine((box1.Cargo as Apple)?.Color);&#96;
    - 输出结果时需要强制类型转换
    - ？的意思是如果是Apple类型的就输出Color的值，否则输出null值
    - 装盒省事了，把东西从盒子里拿出来复杂了

- 第四种是泛型

  - Box修改如下

  - &#96;&#96;&#96;c#
    class Box&lt;TCargo&gt;
        &#123;
            public TCargo Cargo &#123; get; set; &#125;
        &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>在使用泛型实体前都需要特化，就是给定具体类型</p>
</li>
<li><p>```c#<br>static void Main(string[] args)</p>
<pre><code>    &#123;
        Apple apple = new Apple() &#123; Color = &quot;Red&quot; &#125;;
        Book book = new Book() &#123; Name = &quot;8yyy&quot; &#125;;
        Box&lt;Apple&gt; box1 = new Box&lt;Apple&gt;();
        Box&lt;Book&gt; box2 = new Box&lt;Book&gt;();
        Console.WriteLine(box1.Cargo.Color);
        Console.WriteLine(box2.Cargo.Name);
    &#125;
</code></pre>
<pre class="line-numbers language-none"><code class="language-none">
- 泛型的其他例子

  - &#96;&#96;&#96;c#
    using System;
    
    namespace HelloGeneric
    &#123;
        class Program
        &#123;
            static void Main(string[] args)
            &#123;
                Student&lt;int&gt; stu &#x3D; new Student&lt;int&gt;();
                stu.ID &#x3D; 101;
                stu.Name &#x3D; &quot;8yyy&quot;;
            &#125;
        &#125;
    
    
        interface IUnique&lt;TId&gt;
        &#123;
            TId ID &#123; get; set; &#125;
        &#125;
    
        class Student&lt;TId&gt; : IUnique&lt;TId&gt;   &#x2F;&#x2F;一个类实现了一个泛型接口，那么这个类本身也是泛型的
        &#123;
            public TId ID &#123; get &#x3D;&gt; throw new NotImplementedException(); set &#x3D;&gt; throw new NotImplementedException(); &#125;
            public string Name &#123; get; set; &#125;
        &#125;
    &#125;
    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
</li>
<li><p>当继承接口的时候直接特化，类就可以不再是泛型的</p>
<ul>
<li><p>类之间实现特化之后的泛型接口</p>
</li>
<li><p>```c#<br>class Student : IUnique<int>   </int></p>
<pre><code>&#123;
    public int ID &#123; get =&gt; throw new NotImplementedException(); set =&gt; throw new NotImplementedException(); &#125;
    public string Name &#123; get; set; &#125;
&#125;
</code></pre>
<pre class="line-numbers language-none"><code class="language-none">
- 泛型的基接口的名称空间&#96;using System.Collections.Generic;&#96;

  - &#96;&#96;&#96;c#
    using System;
    using System.Collections.Generic;
    
    namespace HelloGeneric
    &#123;
        class Program
        &#123;
            static void Main(string[] args)
            &#123;
                IList&lt;int&gt; list &#x3D; new List&lt;int&gt;();
                &#x2F;&#x2F;IList泛型接口，List泛型类
                for (int i &#x3D; 0; i &lt; 100; i++)
                &#123;
                    list.Add(i);
                &#125;
    
                foreach (var item in list)
                &#123;
                    Console.WriteLine(item);
                &#125;
            &#125;
        &#125;
    
    
    &#125;
    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
</li>
</ul>
</li>
<li><p>一个方法就是一个算法</p>
</li>
<li><p>```c#<br>using System;<br>using System.Collections.Generic;</p>
<p>namespace HelloGeneric<br>{</p>
<pre><code>class Program
&#123;
    static void Main(string[] args)
    &#123;
        int[] a1 = &#123; 1, 2, 3, 4, 5 &#125;;
        int[] a2 = &#123; 1, 2, 3, 4, 5, 6 &#125;;
        double[] a3 = &#123; 1.1, 2.2, 3.3, 4.4, 5.5 &#125;;
        double[] a4 = &#123; 1.1, 2.2, 3.3, 4.4, 5.5 ,6.6&#125;;
        var result = Zip(a1, a2);
        Console.WriteLine(string.Join(&quot;,&quot;,result));
    &#125;

    static int[] Zip(int[] a, int[] b)
    &#123;
        int[] zipped = new int[a.Length + b.Length];
        int ai = 0, bi = 0, zi = 0;
        do
        &#123;
            if (ai &lt; a.Length) zipped[zi++] = a[ai++];
            if (bi &lt; b.Length) zipped[zi++] = b[bi++];
        &#125; while (ai &lt; a.Length || bi &lt; b.Length);
        return zipped;
    &#125;
&#125;
</code></pre>
<p>}</p>
<pre class="line-numbers language-none"><code class="language-none">
- 有 如上一个例子，&#96;Zip方法&#96;用于将两个&#96;int型&#96;的数组依次交替组成一个数组

- 现在我们有两个&#96;double型&#96;的数组，我们也想把这两个数组一次交替组成一个数组，那么我们就需要用到泛型

- 使用Ctrl+F 全部替换

- ![image-20220927104134768](C:\Users\8y\AppData\Roaming\Typora\typora-user-images\image-20220927104134768.png)

- 我们将代码改为如下形式

- &#96;&#96;&#96;c#
  static T[] Zip&lt;T&gt;(T[] a, T[] b)
          &#123;
              T[] zipped &#x3D; new T[a.Length + b.Length];
              int ai &#x3D; 0, bi &#x3D; 0, zi &#x3D; 0;
              do
              &#123;
                  if (ai &lt; a.Length) zipped[zi++] &#x3D; a[ai++];
                  if (bi &lt; b.Length) zipped[zi++] &#x3D; b[bi++];
              &#125; while (ai &lt; a.Length || bi &lt; b.Length);
              return zipped;
          &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
</li>
<li><p>正交性：泛型类型(类/接口/委托…）、泛型成员(属性/方法/字段…）</p>
<ul>
<li><p>泛型与其他的变成实体都存在一个交叉点——正交点</p>
</li>
<li><p>泛型委托</p>
<ul>
<li><p>Action委托</p>
</li>
<li><p>```c#<br>using System;<br>using System.Collections.Generic;</p>
<p>namespace HelloGeneric<br>{</p>
<pre><code>class Program
&#123;
    static void Main(string[] args)
    &#123;
        Action&lt;string&gt; ac1 = Hello;
        ac1(&quot;8yyy&quot;);
        Action&lt;int&gt; ac2 = Mul;
        ac2(100);
    &#125;

    static void Hello(string name)
    &#123;
        Console.WriteLine($&quot;Hello,&#123;name&#125;&quot;);
    &#125;

    static void Mul(int x)
    &#123;
        Console.WriteLine(x*100);
    &#125;
&#125;
</code></pre>
<p>}</p>
<pre class="line-numbers language-none"><code class="language-none">
- 运行结果如下：

- &#96;&#96;&#96;
  Hello,8yyy
  10000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>Func委托</p>
</li>
<li><p>```c#<br>using System;<br>using System.Collections.Generic;</p>
<p>namespace HelloGeneric<br>{</p>
<pre><code>class Program
&#123;
    static void Main(string[] args)
    &#123;
        Func&lt;int, int, int&gt; func1 = Add;
        int res = func1(100, 200);
        Console.WriteLine(res);
    &#125;

    static int Add(int a,int b)
    &#123;
        return a + b;
    &#125;

    static double Add(double a, double b)
    &#123;
        return a + b;
    &#125;
&#125;
</code></pre>
<p>}</p>
<pre class="line-numbers language-none"><code class="language-none">
      

- 类型方法的参数推断

- 泛型与委托、lambda表达式

  - 对于逻辑非常简单的方法，在调用的地方谁调用谁声明，并且是匿名声明。

  - 使用lambda表达式，Func泛型委托

  - &#96;&#96;&#96;c#
    static void Main(string[] args)
            &#123;
                Func&lt;int, int, int&gt; func1 &#x3D; (int a, int b) &#x3D;&gt; &#123; return a + b; &#125;;
                int res &#x3D; func1(100, 200);
                Console.WriteLine(res);
            &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
</li>
<li><p><code>(int a, int b) =&gt; &#123; return a + b; &#125;;</code>这段代码的逻辑就等价于以下Add方法</p>
<ul>
<li>```c#<br>static int Add(int a,int b)<pre><code>    &#123;
        return a + b;
    &#125;
</code></pre>
<pre class="line-numbers language-none"><code class="language-none">
  - 同时我们可以使用简化，因为在声明Func泛型时已经表明变量是int型的了

    - &#96;(a,b) &#x3D;&gt; &#123; return a + b; &#125;;&#96;

  







### 17.2 partial类

**什么是partial类？**

C#运行我们把一个类的代码分成两个部分甚至多个部分进行编写

同一个类分割成多个partial类，类名称是相同的，partial类的编写进度可以各自控制，最后合成为一个类。

partial类还有一个功能，就是允许不同的partial类可以使用不同编程语言来写，然后最后合成为一个类，仍然不影响。

- **为什么需要partial类？**减少类的派生
- partial类与Entity Framework
- partia类与Windows Forns, WPF, ASP.NET Core



首先由一个Bookstore数据库

![image-20220927113437000](C:\Users\8y\AppData\Roaming\Typora\typora-user-images\image-20220927113437000.png)



.net core 没有ADO.NET Entity Data Model。

需要新建一个.net framework的解决方案

添加ADO.NET Entity Data Model，结果如下

![image-20220927140903136](C:\Users\8y\AppData\Roaming\Typora\typora-user-images\image-20220927140903136.png)



&#96;&#96;&#96;c#
        static void Main(string[] args)
        &#123;
            var dbContext &#x3D; new BookstoreEntities();
            var books &#x3D; dbContext.Book;
            foreach (var book in books)
            &#123;
                Console.WriteLine(book.Name);
            &#125;
        &#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/.com//Users\8y\AppData\Roaming\Typora\typora-user-images\image-20220927142323374.png" alt="image-20220927142323374"></p>
<p><img src="/.com//Users\8y\AppData\Roaming\Typora\typora-user-images\image-20220927142454032.png" alt="image-20220927142454032"></p>
<p>再对泛型里面的Book类型F12查看定义</p>
<p><img src="/.com//Users\8y\AppData\Roaming\Typora\typora-user-images\image-20220927142529205.png" alt="image-20220927142529205"></p>
<p>右键<code>Bookstore.Client</code>项目添加一个类<code>BookstorePart2</code>，将上述代码复制到里面，修改如下：</p>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">namespace Bookstore.Client
&#123;
    using System;
    using System.Collections.Generic;

    public partial class Book
    &#123;
        public string Report()
        &#123;
            return $&quot;ID:&#123;this.ID&#125; Name:&#123;this.Name&#125; Price:&#123;this.Price&#125;&quot;;
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>然后在SQL server新填一个字段Author，回到Model<code>从数据库更新模型</code>，效果如下</p>
<p><img src="/.com//Users\8y\AppData\Roaming\Typora\typora-user-images\image-20220927143649995.png" alt="image-20220927143649995"></p>
<p>回到Book类的定义，你会发现存在两个声明，其中原来的那个也进行了修改</p>
<p><img src="/.com//Users\8y\AppData\Roaming\Typora\typora-user-images\image-20220927143734398.png" alt="image-20220927143734398"></p>
<p>写在partial类的另外一部分<code>BookstorePart2</code>没受到任何影响</p>
<h3 id="17-3-枚举类型"><a href="#17-3-枚举类型" class="headerlink" title="17.3 枚举类型"></a>17.3 枚举类型</h3><ul>
<li>人为限定取值范围的整数</li>
<li>整数值的对应<ul>
<li>默认为0123…</li>
</ul>
</li>
<li>比特位式用法<ul>
<li>读取文件</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using System;

namespace HelloEnum
&#123;
    class Program
    &#123;
        static void Main(string[] args)
        &#123;
            Person personOne &#x3D; new Person() &#123; Name &#x3D; &quot;8yyy&quot;,Level&#x3D;Level.BigBoos &#125;;
            Console.WriteLine((int)Level.Employee);
            Console.WriteLine((int)Level.Manager);
            Console.WriteLine((int)Level.Boos);
            Console.WriteLine((int)Level.BigBoos);

            Person personTwo &#x3D; new Person() &#123; Name&#x3D;&quot;Timothy&quot;&#125;;
            personTwo.Skill &#x3D; Skill.Cook | Skill.Drive | Skill.Program | Skill.Teach;
            Console.WriteLine((personTwo.Skill &amp; Skill.Cook)&gt;0);    &#x2F;&#x2F;比特位式用法,返回Ture则说明会做饭

        &#125;
    &#125;

    enum Level&#123;
        Employee&#x3D;100,       &#x2F;&#x2F;人为限定取值范围的整数
        Manager,
        Boos&#x3D;301,
        BigBoos,
    &#125;

    &#x2F;&#x2F;比特位式用法
    enum Skill
    &#123;
        Cook&#x3D;1,
        Drive&#x3D;2,
        Program&#x3D;4,
        Teach&#x3D;8,
    &#125;

    class Person
    &#123;
        public string Name &#123; get; set; &#125;
        public Level Level &#123; get; set; &#125;
        public Skill Skill &#123; get; set; &#125;
    &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>运行结果如下：</p>
<pre class="line-numbers language-none"><code class="language-none">100
101
301
302
True<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h3 id="17-4-结构体（struct）"><a href="#17-4-结构体（struct）" class="headerlink" title="17.4 结构体（struct）"></a>17.4 结构体（struct）</h3><ul>
<li>值类型，可装/拆箱</li>
<li>可实现接口，不能派生自类/结构体</li>
<li>不能又显示无参构造器</li>
</ul>
<h3 id="17-5-Lambda表达式"><a href="#17-5-Lambda表达式" class="headerlink" title="17.5 Lambda表达式"></a>17.5 Lambda表达式</h3><p>1.匿名方法</p>
<p>2.Inline方法</p>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using System;

namespace Combine
&#123;
    class Program
    &#123;
        static void Main(string[] args)
        &#123;
            &#x2F;&#x2F;可省略(int a,int b)中的int
            Func&lt;int, int, int&gt; func &#x3D; new Func&lt;int, int, int&gt;((a,b)&#x3D;&gt; &#123; return a + b; &#125;);
            int res &#x3D; func(3, 5);
            Console.WriteLine(res) ;

            func &#x3D; new Func&lt;int, int, int&gt;((a, b) &#x3D;&gt; &#123; return a * b; &#125;);
            res &#x3D; func(5 , 7);
            Console.WriteLine(res);

            &#x2F;&#x2F;可省略委托实例
            func &#x3D; (a, b) &#x3D;&gt; &#123; return a - b; &#125;;
            res &#x3D; func(8, 9);
            Console.WriteLine(res);

            &#x2F;&#x2F;可省略return
            func &#x3D; (a, b) &#x3D;&gt; (a+b+1);
            res &#x3D; func(10, 12);
            Console.WriteLine(res);
        &#125;
    &#125;

&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>运行结果如下：</p>
<pre class="line-numbers language-none"><code class="language-none">8
35
-1
23<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>



<p>泛型方法+泛型委托参数+泛型参数</p>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using System;

namespace Combine
&#123;
    class Program
    &#123;
        static void Main(string[] args)
        &#123;
            &#x2F;&#x2F;&lt;int&gt;也可以省略，泛型委托的类型参数推断
            DoSomeCalc&lt;int&gt;((a, b) &#x3D;&gt; (a + b), 5, 6);
        &#125;

        static void DoSomeCalc&lt;T&gt;(Func&lt;T,T,T&gt; func,T x, T y)
        &#123;
            T res &#x3D; func(x, y);
            Console.WriteLine(res);
        &#125;
    &#125;

&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>运行结果为11</p>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">8yyy</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="http://example.com/2022/10/02/%E5%88%98%E9%93%81%E7%8C%9B%E3%80%8AC-%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E8%AF%A6%E8%A7%A3%E3%80%8B%E7%AC%94%E8%AE%B0/">http://example.com/2022/10/02/%E5%88%98%E9%93%81%E7%8C%9B%E3%80%8AC-%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E8%AF%A6%E8%A7%A3%E3%80%8B%E7%AC%94%E8%AE%B0/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">8yyy</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/CSharp/">
                                    <span class="chip bg-color">CSharp</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/8yyy/8yyy.github.io/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="https://cdn.jsdelivr.net/gh/8yyy/8yyy.github.io/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="https://cdn.jsdelivr.net/gh/8yyy/8yyy.github.io/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="https://cdn.jsdelivr.net/gh/8yyy/8yyy.github.io/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="far fa-dot-circle"></i>&nbsp;本篇
            </div>
            <div class="card">
                <a href="/2022/10/02/%E5%88%98%E9%93%81%E7%8C%9B%E3%80%8AC-%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E8%AF%A6%E8%A7%A3%E3%80%8B%E7%AC%94%E8%AE%B0/">
                    <div class="card-image">
                        
                        
                        <img src="https://cdn.jsdelivr.net/gh/8yyy/8yyy.github.io/medias/featureimages/12.jpg" class="responsive-img" alt="刘铁猛《C#语言入门详解》笔记">
                        
                        <span class="card-title">刘铁猛《C#语言入门详解》笔记</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2022-10-02
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            8yyy
                            
                        </span>
                    </div>
                </div>

                
                <div class="card-action article-tags">
                    
                    <a href="/tags/CSharp/">
                        <span class="chip bg-color">CSharp</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2022/10/02/%E6%A0%87%E9%A2%98test/">
                    <div class="card-image">
                        
                        
                        <img src="https://cdn.jsdelivr.net/gh/8yyy/8yyy.github.io/medias/featureimages/0.jpg" class="responsive-img" alt="">
                        
                        <span class="card-title"></span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2022-10-02
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            8yyy
                            
                        </span>
                    </div>
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/8yyy/8yyy.github.io/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/8yyy/8yyy.github.io/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/8yyy/8yyy.github.io/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/8yyy/8yyy.github.io/libs/codeBlock/codeShrink.js"></script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="https://cdn.jsdelivr.net/gh/8yyy/8yyy.github.io/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/8yyy/8yyy.github.io/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="503838841"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="https://cdn.jsdelivr.net/gh/8yyy/8yyy.github.io/libs/aplayer/APlayer.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/8yyy/8yyy.github.io/libs/aplayer/Meting.min.js"></script>

    

    <div class="container row center-align"
         style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2019-2022</span>
            
            <a href="/about" target="_blank">8yyy</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            
            
                
            
            
                <span id="busuanzi_container_site_pv">
                &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;
                    <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
                <span id="busuanzi_container_site_uv">
                &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;
                    <span id="busuanzi_value_site_uv" class="white-color"></span>
            </span>
            
            <br>

            <!-- 运行天数提醒. -->
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">


    <a href="mailto:1410868939@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=1410868939" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 1410868939" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="https://cdn.jsdelivr.net/gh/8yyy/8yyy.github.io/libs/materialize/materialize.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/8yyy/8yyy.github.io/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/8yyy/8yyy.github.io/libs/aos/aos.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/8yyy/8yyy.github.io/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/8yyy/8yyy.github.io/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/8yyy/8yyy.github.io/js/matery.js"></script>

    

    

    <!-- 雪花特效 -->
    

    <!-- 鼠标星星特效 -->
    

     
        <script src="https://ssl.captcha.qq.com/TCaptcha.js"></script>
        <script src="https://cdn.jsdelivr.net/gh/8yyy/8yyy.github.io/libs/others/TencentCaptcha.js"></script>
        <button id="TencentCaptcha" data-appid="xxxxxxxxxx" data-cbfn="callback" type="button" hidden></button>
    

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="https://cdn.jsdelivr.net/gh/8yyy/8yyy.github.io/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="https://cdn.jsdelivr.net/gh/8yyy/8yyy.github.io/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <!--腾讯兔小巢-->
    
    

    

    

    
    <script src="https://cdn.jsdelivr.net/gh/8yyy/8yyy.github.io/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
